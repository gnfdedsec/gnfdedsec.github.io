const w0 = function () {
	const e = document.createElement('link').relList;
	if (e && e.supports && e.supports('modulepreload')) return;
	for (const n of document.querySelectorAll('link[rel="modulepreload"]'))
		i(n);
	new MutationObserver((n) => {
		for (const a of n)
			if (a.type === 'childList')
				for (const s of a.addedNodes)
					s.tagName === 'LINK' && s.rel === 'modulepreload' && i(s);
	}).observe(document, { childList: !0, subtree: !0 });
	function t(n) {
		const a = {};
		return (
			n.integrity && (a.integrity = n.integrity),
			n.referrerpolicy && (a.referrerPolicy = n.referrerpolicy),
			n.crossorigin === 'use-credentials'
				? (a.credentials = 'include')
				: n.crossorigin === 'anonymous'
					? (a.credentials = 'omit')
					: (a.credentials = 'same-origin'),
			a
		);
	}
	function i(n) {
		if (n.ep) return;
		n.ep = !0;
		const a = t(n);
		fetch(n.href, a);
	}
};
w0();
var _0 = Object.defineProperty,
	xh = Object.getOwnPropertySymbols,
	M0 = Object.prototype.hasOwnProperty,
	S0 = Object.prototype.propertyIsEnumerable,
	bh = (r, e, t) =>
		e in r
			? _0(r, e, {
				enumerable: !0,
				configurable: !0,
				writable: !0,
				value: t
			})
			: (r[e] = t),
	T0 = (r, e) => {
		for (var t in e || (e = {})) M0.call(e, t) && bh(r, t, e[t]);
		if (xh) for (var t of xh(e)) S0.call(e, t) && bh(r, t, e[t]);
		return r;
	};
const E0 = function () {
	const r = document.createElement('link').relList;
	if (r && r.supports && r.supports('modulepreload')) return;
	for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
		t(i);
	new MutationObserver((i) => {
		for (const n of i)
			if (n.type === 'childList')
				for (const a of n.addedNodes)
					a.tagName === 'LINK' && a.rel === 'modulepreload' && t(a);
	}).observe(document, { childList: !0, subtree: !0 });
	function e(i) {
		const n = {};
		return (
			i.integrity && (n.integrity = i.integrity),
			i.referrerpolicy && (n.referrerPolicy = i.referrerpolicy),
			i.crossorigin === 'use-credentials'
				? (n.credentials = 'include')
				: i.crossorigin === 'anonymous'
					? (n.credentials = 'omit')
					: (n.credentials = 'same-origin'),
			n
		);
	}
	function t(i) {
		if (i.ep) return;
		i.ep = !0;
		const n = e(i);
		fetch(i.href, n);
	}
};
E0();
function ou(r, e) {
	const t = Object.create(null),
		i = r.split(',');
	for (let n = 0; n < i.length; n++) t[i[n]] = !0;
	return e ? (n) => !!t[n.toLowerCase()] : (n) => !!t[n];
}
const A0 =
        'itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly',
	L0 = ou(A0);
function gm(r) {
	return !!r || r === '';
}
function cn(r) {
	if (ze(r)) {
		const e = {};
		for (let t = 0; t < r.length; t++) {
			const i = r[t],
				n = xt(i) ? C0(i) : cn(i);
			if (n) for (const a in n) e[a] = n[a];
		}
		return e;
	} else if (xt(r) || bt(r)) return r;
}
const R0 = /;(?![^(]*\))/g,
	k0 = /:(.+)/;
function C0(r) {
	const e = {};
	return (
		r.split(R0).forEach((t) => {
			if (t) {
				const i = t.split(k0);
				i.length > 1 && (e[i[0].trim()] = i[1].trim());
			}
		}),
		e
	);
}
function nr(r) {
	let e = '';
	if (xt(r)) e = r;
	else if (ze(r))
		for (let t = 0; t < r.length; t++) {
			const i = nr(r[t]);
			i && (e += i + ' ');
		}
	else if (bt(r)) for (const t in r) r[t] && (e += t + ' ');
	return e.trim();
}
const vr = (r) =>
		xt(r)
			? r
			: r == null
				? ''
				: ze(r) || (bt(r) && (r.toString === bm || !He(r.toString)))
					? JSON.stringify(r, vm, 2)
					: String(r),
	vm = (r, e) =>
		e && e.__v_isRef
			? vm(r, e.value)
			: Kn(e)
				? {
					[`Map(${e.size})`]: [...e.entries()].reduce(
						(t, [i, n]) => ((t[`${i} =>`] = n), t),
						{}
					)
				}
				: ym(e)
					? { [`Set(${e.size})`]: [...e.values()] }
					: bt(e) && !ze(e) && !wm(e)
						? String(e)
						: e,
	st = {},
	$n = [],
	Dr = () => {},
	P0 = () => !1,
	I0 = /^on[^a-z]/,
	Ho = (r) => I0.test(r),
	lu = (r) => r.startsWith('onUpdate:'),
	Pt = Object.assign,
	cu = (r, e) => {
		const t = r.indexOf(e);
		t > -1 && r.splice(t, 1);
	},
	D0 = Object.prototype.hasOwnProperty,
	qe = (r, e) => D0.call(r, e),
	ze = Array.isArray,
	Kn = (r) => Go(r) === '[object Map]',
	ym = (r) => Go(r) === '[object Set]',
	He = (r) => typeof r == 'function',
	xt = (r) => typeof r == 'string',
	uu = (r) => typeof r == 'symbol',
	bt = (r) => r !== null && typeof r == 'object',
	xm = (r) => bt(r) && He(r.then) && He(r.catch),
	bm = Object.prototype.toString,
	Go = (r) => bm.call(r),
	O0 = (r) => Go(r).slice(8, -1),
	wm = (r) => Go(r) === '[object Object]',
	hu = (r) =>
		xt(r) && r !== 'NaN' && r[0] !== '-' && '' + parseInt(r, 10) === r,
	bo = ou(
		',key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted'
	),
	Vo = (r) => {
		const e = Object.create(null);
		return (t) => e[t] || (e[t] = r(t));
	},
	N0 = /-(\w)/g,
	Or = Vo((r) => r.replace(N0, (e, t) => (t ? t.toUpperCase() : ''))),
	z0 = /\B([A-Z])/g,
	ga = Vo((r) => r.replace(z0, '-$1').toLowerCase()),
	Wo = Vo((r) => r.charAt(0).toUpperCase() + r.slice(1)),
	wl = Vo((r) => (r ? `on${Wo(r)}` : '')),
	os = (r, e) => !Object.is(r, e),
	wo = (r, e) => {
		for (let t = 0; t < r.length; t++) r[t](e);
	},
	Ro = (r, e, t) => {
		Object.defineProperty(r, e, {
			configurable: !0,
			enumerable: !1,
			value: t
		});
	},
	ko = (r) => {
		const e = parseFloat(r);
		return isNaN(e) ? r : e;
	};
let wh;
const U0 = () =>
	wh ||
    (wh =
        typeof globalThis != 'undefined'
        	? globalThis
        	: typeof self != 'undefined'
        		? self
        		: typeof window != 'undefined'
        			? window
        			: typeof global != 'undefined'
        				? global
        				: {});
let Lr;
class B0 {
	constructor(e = !1) {
		(this.active = !0),
		(this.effects = []),
		(this.cleanups = []),
		!e &&
                Lr &&
                ((this.parent = Lr),
                (this.index = (Lr.scopes || (Lr.scopes = [])).push(this) - 1));
	}
	run(e) {
		if (this.active) {
			const t = Lr;
			try {
				return (Lr = this), e();
			} finally {
				Lr = t;
			}
		}
	}
	on() {
		Lr = this;
	}
	off() {
		Lr = this.parent;
	}
	stop(e) {
		if (this.active) {
			let t, i;
			for (t = 0, i = this.effects.length; t < i; t++)
				this.effects[t].stop();
			for (t = 0, i = this.cleanups.length; t < i; t++)
				this.cleanups[t]();
			if (this.scopes)
				for (t = 0, i = this.scopes.length; t < i; t++)
					this.scopes[t].stop(!0);
			if (this.parent && !e) {
				const n = this.parent.scopes.pop();
				n &&
                    n !== this &&
                    ((this.parent.scopes[this.index] = n),
                    (n.index = this.index));
			}
			this.active = !1;
		}
	}
}
function F0(r, e = Lr) {
	e && e.active && e.effects.push(r);
}
const du = (r) => {
		const e = new Set(r);
		return (e.w = 0), (e.n = 0), e;
	},
	_m = (r) => (r.w & ki) > 0,
	Mm = (r) => (r.n & ki) > 0,
	H0 = ({ deps: r }) => {
		if (r.length) for (let e = 0; e < r.length; e++) r[e].w |= ki;
	},
	G0 = (r) => {
		const { deps: e } = r;
		if (e.length) {
			let t = 0;
			for (let i = 0; i < e.length; i++) {
				const n = e[i];
				_m(n) && !Mm(n) ? n.delete(r) : (e[t++] = n),
				(n.w &= ~ki),
				(n.n &= ~ki);
			}
			e.length = t;
		}
	},
	xc = new WeakMap();
let ja = 0,
	ki = 1;
const bc = 30;
let pr;
const Qi = Symbol(''),
	wc = Symbol('');
class pu {
	constructor(e, t = null, i) {
		(this.fn = e),
		(this.scheduler = t),
		(this.active = !0),
		(this.deps = []),
		(this.parent = void 0),
		F0(this, i);
	}
	run() {
		if (!this.active) return this.fn();
		let e = pr,
			t = Mi;
		for (; e; ) {
			if (e === this) return;
			e = e.parent;
		}
		try {
			return (
				(this.parent = pr),
				(pr = this),
				(Mi = !0),
				(ki = 1 << ++ja),
				ja <= bc ? H0(this) : _h(this),
				this.fn()
			);
		} finally {
			ja <= bc && G0(this),
			(ki = 1 << --ja),
			(pr = this.parent),
			(Mi = t),
			(this.parent = void 0),
			this.deferStop && this.stop();
		}
	}
	stop() {
		pr === this
			? (this.deferStop = !0)
			: this.active &&
              (_h(this), this.onStop && this.onStop(), (this.active = !1));
	}
}
function _h(r) {
	const { deps: e } = r;
	if (e.length) {
		for (let t = 0; t < e.length; t++) e[t].delete(r);
		e.length = 0;
	}
}
let Mi = !0;
const Sm = [];
function va() {
	Sm.push(Mi), (Mi = !1);
}
function ya() {
	const r = Sm.pop();
	Mi = r === void 0 ? !0 : r;
}
function qt(r, e, t) {
	if (Mi && pr) {
		let i = xc.get(r);
		i || xc.set(r, (i = new Map()));
		let n = i.get(t);
		n || i.set(t, (n = du())), Tm(n);
	}
}
function Tm(r, e) {
	let t = !1;
	ja <= bc ? Mm(r) || ((r.n |= ki), (t = !_m(r))) : (t = !r.has(pr)),
	t && (r.add(pr), pr.deps.push(r));
}
function Jr(r, e, t, i, n, a) {
	const s = xc.get(r);
	if (!s) return;
	let o = [];
	if (e === 'clear') o = [...s.values()];
	else if (t === 'length' && ze(r))
		s.forEach((l, c) => {
			(c === 'length' || c >= i) && o.push(l);
		});
	else
		switch ((t !== void 0 && o.push(s.get(t)), e)) {
		case 'add':
			ze(r)
				? hu(t) && o.push(s.get('length'))
				: (o.push(s.get(Qi)), Kn(r) && o.push(s.get(wc)));
			break;
		case 'delete':
			ze(r) || (o.push(s.get(Qi)), Kn(r) && o.push(s.get(wc)));
			break;
		case 'set':
			Kn(r) && o.push(s.get(Qi));
			break;
		}
	if (o.length === 1) o[0] && _c(o[0]);
	else {
		const l = [];
		for (const c of o) c && l.push(...c);
		_c(du(l));
	}
}
function _c(r, e) {
	const t = ze(r) ? r : [...r];
	for (const i of t) i.computed && Mh(i);
	for (const i of t) i.computed || Mh(i);
}
function Mh(r, e) {
	(r !== pr || r.allowRecurse) && (r.scheduler ? r.scheduler() : r.run());
}
const V0 = ou('__proto__,__v_isRef,__isVue'),
	Em = new Set(
		Object.getOwnPropertyNames(Symbol)
			.filter((r) => r !== 'arguments' && r !== 'caller')
			.map((r) => Symbol[r])
			.filter(uu)
	),
	W0 = mu(),
	j0 = mu(!1, !0),
	X0 = mu(!0),
	Sh = q0();
function q0() {
	const r = {};
	return (
		['includes', 'indexOf', 'lastIndexOf'].forEach((e) => {
			r[e] = function (...t) {
				const i = Ke(this);
				for (let a = 0, s = this.length; a < s; a++)
					qt(i, 'get', a + '');
				const n = i[e](...t);
				return n === -1 || n === !1 ? i[e](...t.map(Ke)) : n;
			};
		}),
		['push', 'pop', 'shift', 'unshift', 'splice'].forEach((e) => {
			r[e] = function (...t) {
				va();
				const i = Ke(this)[e].apply(this, t);
				return ya(), i;
			};
		}),
		r
	);
}
function mu(r = !1, e = !1) {
	return function (t, i, n) {
		if (i === '__v_isReactive') return !r;
		if (i === '__v_isReadonly') return r;
		if (i === '__v_isShallow') return e;
		if (i === '__v_raw' && n === (r ? (e ? cv : Cm) : e ? km : Rm).get(t))
			return t;
		const a = ze(t);
		if (!r && a && qe(Sh, i)) return Reflect.get(Sh, i, n);
		const s = Reflect.get(t, i, n);
		return (uu(i) ? Em.has(i) : V0(i)) || (r || qt(t, 'get', i), e)
			? s
			: Rt(s)
				? a && hu(i)
					? s
					: s.value
				: bt(s)
					? r
						? Pm(s)
						: Es(s)
					: s;
	};
}
const Y0 = Am(),
	Z0 = Am(!0);
function Am(r = !1) {
	return function (e, t, i, n) {
		let a = e[t];
		if (ls(a) && Rt(a) && !Rt(i)) return !1;
		if (
			!r &&
            !ls(i) &&
            (Mc(i) || ((i = Ke(i)), (a = Ke(a))), !ze(e) && Rt(a) && !Rt(i))
		)
			return (a.value = i), !0;
		const s = ze(e) && hu(t) ? Number(t) < e.length : qe(e, t),
			o = Reflect.set(e, t, i, n);
		return (
			e === Ke(n) &&
                (s ? os(i, a) && Jr(e, 'set', t, i) : Jr(e, 'add', t, i)),
			o
		);
	};
}
function $0(r, e) {
	const t = qe(r, e);
	r[e];
	const i = Reflect.deleteProperty(r, e);
	return i && t && Jr(r, 'delete', e, void 0), i;
}
function K0(r, e) {
	const t = Reflect.has(r, e);
	return (!uu(e) || !Em.has(e)) && qt(r, 'has', e), t;
}
function J0(r) {
	return qt(r, 'iterate', ze(r) ? 'length' : Qi), Reflect.ownKeys(r);
}
const Lm = { get: W0, set: Y0, deleteProperty: $0, has: K0, ownKeys: J0 },
	Q0 = {
		get: X0,
		set(r, e) {
			return !0;
		},
		deleteProperty(r, e) {
			return !0;
		}
	},
	ev = Pt({}, Lm, { get: j0, set: Z0 }),
	fu = (r) => r,
	jo = (r) => Reflect.getPrototypeOf(r);
function Ps(r, e, t = !1, i = !1) {
	r = r.__v_raw;
	const n = Ke(r),
		a = Ke(e);
	t || (e !== a && qt(n, 'get', e), qt(n, 'get', a));
	const { has: s } = jo(n),
		o = i ? fu : t ? yu : cs;
	if (s.call(n, e)) return o(r.get(e));
	if (s.call(n, a)) return o(r.get(a));
	r !== n && r.get(e);
}
function Is(r, e = !1) {
	const t = this.__v_raw,
		i = Ke(t),
		n = Ke(r);
	return (
		e || (r !== n && qt(i, 'has', r), qt(i, 'has', n)),
		r === n ? t.has(r) : t.has(r) || t.has(n)
	);
}
function Ds(r, e = !1) {
	return (
		(r = r.__v_raw),
		!e && qt(Ke(r), 'iterate', Qi),
		Reflect.get(r, 'size', r)
	);
}
function Th(r) {
	r = Ke(r);
	const e = Ke(this);
	return jo(e).has.call(e, r) || (e.add(r), Jr(e, 'add', r, r)), this;
}
function Eh(r, e) {
	e = Ke(e);
	const t = Ke(this),
		{ has: i, get: n } = jo(t);
	let a = i.call(t, r);
	a || ((r = Ke(r)), (a = i.call(t, r)));
	const s = n.call(t, r);
	return (
		t.set(r, e),
		a ? os(e, s) && Jr(t, 'set', r, e) : Jr(t, 'add', r, e),
		this
	);
}
function Ah(r) {
	const e = Ke(this),
		{ has: t, get: i } = jo(e);
	let n = t.call(e, r);
	n || ((r = Ke(r)), (n = t.call(e, r))), i && i.call(e, r);
	const a = e.delete(r);
	return n && Jr(e, 'delete', r, void 0), a;
}
function Lh() {
	const r = Ke(this),
		e = r.size !== 0,
		t = r.clear();
	return e && Jr(r, 'clear', void 0, void 0), t;
}
function Os(r, e) {
	return function (t, i) {
		const n = this,
			a = n.__v_raw,
			s = Ke(a),
			o = e ? fu : r ? yu : cs;
		return (
			!r && qt(s, 'iterate', Qi),
			a.forEach((l, c) => t.call(i, o(l), o(c), n))
		);
	};
}
function Ns(r, e, t) {
	return function (...i) {
		const n = this.__v_raw,
			a = Ke(n),
			s = Kn(a),
			o = r === 'entries' || (r === Symbol.iterator && s),
			l = r === 'keys' && s,
			c = n[r](...i),
			u = t ? fu : e ? yu : cs;
		return (
			!e && qt(a, 'iterate', l ? wc : Qi),
			{
				next() {
					const { value: h, done: d } = c.next();
					return d
						? { value: h, done: d }
						: { value: o ? [u(h[0]), u(h[1])] : u(h), done: d };
				},
				[Symbol.iterator]() {
					return this;
				}
			}
		);
	};
}
function ni(r) {
	return function (...e) {
		return r === 'delete' ? !1 : this;
	};
}
function tv() {
	const r = {
			get(n) {
				return Ps(this, n);
			},
			get size() {
				return Ds(this);
			},
			has: Is,
			add: Th,
			set: Eh,
			delete: Ah,
			clear: Lh,
			forEach: Os(!1, !1)
		},
		e = {
			get(n) {
				return Ps(this, n, !1, !0);
			},
			get size() {
				return Ds(this);
			},
			has: Is,
			add: Th,
			set: Eh,
			delete: Ah,
			clear: Lh,
			forEach: Os(!1, !0)
		},
		t = {
			get(n) {
				return Ps(this, n, !0);
			},
			get size() {
				return Ds(this, !0);
			},
			has(n) {
				return Is.call(this, n, !0);
			},
			add: ni('add'),
			set: ni('set'),
			delete: ni('delete'),
			clear: ni('clear'),
			forEach: Os(!0, !1)
		},
		i = {
			get(n) {
				return Ps(this, n, !0, !0);
			},
			get size() {
				return Ds(this, !0);
			},
			has(n) {
				return Is.call(this, n, !0);
			},
			add: ni('add'),
			set: ni('set'),
			delete: ni('delete'),
			clear: ni('clear'),
			forEach: Os(!0, !0)
		};
	return (
		['keys', 'values', 'entries', Symbol.iterator].forEach((n) => {
			(r[n] = Ns(n, !1, !1)),
			(t[n] = Ns(n, !0, !1)),
			(e[n] = Ns(n, !1, !0)),
			(i[n] = Ns(n, !0, !0));
		}),
		[r, t, e, i]
	);
}
const [rv, iv, nv, av] = tv();
function gu(r, e) {
	const t = e ? (r ? av : nv) : r ? iv : rv;
	return (i, n, a) =>
		n === '__v_isReactive'
			? !r
			: n === '__v_isReadonly'
				? r
				: n === '__v_raw'
					? i
					: Reflect.get(qe(t, n) && n in i ? t : i, n, a);
}
const sv = { get: gu(!1, !1) },
	ov = { get: gu(!1, !0) },
	lv = { get: gu(!0, !1) },
	Rm = new WeakMap(),
	km = new WeakMap(),
	Cm = new WeakMap(),
	cv = new WeakMap();
function uv(r) {
	switch (r) {
	case 'Object':
	case 'Array':
		return 1;
	case 'Map':
	case 'Set':
	case 'WeakMap':
	case 'WeakSet':
		return 2;
	default:
		return 0;
	}
}
function hv(r) {
	return r.__v_skip || !Object.isExtensible(r) ? 0 : uv(O0(r));
}
function Es(r) {
	return ls(r) ? r : vu(r, !1, Lm, sv, Rm);
}
function dv(r) {
	return vu(r, !1, ev, ov, km);
}
function Pm(r) {
	return vu(r, !0, Q0, lv, Cm);
}
function vu(r, e, t, i, n) {
	if (!bt(r) || (r.__v_raw && !(e && r.__v_isReactive))) return r;
	const a = n.get(r);
	if (a) return a;
	const s = hv(r);
	if (s === 0) return r;
	const o = new Proxy(r, s === 2 ? i : t);
	return n.set(r, o), o;
}
function Jn(r) {
	return ls(r) ? Jn(r.__v_raw) : !!(r && r.__v_isReactive);
}
function ls(r) {
	return !!(r && r.__v_isReadonly);
}
function Mc(r) {
	return !!(r && r.__v_isShallow);
}
function Im(r) {
	return Jn(r) || ls(r);
}
function Ke(r) {
	const e = r && r.__v_raw;
	return e ? Ke(e) : r;
}
function Dm(r) {
	return Ro(r, '__v_skip', !0), r;
}
const cs = (r) => (bt(r) ? Es(r) : r),
	yu = (r) => (bt(r) ? Pm(r) : r);
function Om(r) {
	Mi && pr && ((r = Ke(r)), Tm(r.dep || (r.dep = du())));
}
function Nm(r, e) {
	(r = Ke(r)), r.dep && _c(r.dep);
}
function Rt(r) {
	return !!(r && r.__v_isRef === !0);
}
function lt(r) {
	return zm(r, !1);
}
function pv(r) {
	return zm(r, !0);
}
function zm(r, e) {
	return Rt(r) ? r : new mv(r, e);
}
class mv {
	constructor(e, t) {
		(this.__v_isShallow = t),
		(this.dep = void 0),
		(this.__v_isRef = !0),
		(this._rawValue = t ? e : Ke(e)),
		(this._value = t ? e : cs(e));
	}
	get value() {
		return Om(this), this._value;
	}
	set value(e) {
		(e = this.__v_isShallow ? e : Ke(e)),
		os(e, this._rawValue) &&
                ((this._rawValue = e),
                (this._value = this.__v_isShallow ? e : cs(e)),
                Nm(this));
	}
}
function Qn(r) {
	return Rt(r) ? r.value : r;
}
const fv = {
	get: (r, e, t) => Qn(Reflect.get(r, e, t)),
	set: (r, e, t, i) => {
		const n = r[e];
		return Rt(n) && !Rt(t) ? ((n.value = t), !0) : Reflect.set(r, e, t, i);
	}
};
function Um(r) {
	return Jn(r) ? r : new Proxy(r, fv);
}
class gv {
	constructor(e, t, i, n) {
		(this._setter = t),
		(this.dep = void 0),
		(this.__v_isRef = !0),
		(this._dirty = !0),
		(this.effect = new pu(e, () => {
			this._dirty || ((this._dirty = !0), Nm(this));
		})),
		(this.effect.computed = this),
		(this.effect.active = this._cacheable = !n),
		(this.__v_isReadonly = i);
	}
	get value() {
		const e = Ke(this);
		return (
			Om(e),
			(e._dirty || !e._cacheable) &&
                ((e._dirty = !1), (e._value = e.effect.run())),
			e._value
		);
	}
	set value(e) {
		this._setter(e);
	}
}
function vv(r, e, t = !1) {
	let i, n;
	const a = He(r);
	return (
		a ? ((i = r), (n = Dr)) : ((i = r.get), (n = r.set)),
		new gv(i, n, a || !n, t)
	);
}
function Si(r, e, t, i) {
	let n;
	try {
		n = i ? r(...i) : r();
	} catch (a) {
		Xo(a, e, t);
	}
	return n;
}
function er(r, e, t, i) {
	if (He(r)) {
		const a = Si(r, e, t, i);
		return (
			a &&
                xm(a) &&
                a.catch((s) => {
                	Xo(s, e, t);
                }),
			a
		);
	}
	const n = [];
	for (let a = 0; a < r.length; a++) n.push(er(r[a], e, t, i));
	return n;
}
function Xo(r, e, t, i = !0) {
	const n = e ? e.vnode : null;
	if (e) {
		let a = e.parent;
		const s = e.proxy,
			o = t;
		for (; a; ) {
			const c = a.ec;
			if (c) {
				for (let u = 0; u < c.length; u++)
					if (c[u](r, s, o) === !1) return;
			}
			a = a.parent;
		}
		const l = e.appContext.config.errorHandler;
		if (l) {
			Si(l, null, 10, [r, s, o]);
			return;
		}
	}
	yv(r, t, n, i);
}
function yv(r, e, t, i = !0) {
	console.error(r);
}
let Co = !1,
	Sc = !1;
const jt = [];
let qr = 0;
const Za = [];
let Xa = null,
	Hn = 0;
const $a = [];
let yi = null,
	Gn = 0;
const Bm = Promise.resolve();
let xu = null,
	Tc = null;
function Fm(r) {
	const e = xu || Bm;
	return r ? e.then(this ? r.bind(this) : r) : e;
}
function xv(r) {
	let e = qr + 1,
		t = jt.length;
	for (; e < t; ) {
		const i = (e + t) >>> 1;
		us(jt[i]) < r ? (e = i + 1) : (t = i);
	}
	return e;
}
function Hm(r) {
	(!jt.length || !jt.includes(r, Co && r.allowRecurse ? qr + 1 : qr)) &&
        r !== Tc &&
        (r.id == null ? jt.push(r) : jt.splice(xv(r.id), 0, r), Gm());
}
function Gm() {
	!Co && !Sc && ((Sc = !0), (xu = Bm.then(jm)));
}
function bv(r) {
	const e = jt.indexOf(r);
	e > qr && jt.splice(e, 1);
}
function Vm(r, e, t, i) {
	ze(r)
		? t.push(...r)
		: (!e || !e.includes(r, r.allowRecurse ? i + 1 : i)) && t.push(r),
	Gm();
}
function wv(r) {
	Vm(r, Xa, Za, Hn);
}
function _v(r) {
	Vm(r, yi, $a, Gn);
}
function qo(r, e = null) {
	if (Za.length) {
		for (
			Tc = e, Xa = [...new Set(Za)], Za.length = 0, Hn = 0;
			Hn < Xa.length;
			Hn++
		)
			Xa[Hn]();
		(Xa = null), (Hn = 0), (Tc = null), qo(r, e);
	}
}
function Wm(r) {
	if ((qo(), $a.length)) {
		const e = [...new Set($a)];
		if ((($a.length = 0), yi)) {
			yi.push(...e);
			return;
		}
		for (
			yi = e, yi.sort((t, i) => us(t) - us(i)), Gn = 0;
			Gn < yi.length;
			Gn++
		)
			yi[Gn]();
		(yi = null), (Gn = 0);
	}
}
const us = (r) => (r.id == null ? 1 / 0 : r.id);
function jm(r) {
	(Sc = !1), (Co = !0), qo(r), jt.sort((e, t) => us(e) - us(t));
	try {
		for (qr = 0; qr < jt.length; qr++) {
			const e = jt[qr];
			e && e.active !== !1 && Si(e, null, 14);
		}
	} finally {
		(qr = 0),
		(jt.length = 0),
		Wm(),
		(Co = !1),
		(xu = null),
		(jt.length || Za.length || $a.length) && jm(r);
	}
}
function Mv(r, e, ...t) {
	if (r.isUnmounted) return;
	const i = r.vnode.props || st;
	let n = t;
	const a = e.startsWith('update:'),
		s = a && e.slice(7);
	if (s && s in i) {
		const u = `${s === 'modelValue' ? 'model' : s}Modifiers`,
			{ number: h, trim: d } = i[u] || st;
		d && (n = t.map((p) => p.trim())), h && (n = t.map(ko));
	}
	let o,
		l = i[(o = wl(e))] || i[(o = wl(Or(e)))];
	!l && a && (l = i[(o = wl(ga(e)))]), l && er(l, r, 6, n);
	const c = i[o + 'Once'];
	if (c) {
		if (!r.emitted) r.emitted = {};
		else if (r.emitted[o]) return;
		(r.emitted[o] = !0), er(c, r, 6, n);
	}
}
function Xm(r, e, t = !1) {
	const i = e.emitsCache,
		n = i.get(r);
	if (n !== void 0) return n;
	const a = r.emits;
	let s = {},
		o = !1;
	if (!He(r)) {
		const l = (c) => {
			const u = Xm(c, e, !0);
			u && ((o = !0), Pt(s, u));
		};
		!t && e.mixins.length && e.mixins.forEach(l),
		r.extends && l(r.extends),
		r.mixins && r.mixins.forEach(l);
	}
	return !a && !o
		? (i.set(r, null), null)
		: (ze(a) ? a.forEach((l) => (s[l] = null)) : Pt(s, a), i.set(r, s), s);
}
function Yo(r, e) {
	return !r || !Ho(e)
		? !1
		: ((e = e.slice(2).replace(/Once$/, '')),
		qe(r, e[0].toLowerCase() + e.slice(1)) || qe(r, ga(e)) || qe(r, e));
}
let Jt = null,
	Zo = null;
function Po(r) {
	const e = Jt;
	return (Jt = r), (Zo = (r && r.type.__scopeId) || null), e;
}
function qm(r) {
	Zo = r;
}
function Ym() {
	Zo = null;
}
function tr(r, e = Jt, t) {
	if (!e || r._n) return r;
	const i = (...n) => {
		i._d && Fh(-1);
		const a = Po(e),
			s = r(...n);
		return Po(a), i._d && Fh(1), s;
	};
	return (i._n = !0), (i._c = !0), (i._d = !0), i;
}
function _l(r) {
	const {
		type: e,
		vnode: t,
		proxy: i,
		withProxy: n,
		props: a,
		propsOptions: [s],
		slots: o,
		attrs: l,
		emit: c,
		render: u,
		renderCache: h,
		data: d,
		setupState: p,
		ctx: g,
		inheritAttrs: m
	} = r;
	let f, v;
	const x = Po(r);
	try {
		if (t.shapeFlag & 4) {
			const S = n || i;
			(f = Rr(u.call(S, S, h, a, p, d, g))), (v = l);
		} else {
			const S = e;
			(f = Rr(
				S.length > 1
					? S(a, { attrs: l, slots: o, emit: c })
					: S(a, null)
			)),
			(v = e.props ? l : Sv(l));
		}
	} catch (S) {
		(Qa.length = 0), Xo(S, r, 1), (f = Ge(xr));
	}
	let A = f;
	if (v && m !== !1) {
		const S = Object.keys(v),
			{ shapeFlag: M } = A;
		S.length &&
            M & 7 &&
            (s && S.some(lu) && (v = Tv(v, s)), (A = Ci(A, v)));
	}
	return (
		t.dirs &&
            ((A = Ci(A)), (A.dirs = A.dirs ? A.dirs.concat(t.dirs) : t.dirs)),
		t.transition && (A.transition = t.transition),
		(f = A),
		Po(x),
		f
	);
}
const Sv = (r) => {
		let e;
		for (const t in r)
			(t === 'class' || t === 'style' || Ho(t)) &&
                ((e || (e = {}))[t] = r[t]);
		return e;
	},
	Tv = (r, e) => {
		const t = {};
		for (const i in r) (!lu(i) || !(i.slice(9) in e)) && (t[i] = r[i]);
		return t;
	};
function Ev(r, e, t) {
	const { props: i, children: n, component: a } = r,
		{ props: s, children: o, patchFlag: l } = e,
		c = a.emitsOptions;
	if (e.dirs || e.transition) return !0;
	if (t && l >= 0) {
		if (l & 1024) return !0;
		if (l & 16) return i ? Rh(i, s, c) : !!s;
		if (l & 8) {
			const u = e.dynamicProps;
			for (let h = 0; h < u.length; h++) {
				const d = u[h];
				if (s[d] !== i[d] && !Yo(c, d)) return !0;
			}
		}
	} else
		return (n || o) && (!o || !o.$stable)
			? !0
			: i === s
				? !1
				: i
					? s
						? Rh(i, s, c)
						: !0
					: !!s;
	return !1;
}
function Rh(r, e, t) {
	const i = Object.keys(e);
	if (i.length !== Object.keys(r).length) return !0;
	for (let n = 0; n < i.length; n++) {
		const a = i[n];
		if (e[a] !== r[a] && !Yo(t, a)) return !0;
	}
	return !1;
}
function Av({ vnode: r, parent: e }, t) {
	for (; e && e.subTree === r; ) ((r = e.vnode).el = t), (e = e.parent);
}
const Lv = (r) => r.__isSuspense;
function Rv(r, e) {
	e && e.pendingBranch
		? ze(r)
			? e.effects.push(...r)
			: e.effects.push(r)
		: _v(r);
}
function _o(r, e) {
	if (At) {
		let t = At.provides;
		const i = At.parent && At.parent.provides;
		i === t && (t = At.provides = Object.create(i)), (t[r] = e);
	}
}
function Ti(r, e, t = !1) {
	const i = At || Jt;
	if (i) {
		const n =
            i.parent == null
            	? i.vnode.appContext && i.vnode.appContext.provides
            	: i.parent.provides;
		if (n && r in n) return n[r];
		if (arguments.length > 1) return t && He(e) ? e.call(i.proxy) : e;
	}
}
function kv(r, e) {
	return bu(r, null, { flush: 'post' });
}
const kh = {};
function Mo(r, e, t) {
	return bu(r, e, t);
}
function bu(
	r,
	e,
	{ immediate: t, deep: i, flush: n, onTrack: a, onTrigger: s } = st
) {
	const o = At;
	let l,
		c = !1,
		u = !1;
	if (
		(Rt(r)
			? ((l = () => r.value), (c = Mc(r)))
			: Jn(r)
				? ((l = () => r), (i = !0))
				: ze(r)
					? ((u = !0),
					(c = r.some((v) => Jn(v) || Mc(v))),
					(l = () =>
						r.map((v) => {
							if (Rt(v)) return v.value;
							if (Jn(v)) return Ki(v);
							if (He(v)) return Si(v, o, 2);
						})))
					: He(r)
						? e
							? (l = () => Si(r, o, 2))
							: (l = () => {
								if (!(o && o.isUnmounted))
									return h && h(), er(r, o, 3, [d]);
							})
						: (l = Dr),
		e && i)
	) {
		const v = l;
		l = () => Ki(v());
	}
	let h,
		d = (v) => {
			h = f.onStop = () => {
				Si(v, o, 4);
			};
		};
	if (ds)
		return (
			(d = Dr), e ? t && er(e, o, 3, [l(), u ? [] : void 0, d]) : l(), Dr
		);
	let p = u ? [] : kh;
	const g = () => {
		if (f.active)
			if (e) {
				const v = f.run();
				(i || c || (u ? v.some((x, A) => os(x, p[A])) : os(v, p))) &&
                    (h && h(),
                    er(e, o, 3, [v, p === kh ? void 0 : p, d]),
                    (p = v));
			} else f.run();
	};
	g.allowRecurse = !!e;
	let m;
	n === 'sync'
		? (m = g)
		: n === 'post'
			? (m = () => Gt(g, o && o.suspense))
			: (m = () => wv(g));
	const f = new pu(l, m);
	return (
		e
			? t
				? g()
				: (p = f.run())
			: n === 'post'
				? Gt(f.run.bind(f), o && o.suspense)
				: f.run(),
		() => {
			f.stop(), o && o.scope && cu(o.scope.effects, f);
		}
	);
}
function Cv(r, e, t) {
	const i = this.proxy,
		n = xt(r) ? (r.includes('.') ? Zm(i, r) : () => i[r]) : r.bind(i, i);
	let a;
	He(e) ? (a = e) : ((a = e.handler), (t = e));
	const s = At;
	ia(this);
	const o = bu(n, a.bind(i), t);
	return s ? ia(s) : tn(), o;
}
function Zm(r, e) {
	const t = e.split('.');
	return () => {
		let i = r;
		for (let n = 0; n < t.length && i; n++) i = i[t[n]];
		return i;
	};
}
function Ki(r, e) {
	if (!bt(r) || r.__v_skip || ((e = e || new Set()), e.has(r))) return r;
	if ((e.add(r), Rt(r))) Ki(r.value, e);
	else if (ze(r)) for (let t = 0; t < r.length; t++) Ki(r[t], e);
	else if (ym(r) || Kn(r))
		r.forEach((t) => {
			Ki(t, e);
		});
	else if (wm(r)) for (const t in r) Ki(r[t], e);
	return r;
}
function Pv() {
	const r = {
		isMounted: !1,
		isLeaving: !1,
		isUnmounting: !1,
		leavingVNodes: new Map()
	};
	return (
		As(() => {
			r.isMounted = !0;
		}),
		tf(() => {
			r.isUnmounting = !0;
		}),
		r
	);
}
const Zt = [Function, Array],
	Iv = {
		name: 'BaseTransition',
		props: {
			mode: String,
			appear: Boolean,
			persisted: Boolean,
			onBeforeEnter: Zt,
			onEnter: Zt,
			onAfterEnter: Zt,
			onEnterCancelled: Zt,
			onBeforeLeave: Zt,
			onLeave: Zt,
			onAfterLeave: Zt,
			onLeaveCancelled: Zt,
			onBeforeAppear: Zt,
			onAppear: Zt,
			onAfterAppear: Zt,
			onAppearCancelled: Zt
		},
		setup(r, { slots: e }) {
			const t = gf(),
				i = Pv();
			let n;
			return () => {
				const a = e.default && Jm(e.default(), !0);
				if (!a || !a.length) return;
				let s = a[0];
				if (a.length > 1) {
					for (const m of a)
						if (m.type !== xr) {
							s = m;
							break;
						}
				}
				const o = Ke(r),
					{ mode: l } = o;
				if (i.isLeaving) return Ml(s);
				const c = Ch(s);
				if (!c) return Ml(s);
				const u = Ec(c, o, i, t);
				Ac(c, u);
				const h = t.subTree,
					d = h && Ch(h);
				let p = !1;
				const { getTransitionKey: g } = c.type;
				if (g) {
					const m = g();
					n === void 0 ? (n = m) : m !== n && ((n = m), (p = !0));
				}
				if (d && d.type !== xr && (!Yi(c, d) || p)) {
					const m = Ec(d, o, i, t);
					if ((Ac(d, m), l === 'out-in'))
						return (
							(i.isLeaving = !0),
							(m.afterLeave = () => {
								(i.isLeaving = !1), t.update();
							}),
							Ml(s)
						);
					l === 'in-out' &&
                        c.type !== xr &&
                        (m.delayLeave = (f, v, x) => {
                        	const A = Km(i, d);
                        	(A[String(d.key)] = d),
                        	(f._leaveCb = () => {
                        		v(),
                        		(f._leaveCb = void 0),
                        		delete u.delayedLeave;
                        	}),
                        	(u.delayedLeave = x);
                        });
				}
				return s;
			};
		}
	},
	$m = Iv;
function Km(r, e) {
	const { leavingVNodes: t } = r;
	let i = t.get(e.type);
	return i || ((i = Object.create(null)), t.set(e.type, i)), i;
}
function Ec(r, e, t, i) {
	const {
			appear: n,
			mode: a,
			persisted: s = !1,
			onBeforeEnter: o,
			onEnter: l,
			onAfterEnter: c,
			onEnterCancelled: u,
			onBeforeLeave: h,
			onLeave: d,
			onAfterLeave: p,
			onLeaveCancelled: g,
			onBeforeAppear: m,
			onAppear: f,
			onAfterAppear: v,
			onAppearCancelled: x
		} = e,
		A = String(r.key),
		S = Km(t, r),
		M = (G, re) => {
			G && er(G, i, 9, re);
		},
		I = (G, re) => {
			const B = re[1];
			M(G, re),
			ze(G)
				? G.every((b) => b.length <= 1) && B()
				: G.length <= 1 && B();
		},
		D = {
			mode: a,
			persisted: s,
			beforeEnter(G) {
				let re = o;
				if (!t.isMounted)
					if (n) re = m || o;
					else return;
				G._leaveCb && G._leaveCb(!0);
				const B = S[A];
				B && Yi(r, B) && B.el._leaveCb && B.el._leaveCb(), M(re, [G]);
			},
			enter(G) {
				let re = l,
					B = c,
					b = u;
				if (!t.isMounted)
					if (n) (re = f || l), (B = v || c), (b = x || u);
					else return;
				let E = !1;
				const j = (G._enterCb = (z) => {
					E ||
                        ((E = !0),
                        z ? M(b, [G]) : M(B, [G]),
                        D.delayedLeave && D.delayedLeave(),
                        (G._enterCb = void 0));
				});
				re ? I(re, [G, j]) : j();
			},
			leave(G, re) {
				const B = String(r.key);
				if ((G._enterCb && G._enterCb(!0), t.isUnmounting)) return re();
				M(h, [G]);
				let b = !1;
				const E = (G._leaveCb = (j) => {
					b ||
                        ((b = !0),
                        re(),
                        j ? M(g, [G]) : M(p, [G]),
                        (G._leaveCb = void 0),
                        S[B] === r && delete S[B]);
				});
				(S[B] = r), d ? I(d, [G, E]) : E();
			},
			clone(G) {
				return Ec(G, e, t, i);
			}
		};
	return D;
}
function Ml(r) {
	if ($o(r)) return (r = Ci(r)), (r.children = null), r;
}
function Ch(r) {
	return $o(r) ? (r.children ? r.children[0] : void 0) : r;
}
function Ac(r, e) {
	r.shapeFlag & 6 && r.component
		? Ac(r.component.subTree, e)
		: r.shapeFlag & 128
			? ((r.ssContent.transition = e.clone(r.ssContent)),
			(r.ssFallback.transition = e.clone(r.ssFallback)))
			: (r.transition = e);
}
function Jm(r, e = !1, t) {
	let i = [],
		n = 0;
	for (let a = 0; a < r.length; a++) {
		let s = r[a];
		const o =
            t == null ? s.key : String(t) + String(s.key != null ? s.key : a);
		s.type === gt
			? (s.patchFlag & 128 && n++, (i = i.concat(Jm(s.children, e, o))))
			: (e || s.type !== xr) && i.push(o != null ? Ci(s, { key: o }) : s);
	}
	if (n > 1) for (let a = 0; a < i.length; a++) i[a].patchFlag = -2;
	return i;
}
function Qm(r) {
	return He(r) ? { setup: r, name: r.name } : r;
}
const So = (r) => !!r.type.__asyncLoader,
	$o = (r) => r.type.__isKeepAlive;
function Dv(r, e) {
	ef(r, 'a', e);
}
function Ov(r, e) {
	ef(r, 'da', e);
}
function ef(r, e, t = At) {
	const i =
        r.__wdc ||
        (r.__wdc = () => {
        	let n = t;
        	for (; n; ) {
        		if (n.isDeactivated) return;
        		n = n.parent;
        	}
        	return r();
        });
	if ((Ko(e, i, t), t)) {
		let n = t.parent;
		for (; n && n.parent; )
			$o(n.parent.vnode) && Nv(i, e, t, n), (n = n.parent);
	}
}
function Nv(r, e, t, i) {
	const n = Ko(e, r, i, !0);
	wu(() => {
		cu(i[e], n);
	}, t);
}
function Ko(r, e, t = At, i = !1) {
	if (t) {
		const n = t[r] || (t[r] = []),
			a =
                e.__weh ||
                (e.__weh = (...s) => {
                	if (t.isUnmounted) return;
                	va(), ia(t);
                	const o = er(e, t, r, s);
                	return tn(), ya(), o;
                });
		return i ? n.unshift(a) : n.push(a), a;
	}
}
const ti =
        (r) =>
        	(e, t = At) =>
        		(!ds || r === 'sp') && Ko(r, e, t),
	zv = ti('bm'),
	As = ti('m'),
	Uv = ti('bu'),
	Bv = ti('u'),
	tf = ti('bum'),
	wu = ti('um'),
	Fv = ti('sp'),
	Hv = ti('rtg'),
	Gv = ti('rtc');
function Vv(r, e = At) {
	Ko('ec', r, e);
}
function Yr(r, e) {
	const t = Jt;
	if (t === null) return r;
	const i = el(t) || t.proxy,
		n = r.dirs || (r.dirs = []);
	for (let a = 0; a < e.length; a++) {
		let [s, o, l, c = st] = e[a];
		He(s) && (s = { mounted: s, updated: s }),
		s.deep && Ki(o),
		n.push({
			dir: s,
			instance: i,
			value: o,
			oldValue: void 0,
			arg: l,
			modifiers: c
		});
	}
	return r;
}
function Ui(r, e, t, i) {
	const n = r.dirs,
		a = e && e.dirs;
	for (let s = 0; s < n.length; s++) {
		const o = n[s];
		a && (o.oldValue = a[s].value);
		let l = o.dir[i];
		l && (va(), er(l, t, 8, [r.el, o, r, e]), ya());
	}
}
const _u = 'components';
function yr(r, e) {
	return nf(_u, r, !0, e) || r;
}
const rf = Symbol();
function Wv(r) {
	return xt(r) ? nf(_u, r, !1) || r : r || rf;
}
function nf(r, e, t = !0, i = !1) {
	const n = Jt || At;
	if (n) {
		const a = n.type;
		if (r === _u) {
			const o = wy(a);
			if (o && (o === e || o === Or(e) || o === Wo(Or(e)))) return a;
		}
		const s = Ph(n[r] || a[r], e) || Ph(n.appContext[r], e);
		return !s && i ? a : s;
	}
}
function Ph(r, e) {
	return r && (r[e] || r[Or(e)] || r[Wo(Or(e))]);
}
function Zr(r, e, t, i) {
	let n;
	const a = t && t[i];
	if (ze(r) || xt(r)) {
		n = new Array(r.length);
		for (let s = 0, o = r.length; s < o; s++)
			n[s] = e(r[s], s, void 0, a && a[s]);
	} else if (typeof r == 'number') {
		n = new Array(r);
		for (let s = 0; s < r; s++) n[s] = e(s + 1, s, void 0, a && a[s]);
	} else if (bt(r))
		if (r[Symbol.iterator])
			n = Array.from(r, (s, o) => e(s, o, void 0, a && a[o]));
		else {
			const s = Object.keys(r);
			n = new Array(s.length);
			for (let o = 0, l = s.length; o < l; o++) {
				const c = s[o];
				n[o] = e(r[c], c, o, a && a[o]);
			}
		}
	else n = [];
	return t && (t[i] = n), n;
}
const Lc = (r) => (r ? (vf(r) ? el(r) || r.proxy : Lc(r.parent)) : null),
	Io = Pt(Object.create(null), {
		$: (r) => r,
		$el: (r) => r.vnode.el,
		$data: (r) => r.data,
		$props: (r) => r.props,
		$attrs: (r) => r.attrs,
		$slots: (r) => r.slots,
		$refs: (r) => r.refs,
		$parent: (r) => Lc(r.parent),
		$root: (r) => Lc(r.root),
		$emit: (r) => r.emit,
		$options: (r) => sf(r),
		$forceUpdate: (r) => r.f || (r.f = () => Hm(r.update)),
		$nextTick: (r) => r.n || (r.n = Fm.bind(r.proxy)),
		$watch: (r) => Cv.bind(r)
	}),
	jv = {
		get({ _: r }, e) {
			const {
				ctx: t,
				setupState: i,
				data: n,
				props: a,
				accessCache: s,
				type: o,
				appContext: l
			} = r;
			let c;
			if (e[0] !== '$') {
				const p = s[e];
				if (p !== void 0)
					switch (p) {
					case 1:
						return i[e];
					case 2:
						return n[e];
					case 4:
						return t[e];
					case 3:
						return a[e];
					}
				else {
					if (i !== st && qe(i, e)) return (s[e] = 1), i[e];
					if (n !== st && qe(n, e)) return (s[e] = 2), n[e];
					if ((c = r.propsOptions[0]) && qe(c, e))
						return (s[e] = 3), a[e];
					if (t !== st && qe(t, e)) return (s[e] = 4), t[e];
					Rc && (s[e] = 0);
				}
			}
			const u = Io[e];
			let h, d;
			if (u) return e === '$attrs' && qt(r, 'get', e), u(r);
			if ((h = o.__cssModules) && (h = h[e])) return h;
			if (t !== st && qe(t, e)) return (s[e] = 4), t[e];
			if (((d = l.config.globalProperties), qe(d, e))) return d[e];
		},
		set({ _: r }, e, t) {
			const { data: i, setupState: n, ctx: a } = r;
			return n !== st && qe(n, e)
				? ((n[e] = t), !0)
				: i !== st && qe(i, e)
					? ((i[e] = t), !0)
					: qe(r.props, e) || (e[0] === '$' && e.slice(1) in r)
						? !1
						: ((a[e] = t), !0);
		},
		has(
			{
				_: {
					data: r,
					setupState: e,
					accessCache: t,
					ctx: i,
					appContext: n,
					propsOptions: a
				}
			},
			s
		) {
			let o;
			return (
				!!t[s] ||
                (r !== st && qe(r, s)) ||
                (e !== st && qe(e, s)) ||
                ((o = a[0]) && qe(o, s)) ||
                qe(i, s) ||
                qe(Io, s) ||
                qe(n.config.globalProperties, s)
			);
		},
		defineProperty(r, e, t) {
			return (
				t.get != null
					? (r._.accessCache[e] = 0)
					: qe(t, 'value') && this.set(r, e, t.value, null),
				Reflect.defineProperty(r, e, t)
			);
		}
	};
let Rc = !0;
function Xv(r) {
	const e = sf(r),
		t = r.proxy,
		i = r.ctx;
	(Rc = !1), e.beforeCreate && Ih(e.beforeCreate, r, 'bc');
	const {
		data: n,
		computed: a,
		methods: s,
		watch: o,
		provide: l,
		inject: c,
		created: u,
		beforeMount: h,
		mounted: d,
		beforeUpdate: p,
		updated: g,
		activated: m,
		deactivated: f,
		beforeDestroy: v,
		beforeUnmount: x,
		destroyed: A,
		unmounted: S,
		render: M,
		renderTracked: I,
		renderTriggered: D,
		errorCaptured: G,
		serverPrefetch: re,
		expose: B,
		inheritAttrs: b,
		components: E,
		directives: j,
		filters: z
	} = e;
	if ((c && qv(c, i, null, r.appContext.config.unwrapInjectedRef), s))
		for (const H in s) {
			const k = s[H];
			He(k) && (i[H] = k.bind(t));
		}
	if (n) {
		const H = n.call(t, t);
		bt(H) && (r.data = Es(H));
	}
	if (((Rc = !0), a))
		for (const H in a) {
			const k = a[H],
				P = He(k) ? k.bind(t, t) : He(k.get) ? k.get.bind(t, t) : Dr,
				Z = !He(k) && He(k.set) ? k.set.bind(t) : Dr,
				J = mr({ get: P, set: Z });
			Object.defineProperty(i, H, {
				enumerable: !0,
				configurable: !0,
				get: () => J.value,
				set: (fe) => (J.value = fe)
			});
		}
	if (o) for (const H in o) af(o[H], i, t, H);
	if (l) {
		const H = He(l) ? l.call(t) : l;
		Reflect.ownKeys(H).forEach((k) => {
			_o(k, H[k]);
		});
	}
	u && Ih(u, r, 'c');
	function V(H, k) {
		ze(k) ? k.forEach((P) => H(P.bind(t))) : k && H(k.bind(t));
	}
	if (
		(V(zv, h),
		V(As, d),
		V(Uv, p),
		V(Bv, g),
		V(Dv, m),
		V(Ov, f),
		V(Vv, G),
		V(Gv, I),
		V(Hv, D),
		V(tf, x),
		V(wu, S),
		V(Fv, re),
		ze(B))
	)
		if (B.length) {
			const H = r.exposed || (r.exposed = {});
			B.forEach((k) => {
				Object.defineProperty(H, k, {
					get: () => t[k],
					set: (P) => (t[k] = P)
				});
			});
		} else r.exposed || (r.exposed = {});
	M && r.render === Dr && (r.render = M),
	b != null && (r.inheritAttrs = b),
	E && (r.components = E),
	j && (r.directives = j);
}
function qv(r, e, t = Dr, i = !1) {
	ze(r) && (r = kc(r));
	for (const n in r) {
		const a = r[n];
		let s;
		bt(a)
			? 'default' in a
				? (s = Ti(a.from || n, a.default, !0))
				: (s = Ti(a.from || n))
			: (s = Ti(a)),
		Rt(s) && i
			? Object.defineProperty(e, n, {
				enumerable: !0,
				configurable: !0,
				get: () => s.value,
				set: (o) => (s.value = o)
			})
			: (e[n] = s);
	}
}
function Ih(r, e, t) {
	er(ze(r) ? r.map((i) => i.bind(e.proxy)) : r.bind(e.proxy), e, t);
}
function af(r, e, t, i) {
	const n = i.includes('.') ? Zm(t, i) : () => t[i];
	if (xt(r)) {
		const a = e[r];
		He(a) && Mo(n, a);
	} else if (He(r)) Mo(n, r.bind(t));
	else if (bt(r))
		if (ze(r)) r.forEach((a) => af(a, e, t, i));
		else {
			const a = He(r.handler) ? r.handler.bind(t) : e[r.handler];
			He(a) && Mo(n, a, r);
		}
}
function sf(r) {
	const e = r.type,
		{ mixins: t, extends: i } = e,
		{
			mixins: n,
			optionsCache: a,
			config: { optionMergeStrategies: s }
		} = r.appContext,
		o = a.get(e);
	let l;
	return (
		o
			? (l = o)
			: !n.length && !t && !i
				? (l = e)
				: ((l = {}),
				n.length && n.forEach((c) => Do(l, c, s, !0)),
				Do(l, e, s)),
		a.set(e, l),
		l
	);
}
function Do(r, e, t, i = !1) {
	const { mixins: n, extends: a } = e;
	a && Do(r, a, t, !0), n && n.forEach((s) => Do(r, s, t, !0));
	for (const s in e)
		if (!(i && s === 'expose')) {
			const o = Yv[s] || (t && t[s]);
			r[s] = o ? o(r[s], e[s]) : e[s];
		}
	return r;
}
const Yv = {
	data: Dh,
	props: ji,
	emits: ji,
	methods: ji,
	computed: ji,
	beforeCreate: Ft,
	created: Ft,
	beforeMount: Ft,
	mounted: Ft,
	beforeUpdate: Ft,
	updated: Ft,
	beforeDestroy: Ft,
	beforeUnmount: Ft,
	destroyed: Ft,
	unmounted: Ft,
	activated: Ft,
	deactivated: Ft,
	errorCaptured: Ft,
	serverPrefetch: Ft,
	components: ji,
	directives: ji,
	watch: $v,
	provide: Dh,
	inject: Zv
};
function Dh(r, e) {
	return e
		? r
			? function () {
				return Pt(
					He(r) ? r.call(this, this) : r,
					He(e) ? e.call(this, this) : e
				);
			}
			: e
		: r;
}
function Zv(r, e) {
	return ji(kc(r), kc(e));
}
function kc(r) {
	if (ze(r)) {
		const e = {};
		for (let t = 0; t < r.length; t++) e[r[t]] = r[t];
		return e;
	}
	return r;
}
function Ft(r, e) {
	return r ? [...new Set([].concat(r, e))] : e;
}
function ji(r, e) {
	return r ? Pt(Pt(Object.create(null), r), e) : e;
}
function $v(r, e) {
	if (!r) return e;
	if (!e) return r;
	const t = Pt(Object.create(null), r);
	for (const i in e) t[i] = Ft(r[i], e[i]);
	return t;
}
function Kv(r, e, t, i = !1) {
	const n = {},
		a = {};
	Ro(a, Jo, 1), (r.propsDefaults = Object.create(null)), of(r, e, n, a);
	for (const s in r.propsOptions[0]) s in n || (n[s] = void 0);
	t
		? (r.props = i ? n : dv(n))
		: r.type.props
			? (r.props = n)
			: (r.props = a),
	(r.attrs = a);
}
function Jv(r, e, t, i) {
	const {
			props: n,
			attrs: a,
			vnode: { patchFlag: s }
		} = r,
		o = Ke(n),
		[l] = r.propsOptions;
	let c = !1;
	if ((i || s > 0) && !(s & 16)) {
		if (s & 8) {
			const u = r.vnode.dynamicProps;
			for (let h = 0; h < u.length; h++) {
				let d = u[h];
				if (Yo(r.emitsOptions, d)) continue;
				const p = e[d];
				if (l)
					if (qe(a, d)) p !== a[d] && ((a[d] = p), (c = !0));
					else {
						const g = Or(d);
						n[g] = Cc(l, o, g, p, r, !1);
					}
				else p !== a[d] && ((a[d] = p), (c = !0));
			}
		}
	} else {
		of(r, e, n, a) && (c = !0);
		let u;
		for (const h in o)
			(!e || (!qe(e, h) && ((u = ga(h)) === h || !qe(e, u)))) &&
                (l
                	? t &&
                      (t[h] !== void 0 || t[u] !== void 0) &&
                      (n[h] = Cc(l, o, h, void 0, r, !0))
                	: delete n[h]);
		if (a !== o)
			for (const h in a)
				(!e || (!qe(e, h) && !0)) && (delete a[h], (c = !0));
	}
	c && Jr(r, 'set', '$attrs');
}
function of(r, e, t, i) {
	const [n, a] = r.propsOptions;
	let s = !1,
		o;
	if (e)
		for (let l in e) {
			if (bo(l)) continue;
			const c = e[l];
			let u;
			n && qe(n, (u = Or(l)))
				? !a || !a.includes(u)
					? (t[u] = c)
					: ((o || (o = {}))[u] = c)
				: Yo(r.emitsOptions, l) ||
                  ((!(l in i) || c !== i[l]) && ((i[l] = c), (s = !0)));
		}
	if (a) {
		const l = Ke(t),
			c = o || st;
		for (let u = 0; u < a.length; u++) {
			const h = a[u];
			t[h] = Cc(n, l, h, c[h], r, !qe(c, h));
		}
	}
	return s;
}
function Cc(r, e, t, i, n, a) {
	const s = r[t];
	if (s != null) {
		const o = qe(s, 'default');
		if (o && i === void 0) {
			const l = s.default;
			if (s.type !== Function && He(l)) {
				const { propsDefaults: c } = n;
				t in c
					? (i = c[t])
					: (ia(n), (i = c[t] = l.call(null, e)), tn());
			} else i = l;
		}
		s[0] &&
            (a && !o
            	? (i = !1)
            	: s[1] && (i === '' || i === ga(t)) && (i = !0));
	}
	return i;
}
function lf(r, e, t = !1) {
	const i = e.propsCache,
		n = i.get(r);
	if (n) return n;
	const a = r.props,
		s = {},
		o = [];
	let l = !1;
	if (!He(r)) {
		const u = (h) => {
			l = !0;
			const [d, p] = lf(h, e, !0);
			Pt(s, d), p && o.push(...p);
		};
		!t && e.mixins.length && e.mixins.forEach(u),
		r.extends && u(r.extends),
		r.mixins && r.mixins.forEach(u);
	}
	if (!a && !l) return i.set(r, $n), $n;
	if (ze(a))
		for (let u = 0; u < a.length; u++) {
			const h = Or(a[u]);
			Oh(h) && (s[h] = st);
		}
	else if (a)
		for (const u in a) {
			const h = Or(u);
			if (Oh(h)) {
				const d = a[u],
					p = (s[h] = ze(d) || He(d) ? { type: d } : d);
				if (p) {
					const g = Uh(Boolean, p.type),
						m = Uh(String, p.type);
					(p[0] = g > -1),
					(p[1] = m < 0 || g < m),
					(g > -1 || qe(p, 'default')) && o.push(h);
				}
			}
		}
	const c = [s, o];
	return i.set(r, c), c;
}
function Oh(r) {
	return r[0] !== '$';
}
function Nh(r) {
	const e = r && r.toString().match(/^\s*function (\w+)/);
	return e ? e[1] : r === null ? 'null' : '';
}
function zh(r, e) {
	return Nh(r) === Nh(e);
}
function Uh(r, e) {
	return ze(e) ? e.findIndex((t) => zh(t, r)) : He(e) && zh(e, r) ? 0 : -1;
}
const cf = (r) => r[0] === '_' || r === '$stable',
	Mu = (r) => (ze(r) ? r.map(Rr) : [Rr(r)]),
	Qv = (r, e, t) => {
		if (e._n) return e;
		const i = tr((...n) => Mu(e(...n)), t);
		return (i._c = !1), i;
	},
	uf = (r, e, t) => {
		const i = r._ctx;
		for (const n in r) {
			if (cf(n)) continue;
			const a = r[n];
			if (He(a)) e[n] = Qv(n, a, i);
			else if (a != null) {
				const s = Mu(a);
				e[n] = () => s;
			}
		}
	},
	hf = (r, e) => {
		const t = Mu(e);
		r.slots.default = () => t;
	},
	ey = (r, e) => {
		if (r.vnode.shapeFlag & 32) {
			const t = e._;
			t ? ((r.slots = Ke(e)), Ro(e, '_', t)) : uf(e, (r.slots = {}));
		} else (r.slots = {}), e && hf(r, e);
		Ro(r.slots, Jo, 1);
	},
	ty = (r, e, t) => {
		const { vnode: i, slots: n } = r;
		let a = !0,
			s = st;
		if (i.shapeFlag & 32) {
			const o = e._;
			o
				? t && o === 1
					? (a = !1)
					: (Pt(n, e), !t && o === 1 && delete n._)
				: ((a = !e.$stable), uf(e, n)),
			(s = e);
		} else e && (hf(r, e), (s = { default: 1 }));
		if (a) for (const o in n) !cf(o) && !(o in s) && delete n[o];
	};
function df() {
	return {
		app: null,
		config: {
			isNativeTag: P0,
			performance: !1,
			globalProperties: {},
			optionMergeStrategies: {},
			errorHandler: void 0,
			warnHandler: void 0,
			compilerOptions: {}
		},
		mixins: [],
		components: {},
		directives: {},
		provides: Object.create(null),
		optionsCache: new WeakMap(),
		propsCache: new WeakMap(),
		emitsCache: new WeakMap()
	};
}
let ry = 0;
function iy(r, e) {
	return function (t, i = null) {
		He(t) || (t = Object.assign({}, t)), i != null && !bt(i) && (i = null);
		const n = df(),
			a = new Set();
		let s = !1;
		const o = (n.app = {
			_uid: ry++,
			_component: t,
			_props: i,
			_container: null,
			_context: n,
			_instance: null,
			version: My,
			get config() {
				return n.config;
			},
			set config(l) {},
			use(l, ...c) {
				return (
					a.has(l) ||
                        (l && He(l.install)
                        	? (a.add(l), l.install(o, ...c))
                        	: He(l) && (a.add(l), l(o, ...c))),
					o
				);
			},
			mixin(l) {
				return n.mixins.includes(l) || n.mixins.push(l), o;
			},
			component(l, c) {
				return c ? ((n.components[l] = c), o) : n.components[l];
			},
			directive(l, c) {
				return c ? ((n.directives[l] = c), o) : n.directives[l];
			},
			mount(l, c, u) {
				if (!s) {
					const h = Ge(t, i);
					return (
						(h.appContext = n),
						c && e ? e(h, l) : r(h, l, u),
						(s = !0),
						(o._container = l),
						(l.__vue_app__ = o),
						el(h.component) || h.component.proxy
					);
				}
			},
			unmount() {
				s && (r(null, o._container), delete o._container.__vue_app__);
			},
			provide(l, c) {
				return (n.provides[l] = c), o;
			}
		});
		return o;
	};
}
function Pc(r, e, t, i, n = !1) {
	if (ze(r)) {
		r.forEach((d, p) => Pc(d, e && (ze(e) ? e[p] : e), t, i, n));
		return;
	}
	if (So(i) && !n) return;
	const a = i.shapeFlag & 4 ? el(i.component) || i.component.proxy : i.el,
		s = n ? null : a,
		{ i: o, r: l } = r,
		c = e && e.r,
		u = o.refs === st ? (o.refs = {}) : o.refs,
		h = o.setupState;
	if (
		(c != null &&
            c !== l &&
            (xt(c)
            	? ((u[c] = null), qe(h, c) && (h[c] = null))
            	: Rt(c) && (c.value = null)),
		He(l))
	)
		Si(l, o, 12, [s, u]);
	else {
		const d = xt(l),
			p = Rt(l);
		if (d || p) {
			const g = () => {
				if (r.f) {
					const m = d ? u[l] : l.value;
					n
						? ze(m) && cu(m, a)
						: ze(m)
							? m.includes(a) || m.push(a)
							: d
								? ((u[l] = [a]), qe(h, l) && (h[l] = u[l]))
								: ((l.value = [a]), r.k && (u[r.k] = l.value));
				} else
					d
						? ((u[l] = s), qe(h, l) && (h[l] = s))
						: Rt(l) && ((l.value = s), r.k && (u[r.k] = s));
			};
			s ? ((g.id = -1), Gt(g, t)) : g();
		}
	}
}
const Gt = Rv;
function ny(r) {
	return ay(r);
}
function ay(r, e) {
	const t = U0();
	t.__VUE__ = !0;
	const {
			insert: i,
			remove: n,
			patchProp: a,
			createElement: s,
			createText: o,
			createComment: l,
			setText: c,
			setElementText: u,
			parentNode: h,
			nextSibling: d,
			setScopeId: p = Dr,
			cloneNode: g,
			insertStaticContent: m
		} = r,
		f = (
			w,
			R,
			N,
			q = null,
			$ = null,
			ne = null,
			le = !1,
			he = null,
			ge = !!R.dynamicChildren
		) => {
			if (w === R) return;
			w && !Yi(w, R) && ((q = Ae(w)), xe(w, $, ne, !0), (w = null)),
			R.patchFlag === -2 && ((ge = !1), (R.dynamicChildren = null));
			const { type: _, ref: y, shapeFlag: F } = R;
			switch (_) {
			case Tu:
				v(w, R, N, q);
				break;
			case xr:
				x(w, R, N, q);
				break;
			case Ja:
				w == null && A(R, N, q, le);
				break;
			case gt:
				j(w, R, N, q, $, ne, le, he, ge);
				break;
			default:
				F & 1
					? I(w, R, N, q, $, ne, le, he, ge)
					: F & 6
						? z(w, R, N, q, $, ne, le, he, ge)
						: (F & 64 || F & 128) &&
                          _.process(w, R, N, q, $, ne, le, he, ge, ae);
			}
			y != null && $ && Pc(y, w && w.ref, ne, R || w, !R);
		},
		v = (w, R, N, q) => {
			if (w == null) i((R.el = o(R.children)), N, q);
			else {
				const $ = (R.el = w.el);
				R.children !== w.children && c($, R.children);
			}
		},
		x = (w, R, N, q) => {
			w == null ? i((R.el = l(R.children || '')), N, q) : (R.el = w.el);
		},
		A = (w, R, N, q) => {
			[w.el, w.anchor] = m(w.children, R, N, q, w.el, w.anchor);
		},
		S = ({ el: w, anchor: R }, N, q) => {
			let $;
			for (; w && w !== R; ) ($ = d(w)), i(w, N, q), (w = $);
			i(R, N, q);
		},
		M = ({ el: w, anchor: R }) => {
			let N;
			for (; w && w !== R; ) (N = d(w)), n(w), (w = N);
			n(R);
		},
		I = (w, R, N, q, $, ne, le, he, ge) => {
			(le = le || R.type === 'svg'),
			w == null
				? D(R, N, q, $, ne, le, he, ge)
				: B(w, R, $, ne, le, he, ge);
		},
		D = (w, R, N, q, $, ne, le, he) => {
			let ge, _;
			const {
				type: y,
				props: F,
				shapeFlag: Y,
				transition: oe,
				patchFlag: pe,
				dirs: Me
			} = w;
			if (w.el && g !== void 0 && pe === -1) ge = w.el = g(w.el);
			else {
				if (
					((ge = w.el = s(w.type, ne, F && F.is, F)),
					Y & 8
						? u(ge, w.children)
						: Y & 16 &&
                          re(
                          	w.children,
                          	ge,
                          	null,
                          	q,
                          	$,
                          	ne && y !== 'foreignObject',
                          	le,
                          	he
                          ),
					Me && Ui(w, null, q, 'created'),
					F)
				) {
					for (const se in F)
						se !== 'value' &&
                            !bo(se) &&
                            a(ge, se, null, F[se], ne, w.children, q, $, ve);
					'value' in F && a(ge, 'value', null, F.value),
					(_ = F.onVnodeBeforeMount) && Tr(_, q, w);
				}
				G(ge, w, w.scopeId, le, q);
			}
			Me && Ui(w, null, q, 'beforeMount');
			const T = (!$ || ($ && !$.pendingBranch)) && oe && !oe.persisted;
			T && oe.beforeEnter(ge),
			i(ge, R, N),
			((_ = F && F.onVnodeMounted) || T || Me) &&
                    Gt(() => {
                    	_ && Tr(_, q, w),
                    	T && oe.enter(ge),
                    	Me && Ui(w, null, q, 'mounted');
                    }, $);
		},
		G = (w, R, N, q, $) => {
			if ((N && p(w, N), q))
				for (let ne = 0; ne < q.length; ne++) p(w, q[ne]);
			if ($) {
				let ne = $.subTree;
				if (R === ne) {
					const le = $.vnode;
					G(w, le, le.scopeId, le.slotScopeIds, $.parent);
				}
			}
		},
		re = (w, R, N, q, $, ne, le, he, ge = 0) => {
			for (let _ = ge; _ < w.length; _++) {
				const y = (w[_] = he ? xi(w[_]) : Rr(w[_]));
				f(null, y, R, N, q, $, ne, le, he);
			}
		},
		B = (w, R, N, q, $, ne, le) => {
			const he = (R.el = w.el);
			let { patchFlag: ge, dynamicChildren: _, dirs: y } = R;
			ge |= w.patchFlag & 16;
			const F = w.props || st,
				Y = R.props || st;
			let oe;
			N && Bi(N, !1),
			(oe = Y.onVnodeBeforeUpdate) && Tr(oe, N, R, w),
			y && Ui(R, w, N, 'beforeUpdate'),
			N && Bi(N, !0);
			const pe = $ && R.type !== 'foreignObject';
			if (
				(_
					? b(w.dynamicChildren, _, he, N, q, pe, ne)
					: le || Z(w, R, he, null, N, q, pe, ne, !1),
				ge > 0)
			) {
				if (ge & 16) E(he, R, F, Y, N, q, $);
				else if (
					(ge & 2 &&
                        F.class !== Y.class &&
                        a(he, 'class', null, Y.class, $),
					ge & 4 && a(he, 'style', F.style, Y.style, $),
					ge & 8)
				) {
					const Me = R.dynamicProps;
					for (let T = 0; T < Me.length; T++) {
						const se = Me[T],
							Re = F[se],
							_e = Y[se];
						(_e !== Re || se === 'value') &&
                            a(he, se, Re, _e, $, w.children, N, q, ve);
					}
				}
				ge & 1 && w.children !== R.children && u(he, R.children);
			} else !le && _ == null && E(he, R, F, Y, N, q, $);
			((oe = Y.onVnodeUpdated) || y) &&
                Gt(() => {
                	oe && Tr(oe, N, R, w), y && Ui(R, w, N, 'updated');
                }, q);
		},
		b = (w, R, N, q, $, ne, le) => {
			for (let he = 0; he < R.length; he++) {
				const ge = w[he],
					_ = R[he],
					y =
                        ge.el &&
                        (ge.type === gt || !Yi(ge, _) || ge.shapeFlag & 70)
                        	? h(ge.el)
                        	: N;
				f(ge, _, y, null, q, $, ne, le, !0);
			}
		},
		E = (w, R, N, q, $, ne, le) => {
			if (N !== q) {
				for (const he in q) {
					if (bo(he)) continue;
					const ge = q[he],
						_ = N[he];
					ge !== _ &&
                        he !== 'value' &&
                        a(w, he, _, ge, le, R.children, $, ne, ve);
				}
				if (N !== st)
					for (const he in N)
						!bo(he) &&
                            !(he in q) &&
                            a(w, he, N[he], null, le, R.children, $, ne, ve);
				'value' in q && a(w, 'value', N.value, q.value);
			}
		},
		j = (w, R, N, q, $, ne, le, he, ge) => {
			const _ = (R.el = w ? w.el : o('')),
				y = (R.anchor = w ? w.anchor : o(''));
			let { patchFlag: F, dynamicChildren: Y, slotScopeIds: oe } = R;
			oe && (he = he ? he.concat(oe) : oe),
			w == null
				? (i(_, N, q),
				i(y, N, q),
				re(R.children, N, y, $, ne, le, he, ge))
				: F > 0 && F & 64 && Y && w.dynamicChildren
					? (b(w.dynamicChildren, Y, N, $, ne, le, he),
					(R.key != null || ($ && R === $.subTree)) && Su(w, R, !0))
					: Z(w, R, N, y, $, ne, le, he, ge);
		},
		z = (w, R, N, q, $, ne, le, he, ge) => {
			(R.slotScopeIds = he),
			w == null
				? R.shapeFlag & 512
					? $.ctx.activate(R, N, q, le, ge)
					: V(R, N, q, $, ne, le, ge)
				: H(w, R, ge);
		},
		V = (w, R, N, q, $, ne, le) => {
			const he = (w.component = gy(w, q, $));
			if (($o(w) && (he.ctx.renderer = ae), vy(he), he.asyncDep)) {
				if (($ && $.registerDep(he, k), !w.el)) {
					const ge = (he.subTree = Ge(xr));
					x(null, ge, R, N);
				}
				return;
			}
			k(he, w, R, N, $, ne, le);
		},
		H = (w, R, N) => {
			const q = (R.component = w.component);
			if (Ev(w, R, N))
				if (q.asyncDep && !q.asyncResolved) {
					P(q, R, N);
					return;
				} else (q.next = R), bv(q.update), q.update();
			else (R.el = w.el), (q.vnode = R);
		},
		k = (w, R, N, q, $, ne, le) => {
			const he = () => {
					if (w.isMounted) {
						let { next: y, bu: F, u: Y, parent: oe, vnode: pe } = w,
							Me = y,
							T;
						Bi(w, !1),
						y ? ((y.el = pe.el), P(w, y, le)) : (y = pe),
						F && wo(F),
						(T = y.props && y.props.onVnodeBeforeUpdate) &&
                                Tr(T, oe, y, pe),
						Bi(w, !0);
						const se = _l(w),
							Re = w.subTree;
						(w.subTree = se),
						f(Re, se, h(Re.el), Ae(Re), w, $, ne),
						(y.el = se.el),
						Me === null && Av(w, se.el),
						Y && Gt(Y, $),
						(T = y.props && y.props.onVnodeUpdated) &&
                                Gt(() => Tr(T, oe, y, pe), $);
					} else {
						let y;
						const { el: F, props: Y } = R,
							{ bm: oe, m: pe, parent: Me } = w,
							T = So(R);
						if (
							(Bi(w, !1),
							oe && wo(oe),
							!T &&
                                (y = Y && Y.onVnodeBeforeMount) &&
                                Tr(y, Me, R),
							Bi(w, !0),
							F && te)
						) {
							const se = () => {
								(w.subTree = _l(w)),
								te(F, w.subTree, w, $, null);
							};
							T
								? R.type
									.__asyncLoader()
									.then(() => !w.isUnmounted && se())
								: se();
						} else {
							const se = (w.subTree = _l(w));
							f(null, se, N, q, w, $, ne), (R.el = se.el);
						}
						if (
							(pe && Gt(pe, $), !T && (y = Y && Y.onVnodeMounted))
						) {
							const se = R;
							Gt(() => Tr(y, Me, se), $);
						}
						(R.shapeFlag & 256 ||
                            (Me && So(Me.vnode) && Me.vnode.shapeFlag & 256)) &&
                            w.a &&
                            Gt(w.a, $),
						(w.isMounted = !0),
						(R = N = q = null);
					}
				},
				ge = (w.effect = new pu(he, () => Hm(_), w.scope)),
				_ = (w.update = () => ge.run());
			(_.id = w.uid), Bi(w, !0), _();
		},
		P = (w, R, N) => {
			R.component = w;
			const q = w.vnode.props;
			(w.vnode = R),
			(w.next = null),
			Jv(w, R.props, q, N),
			ty(w, R.children, N),
			va(),
			qo(void 0, w.update),
			ya();
		},
		Z = (w, R, N, q, $, ne, le, he, ge = !1) => {
			const _ = w && w.children,
				y = w ? w.shapeFlag : 0,
				F = R.children,
				{ patchFlag: Y, shapeFlag: oe } = R;
			if (Y > 0) {
				if (Y & 128) {
					fe(_, F, N, q, $, ne, le, he, ge);
					return;
				} else if (Y & 256) {
					J(_, F, N, q, $, ne, le, he, ge);
					return;
				}
			}
			oe & 8
				? (y & 16 && ve(_, $, ne), F !== _ && u(N, F))
				: y & 16
					? oe & 16
						? fe(_, F, N, q, $, ne, le, he, ge)
						: ve(_, $, ne, !0)
					: (y & 8 && u(N, ''),
					oe & 16 && re(F, N, q, $, ne, le, he, ge));
		},
		J = (w, R, N, q, $, ne, le, he, ge) => {
			(w = w || $n), (R = R || $n);
			const _ = w.length,
				y = R.length,
				F = Math.min(_, y);
			let Y;
			for (Y = 0; Y < F; Y++) {
				const oe = (R[Y] = ge ? xi(R[Y]) : Rr(R[Y]));
				f(w[Y], oe, N, null, $, ne, le, he, ge);
			}
			_ > y ? ve(w, $, ne, !0, !1, F) : re(R, N, q, $, ne, le, he, ge, F);
		},
		fe = (w, R, N, q, $, ne, le, he, ge) => {
			let _ = 0;
			const y = R.length;
			let F = w.length - 1,
				Y = y - 1;
			for (; _ <= F && _ <= Y; ) {
				const oe = w[_],
					pe = (R[_] = ge ? xi(R[_]) : Rr(R[_]));
				if (Yi(oe, pe)) f(oe, pe, N, null, $, ne, le, he, ge);
				else break;
				_++;
			}
			for (; _ <= F && _ <= Y; ) {
				const oe = w[F],
					pe = (R[Y] = ge ? xi(R[Y]) : Rr(R[Y]));
				if (Yi(oe, pe)) f(oe, pe, N, null, $, ne, le, he, ge);
				else break;
				F--, Y--;
			}
			if (_ > F) {
				if (_ <= Y) {
					const oe = Y + 1,
						pe = oe < y ? R[oe].el : q;
					for (; _ <= Y; )
						f(
							null,
							(R[_] = ge ? xi(R[_]) : Rr(R[_])),
							N,
							pe,
							$,
							ne,
							le,
							he,
							ge
						),
						_++;
				}
			} else if (_ > Y) for (; _ <= F; ) xe(w[_], $, ne, !0), _++;
			else {
				const oe = _,
					pe = _,
					Me = new Map();
				for (_ = pe; _ <= Y; _++) {
					const Le = (R[_] = ge ? xi(R[_]) : Rr(R[_]));
					Le.key != null && Me.set(Le.key, _);
				}
				let T,
					se = 0;
				const Re = Y - pe + 1;
				let _e = !1,
					O = 0;
				const ye = new Array(Re);
				for (_ = 0; _ < Re; _++) ye[_] = 0;
				for (_ = oe; _ <= F; _++) {
					const Le = w[_];
					if (se >= Re) {
						xe(Le, $, ne, !0);
						continue;
					}
					let be;
					if (Le.key != null) be = Me.get(Le.key);
					else
						for (T = pe; T <= Y; T++)
							if (ye[T - pe] === 0 && Yi(Le, R[T])) {
								be = T;
								break;
							}
					be === void 0
						? xe(Le, $, ne, !0)
						: ((ye[be - pe] = _ + 1),
						be >= O ? (O = be) : (_e = !0),
						f(Le, R[be], N, null, $, ne, le, he, ge),
						se++);
				}
				const we = _e ? sy(ye) : $n;
				for (T = we.length - 1, _ = Re - 1; _ >= 0; _--) {
					const Le = pe + _,
						be = R[Le],
						Ne = Le + 1 < y ? R[Le + 1].el : q;
					ye[_] === 0
						? f(null, be, N, Ne, $, ne, le, he, ge)
						: _e && (T < 0 || _ !== we[T] ? ce(be, N, Ne, 2) : T--);
				}
			}
		},
		ce = (w, R, N, q, $ = null) => {
			const {
				el: ne,
				type: le,
				transition: he,
				children: ge,
				shapeFlag: _
			} = w;
			if (_ & 6) {
				ce(w.component.subTree, R, N, q);
				return;
			}
			if (_ & 128) {
				w.suspense.move(R, N, q);
				return;
			}
			if (_ & 64) {
				le.move(w, R, N, ae);
				return;
			}
			if (le === gt) {
				i(ne, R, N);
				for (let y = 0; y < ge.length; y++) ce(ge[y], R, N, q);
				i(w.anchor, R, N);
				return;
			}
			if (le === Ja) {
				S(w, R, N);
				return;
			}
			if (q !== 2 && _ & 1 && he)
				if (q === 0)
					he.beforeEnter(ne), i(ne, R, N), Gt(() => he.enter(ne), $);
				else {
					const { leave: y, delayLeave: F, afterLeave: Y } = he,
						oe = () => i(ne, R, N),
						pe = () => {
							y(ne, () => {
								oe(), Y && Y();
							});
						};
					F ? F(ne, oe, pe) : pe();
				}
			else i(ne, R, N);
		},
		xe = (w, R, N, q = !1, $ = !1) => {
			const {
				type: ne,
				props: le,
				ref: he,
				children: ge,
				dynamicChildren: _,
				shapeFlag: y,
				patchFlag: F,
				dirs: Y
			} = w;
			if ((he != null && Pc(he, null, N, w, !0), y & 256)) {
				R.ctx.deactivate(w);
				return;
			}
			const oe = y & 1 && Y,
				pe = !So(w);
			let Me;
			if (
				(pe && (Me = le && le.onVnodeBeforeUnmount) && Tr(Me, R, w),
				y & 6)
			)
				U(w.component, N, q);
			else {
				if (y & 128) {
					w.suspense.unmount(N, q);
					return;
				}
				oe && Ui(w, null, R, 'beforeUnmount'),
				y & 64
					? w.type.remove(w, R, N, $, ae, q)
					: _ && (ne !== gt || (F > 0 && F & 64))
						? ve(_, R, N, !1, !0)
						: ((ne === gt && F & 384) || (!$ && y & 16)) &&
                          ve(ge, R, N),
				q && W(w);
			}
			((pe && (Me = le && le.onVnodeUnmounted)) || oe) &&
                Gt(() => {
                	Me && Tr(Me, R, w), oe && Ui(w, null, R, 'unmounted');
                }, N);
		},
		W = (w) => {
			const { type: R, el: N, anchor: q, transition: $ } = w;
			if (R === gt) {
				ue(N, q);
				return;
			}
			if (R === Ja) {
				M(w);
				return;
			}
			const ne = () => {
				n(N), $ && !$.persisted && $.afterLeave && $.afterLeave();
			};
			if (w.shapeFlag & 1 && $ && !$.persisted) {
				const { leave: le, delayLeave: he } = $,
					ge = () => le(N, ne);
				he ? he(w.el, ne, ge) : ge();
			} else ne();
		},
		ue = (w, R) => {
			let N;
			for (; w !== R; ) (N = d(w)), n(w), (w = N);
			n(R);
		},
		U = (w, R, N) => {
			const { bum: q, scope: $, update: ne, subTree: le, um: he } = w;
			q && wo(q),
			$.stop(),
			ne && ((ne.active = !1), xe(le, w, R, N)),
			he && Gt(he, R),
			Gt(() => {
				w.isUnmounted = !0;
			}, R),
			R &&
                    R.pendingBranch &&
                    !R.isUnmounted &&
                    w.asyncDep &&
                    !w.asyncResolved &&
                    w.suspenseId === R.pendingId &&
                    (R.deps--, R.deps === 0 && R.resolve());
		},
		ve = (w, R, N, q = !1, $ = !1, ne = 0) => {
			for (let le = ne; le < w.length; le++) xe(w[le], R, N, q, $);
		},
		Ae = (w) =>
			w.shapeFlag & 6
				? Ae(w.component.subTree)
				: w.shapeFlag & 128
					? w.suspense.next()
					: d(w.anchor || w.el),
		Te = (w, R, N) => {
			w == null
				? R._vnode && xe(R._vnode, null, null, !0)
				: f(R._vnode || null, w, R, null, null, null, N),
			Wm(),
			(R._vnode = w);
		},
		ae = {
			p: f,
			um: xe,
			m: ce,
			r: W,
			mt: V,
			mc: re,
			pc: Z,
			pbc: b,
			n: Ae,
			o: r
		};
	let K, te;
	return (
		e && ([K, te] = e(ae)), { render: Te, hydrate: K, createApp: iy(Te, K) }
	);
}
function Bi({ effect: r, update: e }, t) {
	r.allowRecurse = e.allowRecurse = t;
}
function Su(r, e, t = !1) {
	const i = r.children,
		n = e.children;
	if (ze(i) && ze(n))
		for (let a = 0; a < i.length; a++) {
			const s = i[a];
			let o = n[a];
			o.shapeFlag & 1 &&
                !o.dynamicChildren &&
                ((o.patchFlag <= 0 || o.patchFlag === 32) &&
                    ((o = n[a] = xi(n[a])), (o.el = s.el)),
                t || Su(s, o));
		}
}
function sy(r) {
	const e = r.slice(),
		t = [0];
	let i, n, a, s, o;
	const l = r.length;
	for (i = 0; i < l; i++) {
		const c = r[i];
		if (c !== 0) {
			if (((n = t[t.length - 1]), r[n] < c)) {
				(e[i] = n), t.push(i);
				continue;
			}
			for (a = 0, s = t.length - 1; a < s; )
				(o = (a + s) >> 1), r[t[o]] < c ? (a = o + 1) : (s = o);
			c < r[t[a]] && (a > 0 && (e[i] = t[a - 1]), (t[a] = i));
		}
	}
	for (a = t.length, s = t[a - 1]; a-- > 0; ) (t[a] = s), (s = e[s]);
	return t;
}
const oy = (r) => r.__isTeleport,
	Ka = (r) => r && (r.disabled || r.disabled === ''),
	Bh = (r) => typeof SVGElement != 'undefined' && r instanceof SVGElement,
	Ic = (r, e) => {
		const t = r && r.to;
		return xt(t) ? (e ? e(t) : null) : t;
	},
	ly = {
		__isTeleport: !0,
		process(r, e, t, i, n, a, s, o, l, c) {
			const {
					mc: u,
					pc: h,
					pbc: d,
					o: {
						insert: p,
						querySelector: g,
						createText: m,
						createComment: f
					}
				} = c,
				v = Ka(e.props);
			let { shapeFlag: x, children: A, dynamicChildren: S } = e;
			if (r == null) {
				const M = (e.el = m('')),
					I = (e.anchor = m(''));
				p(M, t, i), p(I, t, i);
				const D = (e.target = Ic(e.props, g)),
					G = (e.targetAnchor = m(''));
				D && (p(G, D), (s = s || Bh(D)));
				const re = (B, b) => {
					x & 16 && u(A, B, b, n, a, s, o, l);
				};
				v ? re(t, I) : D && re(D, G);
			} else {
				e.el = r.el;
				const M = (e.anchor = r.anchor),
					I = (e.target = r.target),
					D = (e.targetAnchor = r.targetAnchor),
					G = Ka(r.props),
					re = G ? t : I,
					B = G ? M : D;
				if (
					((s = s || Bh(I)),
					S
						? (d(r.dynamicChildren, S, re, n, a, s, o),
						Su(r, e, !0))
						: l || h(r, e, re, B, n, a, s, o, !1),
					v)
				)
					G || zs(e, t, M, c, 1);
				else if ((e.props && e.props.to) !== (r.props && r.props.to)) {
					const b = (e.target = Ic(e.props, g));
					b && zs(e, b, null, c, 0);
				} else G && zs(e, I, D, c, 1);
			}
		},
		remove(r, e, t, i, { um: n, o: { remove: a } }, s) {
			const {
				shapeFlag: o,
				children: l,
				anchor: c,
				targetAnchor: u,
				target: h,
				props: d
			} = r;
			if ((h && a(u), (s || !Ka(d)) && (a(c), o & 16)))
				for (let p = 0; p < l.length; p++) {
					const g = l[p];
					n(g, e, t, !0, !!g.dynamicChildren);
				}
		},
		move: zs,
		hydrate: cy
	};
function zs(r, e, t, { o: { insert: i }, m: n }, a = 2) {
	a === 0 && i(r.targetAnchor, e, t);
	const { el: s, anchor: o, shapeFlag: l, children: c, props: u } = r,
		h = a === 2;
	if ((h && i(s, e, t), (!h || Ka(u)) && l & 16))
		for (let d = 0; d < c.length; d++) n(c[d], e, t, 2);
	h && i(o, e, t);
}
function cy(
	r,
	e,
	t,
	i,
	n,
	a,
	{ o: { nextSibling: s, parentNode: o, querySelector: l } },
	c
) {
	const u = (e.target = Ic(e.props, l));
	if (u) {
		const h = u._lpa || u.firstChild;
		if (e.shapeFlag & 16)
			if (Ka(e.props))
				(e.anchor = c(s(r), e, o(r), t, i, n, a)), (e.targetAnchor = h);
			else {
				e.anchor = s(r);
				let d = h;
				for (; d; )
					if (
						((d = s(d)),
						d && d.nodeType === 8 && d.data === 'teleport anchor')
					) {
						(e.targetAnchor = d),
						(u._lpa = e.targetAnchor && s(e.targetAnchor));
						break;
					}
				c(h, e, u, t, i, n, a);
			}
	}
	return e.anchor && s(e.anchor);
}
const pf = ly,
	gt = Symbol(void 0),
	Tu = Symbol(void 0),
	xr = Symbol(void 0),
	Ja = Symbol(void 0),
	Qa = [];
let gr = null;
function Ce(r = !1) {
	Qa.push((gr = r ? null : []));
}
function uy() {
	Qa.pop(), (gr = Qa[Qa.length - 1] || null);
}
let hs = 1;
function Fh(r) {
	hs += r;
}
function mf(r) {
	return (
		(r.dynamicChildren = hs > 0 ? gr || $n : null),
		uy(),
		hs > 0 && gr && gr.push(r),
		r
	);
}
function Oe(r, e, t, i, n, a) {
	return mf(ee(r, e, t, i, n, a, !0));
}
function en(r, e, t, i, n) {
	return mf(Ge(r, e, t, i, n, !0));
}
function Dc(r) {
	return r ? r.__v_isVNode === !0 : !1;
}
function Yi(r, e) {
	return r.type === e.type && r.key === e.key;
}
const Jo = '__vInternal',
	ff = ({ key: r }) => (r != null ? r : null),
	To = ({ ref: r, ref_key: e, ref_for: t }) =>
		r != null
			? xt(r) || Rt(r) || He(r)
				? { i: Jt, r, k: e, f: !!t }
				: r
			: null;
function ee(
	r,
	e = null,
	t = null,
	i = 0,
	n = null,
	a = r === gt ? 0 : 1,
	s = !1,
	o = !1
) {
	const l = {
		__v_isVNode: !0,
		__v_skip: !0,
		type: r,
		props: e,
		key: e && ff(e),
		ref: e && To(e),
		scopeId: Zo,
		slotScopeIds: null,
		children: t,
		component: null,
		suspense: null,
		ssContent: null,
		ssFallback: null,
		dirs: null,
		transition: null,
		el: null,
		anchor: null,
		target: null,
		targetAnchor: null,
		staticCount: 0,
		shapeFlag: a,
		patchFlag: i,
		dynamicProps: n,
		dynamicChildren: null,
		appContext: null
	};
	return (
		o
			? (Eu(l, t), a & 128 && r.normalize(l))
			: t && (l.shapeFlag |= xt(t) ? 8 : 16),
		hs > 0 &&
            !s &&
            gr &&
            (l.patchFlag > 0 || a & 6) &&
            l.patchFlag !== 32 &&
            gr.push(l),
		l
	);
}
const Ge = hy;
function hy(r, e = null, t = null, i = 0, n = null, a = !1) {
	if (((!r || r === rf) && (r = xr), Dc(r))) {
		const o = Ci(r, e, !0);
		return (
			t && Eu(o, t),
			hs > 0 &&
                !a &&
                gr &&
                (o.shapeFlag & 6 ? (gr[gr.indexOf(r)] = o) : gr.push(o)),
			(o.patchFlag |= -2),
			o
		);
	}
	if ((_y(r) && (r = r.__vccOpts), e)) {
		e = dy(e);
		let { class: o, style: l } = e;
		o && !xt(o) && (e.class = nr(o)),
		bt(l) && (Im(l) && !ze(l) && (l = Pt({}, l)), (e.style = cn(l)));
	}
	const s = xt(r) ? 1 : Lv(r) ? 128 : oy(r) ? 64 : bt(r) ? 4 : He(r) ? 2 : 0;
	return ee(r, e, t, i, n, s, a, !0);
}
function dy(r) {
	return r ? (Im(r) || Jo in r ? Pt({}, r) : r) : null;
}
function Ci(r, e, t = !1) {
	const { props: i, ref: n, patchFlag: a, children: s } = r,
		o = e ? py(i || {}, e) : i;
	return {
		__v_isVNode: !0,
		__v_skip: !0,
		type: r.type,
		props: o,
		key: o && ff(o),
		ref:
            e && e.ref
            	? t && n
            		? ze(n)
            			? n.concat(To(e))
            			: [n, To(e)]
            		: To(e)
            	: n,
		scopeId: r.scopeId,
		slotScopeIds: r.slotScopeIds,
		children: s,
		target: r.target,
		targetAnchor: r.targetAnchor,
		staticCount: r.staticCount,
		shapeFlag: r.shapeFlag,
		patchFlag: e && r.type !== gt ? (a === -1 ? 16 : a | 16) : a,
		dynamicProps: r.dynamicProps,
		dynamicChildren: r.dynamicChildren,
		appContext: r.appContext,
		dirs: r.dirs,
		transition: r.transition,
		component: r.component,
		suspense: r.suspense,
		ssContent: r.ssContent && Ci(r.ssContent),
		ssFallback: r.ssFallback && Ci(r.ssFallback),
		el: r.el,
		anchor: r.anchor
	};
}
function ar(r = ' ', e = 0) {
	return Ge(Tu, null, r, e);
}
function Qo(r, e) {
	const t = Ge(Ja, null, r);
	return (t.staticCount = e), t;
}
function Ot(r = '', e = !1) {
	return e ? (Ce(), en(xr, null, r)) : Ge(xr, null, r);
}
function Rr(r) {
	return r == null || typeof r == 'boolean'
		? Ge(xr)
		: ze(r)
			? Ge(gt, null, r.slice())
			: typeof r == 'object'
				? xi(r)
				: Ge(Tu, null, String(r));
}
function xi(r) {
	return r.el === null || r.memo ? r : Ci(r);
}
function Eu(r, e) {
	let t = 0;
	const { shapeFlag: i } = r;
	if (e == null) e = null;
	else if (ze(e)) t = 16;
	else if (typeof e == 'object')
		if (i & 65) {
			const n = e.default;
			n && (n._c && (n._d = !1), Eu(r, n()), n._c && (n._d = !0));
			return;
		} else {
			t = 32;
			const n = e._;
			!n && !(Jo in e)
				? (e._ctx = Jt)
				: n === 3 &&
                  Jt &&
                  (Jt.slots._ === 1
                  	? (e._ = 1)
                  	: ((e._ = 2), (r.patchFlag |= 1024)));
		}
	else
		He(e)
			? ((e = { default: e, _ctx: Jt }), (t = 32))
			: ((e = String(e)), i & 64 ? ((t = 16), (e = [ar(e)])) : (t = 8));
	(r.children = e), (r.shapeFlag |= t);
}
function py(...r) {
	const e = {};
	for (let t = 0; t < r.length; t++) {
		const i = r[t];
		for (const n in i)
			if (n === 'class')
				e.class !== i.class && (e.class = nr([e.class, i.class]));
			else if (n === 'style') e.style = cn([e.style, i.style]);
			else if (Ho(n)) {
				const a = e[n],
					s = i[n];
				s &&
                    a !== s &&
                    !(ze(a) && a.includes(s)) &&
                    (e[n] = a ? [].concat(a, s) : s);
			} else n !== '' && (e[n] = i[n]);
	}
	return e;
}
function Tr(r, e, t, i = null) {
	er(r, e, 7, [t, i]);
}
const my = df();
let fy = 0;
function gy(r, e, t) {
	const i = r.type,
		n = (e ? e.appContext : r.appContext) || my,
		a = {
			uid: fy++,
			vnode: r,
			type: i,
			parent: e,
			appContext: n,
			root: null,
			next: null,
			subTree: null,
			effect: null,
			update: null,
			scope: new B0(!0),
			render: null,
			proxy: null,
			exposed: null,
			exposeProxy: null,
			withProxy: null,
			provides: e ? e.provides : Object.create(n.provides),
			accessCache: null,
			renderCache: [],
			components: null,
			directives: null,
			propsOptions: lf(i, n),
			emitsOptions: Xm(i, n),
			emit: null,
			emitted: null,
			propsDefaults: st,
			inheritAttrs: i.inheritAttrs,
			ctx: st,
			data: st,
			props: st,
			attrs: st,
			slots: st,
			refs: st,
			setupState: st,
			setupContext: null,
			suspense: t,
			suspenseId: t ? t.pendingId : 0,
			asyncDep: null,
			asyncResolved: !1,
			isMounted: !1,
			isUnmounted: !1,
			isDeactivated: !1,
			bc: null,
			c: null,
			bm: null,
			m: null,
			bu: null,
			u: null,
			um: null,
			bum: null,
			da: null,
			a: null,
			rtg: null,
			rtc: null,
			ec: null,
			sp: null
		};
	return (
		(a.ctx = { _: a }),
		(a.root = e ? e.root : a),
		(a.emit = Mv.bind(null, a)),
		r.ce && r.ce(a),
		a
	);
}
let At = null;
const gf = () => At || Jt,
	ia = (r) => {
		(At = r), r.scope.on();
	},
	tn = () => {
		At && At.scope.off(), (At = null);
	};
function vf(r) {
	return r.vnode.shapeFlag & 4;
}
let ds = !1;
function vy(r, e = !1) {
	ds = e;
	const { props: t, children: i } = r.vnode,
		n = vf(r);
	Kv(r, t, n, e), ey(r, i);
	const a = n ? yy(r, e) : void 0;
	return (ds = !1), a;
}
function yy(r, e) {
	const t = r.type;
	(r.accessCache = Object.create(null)), (r.proxy = Dm(new Proxy(r.ctx, jv)));
	const { setup: i } = t;
	if (i) {
		const n = (r.setupContext = i.length > 1 ? by(r) : null);
		ia(r), va();
		const a = Si(i, r, 0, [r.props, n]);
		if ((ya(), tn(), xm(a))) {
			if ((a.then(tn, tn), e))
				return a
					.then((s) => {
						Hh(r, s, e);
					})
					.catch((s) => {
						Xo(s, r, 0);
					});
			r.asyncDep = a;
		} else Hh(r, a, e);
	} else yf(r, e);
}
function Hh(r, e, t) {
	He(e)
		? r.type.__ssrInlineRender
			? (r.ssrRender = e)
			: (r.render = e)
		: bt(e) && (r.setupState = Um(e)),
	yf(r, t);
}
let Gh;
function yf(r, e, t) {
	const i = r.type;
	if (!r.render) {
		if (!e && Gh && !i.render) {
			const n = i.template;
			if (n) {
				const { isCustomElement: a, compilerOptions: s } =
                        r.appContext.config,
					{ delimiters: o, compilerOptions: l } = i,
					c = Pt(Pt({ isCustomElement: a, delimiters: o }, s), l);
				i.render = Gh(n, c);
			}
		}
		r.render = i.render || Dr;
	}
	ia(r), va(), Xv(r), ya(), tn();
}
function xy(r) {
	return new Proxy(r.attrs, {
		get(e, t) {
			return qt(r, 'get', '$attrs'), e[t];
		}
	});
}
function by(r) {
	const e = (i) => {
		r.exposed = i || {};
	};
	let t;
	return {
		get attrs() {
			return t || (t = xy(r));
		},
		slots: r.slots,
		emit: r.emit,
		expose: e
	};
}
function el(r) {
	if (r.exposed)
		return (
			r.exposeProxy ||
            (r.exposeProxy = new Proxy(Um(Dm(r.exposed)), {
            	get(e, t) {
            		if (t in e) return e[t];
            		if (t in Io) return Io[t](r);
            	}
            }))
		);
}
function wy(r) {
	return (He(r) && r.displayName) || r.name;
}
function _y(r) {
	return He(r) && '__vccOpts' in r;
}
const mr = (r, e) => vv(r, e, ds);
function Au(r, e, t) {
	const i = arguments.length;
	return i === 2
		? bt(e) && !ze(e)
			? Dc(e)
				? Ge(r, null, [e])
				: Ge(r, e)
			: Ge(r, null, e)
		: (i > 3
			? (t = Array.prototype.slice.call(arguments, 2))
			: i === 3 && Dc(t) && (t = [t]),
		Ge(r, e, t));
}
const My = '3.2.36',
	Sy = 'http://www.w3.org/2000/svg',
	Zi = typeof document != 'undefined' ? document : null,
	Vh = Zi && Zi.createElement('template'),
	Ty = {
		insert: (r, e, t) => {
			e.insertBefore(r, t || null);
		},
		remove: (r) => {
			const e = r.parentNode;
			e && e.removeChild(r);
		},
		createElement: (r, e, t, i) => {
			const n = e
				? Zi.createElementNS(Sy, r)
				: Zi.createElement(r, t ? { is: t } : void 0);
			return (
				r === 'select' &&
                    i &&
                    i.multiple != null &&
                    n.setAttribute('multiple', i.multiple),
				n
			);
		},
		createText: (r) => Zi.createTextNode(r),
		createComment: (r) => Zi.createComment(r),
		setText: (r, e) => {
			r.nodeValue = e;
		},
		setElementText: (r, e) => {
			r.textContent = e;
		},
		parentNode: (r) => r.parentNode,
		nextSibling: (r) => r.nextSibling,
		querySelector: (r) => Zi.querySelector(r),
		setScopeId(r, e) {
			r.setAttribute(e, '');
		},
		cloneNode(r) {
			const e = r.cloneNode(!0);
			return '_value' in r && (e._value = r._value), e;
		},
		insertStaticContent(r, e, t, i, n, a) {
			const s = t ? t.previousSibling : e.lastChild;
			if (n && (n === a || n.nextSibling))
				for (
					;
					e.insertBefore(n.cloneNode(!0), t),
					!(n === a || !(n = n.nextSibling));

				);
			else {
				Vh.innerHTML = i ? `<svg>${r}</svg>` : r;
				const o = Vh.content;
				if (i) {
					const l = o.firstChild;
					for (; l.firstChild; ) o.appendChild(l.firstChild);
					o.removeChild(l);
				}
				e.insertBefore(o, t);
			}
			return [
				s ? s.nextSibling : e.firstChild,
				t ? t.previousSibling : e.lastChild
			];
		}
	};
function Ey(r, e, t) {
	const i = r._vtc;
	i && (e = (e ? [e, ...i] : [...i]).join(' ')),
	e == null
		? r.removeAttribute('class')
		: t
			? r.setAttribute('class', e)
			: (r.className = e);
}
function Ay(r, e, t) {
	const i = r.style,
		n = xt(t);
	if (t && !n) {
		for (const a in t) Oc(i, a, t[a]);
		if (e && !xt(e)) for (const a in e) t[a] == null && Oc(i, a, '');
	} else {
		const a = i.display;
		n ? e !== t && (i.cssText = t) : e && r.removeAttribute('style'),
		'_vod' in r && (i.display = a);
	}
}
const Wh = /\s*!important$/;
function Oc(r, e, t) {
	if (ze(t)) t.forEach((i) => Oc(r, e, i));
	else if ((t == null && (t = ''), e.startsWith('--'))) r.setProperty(e, t);
	else {
		const i = Ly(r, e);
		Wh.test(t)
			? r.setProperty(ga(i), t.replace(Wh, ''), 'important')
			: (r[i] = t);
	}
}
const jh = ['Webkit', 'Moz', 'ms'],
	Sl = {};
function Ly(r, e) {
	const t = Sl[e];
	if (t) return t;
	let i = Or(e);
	if (i !== 'filter' && i in r) return (Sl[e] = i);
	i = Wo(i);
	for (let n = 0; n < jh.length; n++) {
		const a = jh[n] + i;
		if (a in r) return (Sl[e] = a);
	}
	return e;
}
const Xh = 'http://www.w3.org/1999/xlink';
function Ry(r, e, t, i, n) {
	if (i && e.startsWith('xlink:'))
		t == null
			? r.removeAttributeNS(Xh, e.slice(6, e.length))
			: r.setAttributeNS(Xh, e, t);
	else {
		const a = L0(e);
		t == null || (a && !gm(t))
			? r.removeAttribute(e)
			: r.setAttribute(e, a ? '' : t);
	}
}
function ky(r, e, t, i, n, a, s) {
	if (e === 'innerHTML' || e === 'textContent') {
		i && s(i, n, a), (r[e] = t == null ? '' : t);
		return;
	}
	if (e === 'value' && r.tagName !== 'PROGRESS' && !r.tagName.includes('-')) {
		r._value = t;
		const l = t == null ? '' : t;
		(r.value !== l || r.tagName === 'OPTION') && (r.value = l),
		t == null && r.removeAttribute(e);
		return;
	}
	let o = !1;
	if (t === '' || t == null) {
		const l = typeof r[e];
		l === 'boolean'
			? (t = gm(t))
			: t == null && l === 'string'
				? ((t = ''), (o = !0))
				: l === 'number' && ((t = 0), (o = !0));
	}
	try {
		r[e] = t;
	} catch {}
	o && r.removeAttribute(e);
}
const [xf, Cy] = (() => {
	let r = Date.now,
		e = !1;
	if (typeof window != 'undefined') {
		Date.now() > document.createEvent('Event').timeStamp &&
            (r = performance.now.bind(performance));
		const t = navigator.userAgent.match(/firefox\/(\d+)/i);
		e = !!(t && Number(t[1]) <= 53);
	}
	return [r, e];
})();
let Nc = 0;
const Py = Promise.resolve(),
	Iy = () => {
		Nc = 0;
	},
	Dy = () => Nc || (Py.then(Iy), (Nc = xf()));
function Vn(r, e, t, i) {
	r.addEventListener(e, t, i);
}
function Oy(r, e, t, i) {
	r.removeEventListener(e, t, i);
}
function Ny(r, e, t, i, n = null) {
	const a = r._vei || (r._vei = {}),
		s = a[e];
	if (i && s) s.value = i;
	else {
		const [o, l] = zy(e);
		if (i) {
			const c = (a[e] = Uy(i, n));
			Vn(r, o, c, l);
		} else s && (Oy(r, o, s, l), (a[e] = void 0));
	}
}
const qh = /(?:Once|Passive|Capture)$/;
function zy(r) {
	let e;
	if (qh.test(r)) {
		e = {};
		let t;
		for (; (t = r.match(qh)); )
			(r = r.slice(0, r.length - t[0].length)),
			(e[t[0].toLowerCase()] = !0);
	}
	return [ga(r.slice(2)), e];
}
function Uy(r, e) {
	const t = (i) => {
		const n = i.timeStamp || xf();
		(Cy || n >= t.attached - 1) && er(By(i, t.value), e, 5, [i]);
	};
	return (t.value = r), (t.attached = Dy()), t;
}
function By(r, e) {
	if (ze(e)) {
		const t = r.stopImmediatePropagation;
		return (
			(r.stopImmediatePropagation = () => {
				t.call(r), (r._stopped = !0);
			}),
			e.map((i) => (n) => !n._stopped && i && i(n))
		);
	} else return e;
}
const Yh = /^on[a-z]/,
	Fy = (r, e, t, i, n = !1, a, s, o, l) => {
		e === 'class'
			? Ey(r, i, n)
			: e === 'style'
				? Ay(r, t, i)
				: Ho(e)
					? lu(e) || Ny(r, e, t, i, s)
					: (
						e[0] === '.'
							? ((e = e.slice(1)), !0)
							: e[0] === '^'
								? ((e = e.slice(1)), !1)
								: Hy(r, e, i, n)
					)
						? ky(r, e, i, a, s, o, l)
						: (e === 'true-value'
							? (r._trueValue = i)
							: e === 'false-value' && (r._falseValue = i),
						Ry(r, e, i, n));
	};
function Hy(r, e, t, i) {
	return i
		? !!(
			e === 'innerHTML' ||
              e === 'textContent' ||
              (e in r && Yh.test(e) && He(t))
		)
		: e === 'spellcheck' ||
          e === 'draggable' ||
          e === 'translate' ||
          e === 'form' ||
          (e === 'list' && r.tagName === 'INPUT') ||
          (e === 'type' && r.tagName === 'TEXTAREA') ||
          (Yh.test(e) && xt(t))
			? !1
			: e in r;
}
function bf(r) {
	const e = gf();
	if (!e) return;
	const t = () => zc(e.subTree, r(e.proxy));
	kv(t),
	As(() => {
		const i = new MutationObserver(t);
		i.observe(e.subTree.el.parentNode, { childList: !0 }),
		wu(() => i.disconnect());
	});
}
function zc(r, e) {
	if (r.shapeFlag & 128) {
		const t = r.suspense;
		(r = t.activeBranch),
		t.pendingBranch &&
                !t.isHydrating &&
                t.effects.push(() => {
                	zc(t.activeBranch, e);
                });
	}
	for (; r.component; ) r = r.component.subTree;
	if (r.shapeFlag & 1 && r.el) Zh(r.el, e);
	else if (r.type === gt) r.children.forEach((t) => zc(t, e));
	else if (r.type === Ja) {
		let { el: t, anchor: i } = r;
		for (; t && (Zh(t, e), t !== i); ) t = t.nextSibling;
	}
}
function Zh(r, e) {
	if (r.nodeType === 1) {
		const t = r.style;
		for (const i in e) t.setProperty(`--${i}`, e[i]);
	}
}
const ai = 'transition',
	Pa = 'animation',
	xa = (r, { slots: e }) => Au($m, Gy(r), e);
xa.displayName = 'Transition';
const wf = {
	name: String,
	type: String,
	css: { type: Boolean, default: !0 },
	duration: [String, Number, Object],
	enterFromClass: String,
	enterActiveClass: String,
	enterToClass: String,
	appearFromClass: String,
	appearActiveClass: String,
	appearToClass: String,
	leaveFromClass: String,
	leaveActiveClass: String,
	leaveToClass: String
};
xa.props = Pt({}, $m.props, wf);
const Fi = (r, e = []) => {
		ze(r) ? r.forEach((t) => t(...e)) : r && r(...e);
	},
	$h = (r) => (r ? (ze(r) ? r.some((e) => e.length > 1) : r.length > 1) : !1);
function Gy(r) {
	const e = {};
	for (const E in r) E in wf || (e[E] = r[E]);
	if (r.css === !1) return e;
	const {
			name: t = 'v',
			type: i,
			duration: n,
			enterFromClass: a = `${t}-enter-from`,
			enterActiveClass: s = `${t}-enter-active`,
			enterToClass: o = `${t}-enter-to`,
			appearFromClass: l = a,
			appearActiveClass: c = s,
			appearToClass: u = o,
			leaveFromClass: h = `${t}-leave-from`,
			leaveActiveClass: d = `${t}-leave-active`,
			leaveToClass: p = `${t}-leave-to`
		} = r,
		g = Vy(n),
		m = g && g[0],
		f = g && g[1],
		{
			onBeforeEnter: v,
			onEnter: x,
			onEnterCancelled: A,
			onLeave: S,
			onLeaveCancelled: M,
			onBeforeAppear: I = v,
			onAppear: D = x,
			onAppearCancelled: G = A
		} = e,
		re = (E, j, z) => {
			Hi(E, j ? u : o), Hi(E, j ? c : s), z && z();
		},
		B = (E, j) => {
			(E._isLeaving = !1), Hi(E, h), Hi(E, p), Hi(E, d), j && j();
		},
		b = (E) => (j, z) => {
			const V = E ? D : x,
				H = () => re(j, E, z);
			Fi(V, [j, H]),
			Kh(() => {
				Hi(j, E ? l : a), si(j, E ? u : o), $h(V) || Jh(j, i, m, H);
			});
		};
	return Pt(e, {
		onBeforeEnter(E) {
			Fi(v, [E]), si(E, a), si(E, s);
		},
		onBeforeAppear(E) {
			Fi(I, [E]), si(E, l), si(E, c);
		},
		onEnter: b(!1),
		onAppear: b(!0),
		onLeave(E, j) {
			E._isLeaving = !0;
			const z = () => B(E, j);
			si(E, h),
			Xy(),
			si(E, d),
			Kh(() => {
				!E._isLeaving ||
                        (Hi(E, h), si(E, p), $h(S) || Jh(E, i, f, z));
			}),
			Fi(S, [E, z]);
		},
		onEnterCancelled(E) {
			re(E, !1), Fi(A, [E]);
		},
		onAppearCancelled(E) {
			re(E, !0), Fi(G, [E]);
		},
		onLeaveCancelled(E) {
			B(E), Fi(M, [E]);
		}
	});
}
function Vy(r) {
	if (r == null) return null;
	if (bt(r)) return [Tl(r.enter), Tl(r.leave)];
	{
		const e = Tl(r);
		return [e, e];
	}
}
function Tl(r) {
	return ko(r);
}
function si(r, e) {
	e.split(/\s+/).forEach((t) => t && r.classList.add(t)),
	(r._vtc || (r._vtc = new Set())).add(e);
}
function Hi(r, e) {
	e.split(/\s+/).forEach((i) => i && r.classList.remove(i));
	const { _vtc: t } = r;
	t && (t.delete(e), t.size || (r._vtc = void 0));
}
function Kh(r) {
	requestAnimationFrame(() => {
		requestAnimationFrame(r);
	});
}
let Wy = 0;
function Jh(r, e, t, i) {
	const n = (r._endId = ++Wy),
		a = () => {
			n === r._endId && i();
		};
	if (t) return setTimeout(a, t);
	const { type: s, timeout: o, propCount: l } = jy(r, e);
	if (!s) return i();
	const c = s + 'end';
	let u = 0;
	const h = () => {
			r.removeEventListener(c, d), a();
		},
		d = (p) => {
			p.target === r && ++u >= l && h();
		};
	setTimeout(() => {
		u < l && h();
	}, o + 1),
	r.addEventListener(c, d);
}
function jy(r, e) {
	const t = window.getComputedStyle(r),
		i = (g) => (t[g] || '').split(', '),
		n = i(ai + 'Delay'),
		a = i(ai + 'Duration'),
		s = Qh(n, a),
		o = i(Pa + 'Delay'),
		l = i(Pa + 'Duration'),
		c = Qh(o, l);
	let u = null,
		h = 0,
		d = 0;
	e === ai
		? s > 0 && ((u = ai), (h = s), (d = a.length))
		: e === Pa
			? c > 0 && ((u = Pa), (h = c), (d = l.length))
			: ((h = Math.max(s, c)),
			(u = h > 0 ? (s > c ? ai : Pa) : null),
			(d = u ? (u === ai ? a.length : l.length) : 0));
	const p = u === ai && /\b(transform|all)(,|$)/.test(t[ai + 'Property']);
	return { type: u, timeout: h, propCount: d, hasTransform: p };
}
function Qh(r, e) {
	for (; r.length < e.length; ) r = r.concat(r);
	return Math.max(...e.map((t, i) => ed(t) + ed(r[i])));
}
function ed(r) {
	return Number(r.slice(0, -1).replace(',', '.')) * 1e3;
}
function Xy() {
	return document.body.offsetHeight;
}
const td = (r) => {
	const e = r.props['onUpdate:modelValue'] || !1;
	return ze(e) ? (t) => wo(e, t) : e;
};
function qy(r) {
	r.target.composing = !0;
}
function rd(r) {
	const e = r.target;
	e.composing && ((e.composing = !1), e.dispatchEvent(new Event('input')));
}
const Us = {
		created(r, { modifiers: { lazy: e, trim: t, number: i } }, n) {
			r._assign = td(n);
			const a = i || (n.props && n.props.type === 'number');
			Vn(r, e ? 'change' : 'input', (s) => {
				if (s.target.composing) return;
				let o = r.value;
				t && (o = o.trim()), a && (o = ko(o)), r._assign(o);
			}),
			t &&
                    Vn(r, 'change', () => {
                    	r.value = r.value.trim();
                    }),
			e ||
                    (Vn(r, 'compositionstart', qy),
                    Vn(r, 'compositionend', rd),
                    Vn(r, 'change', rd));
		},
		mounted(r, { value: e }) {
			r.value = e == null ? '' : e;
		},
		beforeUpdate(
			r,
			{ value: e, modifiers: { lazy: t, trim: i, number: n } },
			a
		) {
			if (
				((r._assign = td(a)),
				r.composing ||
                    (document.activeElement === r &&
                        r.type !== 'range' &&
                        (t ||
                            (i && r.value.trim() === e) ||
                            ((n || r.type === 'number') && ko(r.value) === e))))
			)
				return;
			const s = e == null ? '' : e;
			r.value !== s && (r.value = s);
		}
	},
	Yy = ['ctrl', 'shift', 'alt', 'meta'],
	Zy = {
		stop: (r) => r.stopPropagation(),
		prevent: (r) => r.preventDefault(),
		self: (r) => r.target !== r.currentTarget,
		ctrl: (r) => !r.ctrlKey,
		shift: (r) => !r.shiftKey,
		alt: (r) => !r.altKey,
		meta: (r) => !r.metaKey,
		left: (r) => 'button' in r && r.button !== 0,
		middle: (r) => 'button' in r && r.button !== 1,
		right: (r) => 'button' in r && r.button !== 2,
		exact: (r, e) => Yy.some((t) => r[`${t}Key`] && !e.includes(t))
	},
	Lu =
        (r, e) =>
        	(t, ...i) => {
        		for (let n = 0; n < e.length; n++) {
        			const a = Zy[e[n]];
        			if (a && a(t, e)) return;
        		}
        		return r(t, ...i);
        	},
	ps = {
		beforeMount(r, { value: e }, { transition: t }) {
			(r._vod = r.style.display === 'none' ? '' : r.style.display),
			t && e ? t.beforeEnter(r) : Ia(r, e);
		},
		mounted(r, { value: e }, { transition: t }) {
			t && e && t.enter(r);
		},
		updated(r, { value: e, oldValue: t }, { transition: i }) {
			!e != !t &&
                (i
                	? e
                		? (i.beforeEnter(r), Ia(r, !0), i.enter(r))
                		: i.leave(r, () => {
                			Ia(r, !1);
                		})
                	: Ia(r, e));
		},
		beforeUnmount(r, { value: e }) {
			Ia(r, e);
		}
	};
function Ia(r, e) {
	r.style.display = e ? r._vod : 'none';
}
const $y = Pt({ patchProp: Fy }, Ty);
let id;
function Ky() {
	return id || (id = ny($y));
}
const Jy = (...r) => {
	const e = Ky().createApp(...r),
		{ mount: t } = e;
	return (
		(e.mount = (i) => {
			const n = Qy(i);
			if (!n) return;
			const a = e._component;
			!He(a) && !a.render && !a.template && (a.template = n.innerHTML),
			(n.innerHTML = '');
			const s = t(n, !1, n instanceof SVGElement);
			return (
				n instanceof Element &&
                    (n.removeAttribute('v-cloak'),
                    n.setAttribute('data-v-app', '')),
				s
			);
		}),
		e
	);
};
function Qy(r) {
	return xt(r) ? document.querySelector(r) : r;
}
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const Ru = '139',
	yn = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
	xn = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
	ex = 0,
	nd = 1,
	tx = 2,
	_f = 1,
	Mf = 2,
	qa = 3,
	na = 0,
	rr = 1,
	an = 2,
	Sf = 1,
	Ei = 0,
	ea = 1,
	ad = 2,
	sd = 3,
	od = 4,
	rx = 5,
	Wn = 100,
	ix = 101,
	nx = 102,
	ld = 103,
	cd = 104,
	ax = 200,
	sx = 201,
	ox = 202,
	lx = 203,
	Tf = 204,
	Ef = 205,
	cx = 206,
	ux = 207,
	hx = 208,
	dx = 209,
	px = 210,
	mx = 0,
	fx = 1,
	gx = 2,
	Uc = 3,
	vx = 4,
	yx = 5,
	xx = 6,
	bx = 7,
	tl = 0,
	wx = 1,
	_x = 2,
	$r = 0,
	Mx = 1,
	Sx = 2,
	Tx = 3,
	Ex = 4,
	Ax = 5,
	Af = 300,
	aa = 301,
	sa = 302,
	Bc = 303,
	Fc = 304,
	rl = 306,
	oa = 1e3,
	Kt = 1001,
	Oo = 1002,
	Mt = 1003,
	Hc = 1004,
	Gc = 1005,
	Nt = 1006,
	Lf = 1007,
	ba = 1008,
	sn = 1009,
	Lx = 1010,
	Rx = 1011,
	ms = 1012,
	kx = 1013,
	Eo = 1014,
	wi = 1015,
	ta = 1016,
	Cx = 1017,
	Px = 1018,
	ra = 1020,
	Ix = 1021,
	Dx = 1022,
	Qt = 1023,
	Ox = 1024,
	Nx = 1025,
	rn = 1026,
	la = 1027,
	zx = 1028,
	Ux = 1029,
	Bx = 1030,
	Fx = 1031,
	Hx = 1033,
	El = 33776,
	Al = 33777,
	Ll = 33778,
	Rl = 33779,
	ud = 35840,
	hd = 35841,
	dd = 35842,
	pd = 35843,
	Gx = 36196,
	md = 37492,
	fd = 37496,
	gd = 37808,
	vd = 37809,
	yd = 37810,
	xd = 37811,
	bd = 37812,
	wd = 37813,
	_d = 37814,
	Md = 37815,
	Sd = 37816,
	Td = 37817,
	Ed = 37818,
	Ad = 37819,
	Ld = 37820,
	Rd = 37821,
	kd = 36492,
	Vx = 2200,
	Wx = 2201,
	jx = 2202,
	fs = 2300,
	ca = 2301,
	kl = 2302,
	Xn = 2400,
	qn = 2401,
	No = 2402,
	ku = 2500,
	Rf = 2501,
	Xx = 0,
	qx = 1,
	kf = 2,
	Qr = 3e3,
	Ze = 3001,
	Yx = 3200,
	Zx = 3201,
	un = 0,
	$x = 1,
	jr = 'srgb',
	Ji = 'srgb-linear',
	Cl = 7680,
	Kx = 519,
	gs = 35044,
	zo = 35048,
	Cd = '300 es',
	Vc = 1035;
class Di {
	addEventListener(e, t) {
		this._listeners === void 0 && (this._listeners = {});
		const i = this._listeners;
		i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
	}
	hasEventListener(e, t) {
		if (this._listeners === void 0) return !1;
		const i = this._listeners;
		return i[e] !== void 0 && i[e].indexOf(t) !== -1;
	}
	removeEventListener(e, t) {
		if (this._listeners === void 0) return;
		const i = this._listeners[e];
		if (i !== void 0) {
			const n = i.indexOf(t);
			n !== -1 && i.splice(n, 1);
		}
	}
	dispatchEvent(e) {
		if (this._listeners === void 0) return;
		const t = this._listeners[e.type];
		if (t !== void 0) {
			e.target = this;
			const i = t.slice(0);
			for (let n = 0, a = i.length; n < a; n++) i[n].call(this, e);
			e.target = null;
		}
	}
}
const Lt = [];
for (let r = 0; r < 256; r++) Lt[r] = (r < 16 ? '0' : '') + r.toString(16);
let Pd = 1234567;
const es = Math.PI / 180,
	vs = 180 / Math.PI;
function ir() {
	const r = (Math.random() * 4294967295) | 0,
		e = (Math.random() * 4294967295) | 0,
		t = (Math.random() * 4294967295) | 0,
		i = (Math.random() * 4294967295) | 0;
	return (
		Lt[r & 255] +
        Lt[(r >> 8) & 255] +
        Lt[(r >> 16) & 255] +
        Lt[(r >> 24) & 255] +
        '-' +
        Lt[e & 255] +
        Lt[(e >> 8) & 255] +
        '-' +
        Lt[((e >> 16) & 15) | 64] +
        Lt[(e >> 24) & 255] +
        '-' +
        Lt[(t & 63) | 128] +
        Lt[(t >> 8) & 255] +
        '-' +
        Lt[(t >> 16) & 255] +
        Lt[(t >> 24) & 255] +
        Lt[i & 255] +
        Lt[(i >> 8) & 255] +
        Lt[(i >> 16) & 255] +
        Lt[(i >> 24) & 255]
	).toLowerCase();
}
function Et(r, e, t) {
	return Math.max(e, Math.min(t, r));
}
function Cu(r, e) {
	return ((r % e) + e) % e;
}
function Jx(r, e, t, i, n) {
	return i + ((r - e) * (n - i)) / (t - e);
}
function Qx(r, e, t) {
	return r !== e ? (t - r) / (e - r) : 0;
}
function ts(r, e, t) {
	return (1 - t) * r + t * e;
}
function eb(r, e, t, i) {
	return ts(r, e, 1 - Math.exp(-t * i));
}
function tb(r, e = 1) {
	return e - Math.abs(Cu(r, e * 2) - e);
}
function rb(r, e, t) {
	return r <= e
		? 0
		: r >= t
			? 1
			: ((r = (r - e) / (t - e)), r * r * (3 - 2 * r));
}
function ib(r, e, t) {
	return r <= e
		? 0
		: r >= t
			? 1
			: ((r = (r - e) / (t - e)), r * r * r * (r * (r * 6 - 15) + 10));
}
function nb(r, e) {
	return r + Math.floor(Math.random() * (e - r + 1));
}
function ab(r, e) {
	return r + Math.random() * (e - r);
}
function sb(r) {
	return r * (0.5 - Math.random());
}
function ob(r) {
	r !== void 0 && (Pd = r);
	let e = (Pd += 1831565813);
	return (
		(e = Math.imul(e ^ (e >>> 15), e | 1)),
		(e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
		((e ^ (e >>> 14)) >>> 0) / 4294967296
	);
}
function lb(r) {
	return r * es;
}
function cb(r) {
	return r * vs;
}
function Wc(r) {
	return (r & (r - 1)) === 0 && r !== 0;
}
function Cf(r) {
	return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
}
function Uo(r) {
	return Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
}
function ub(r, e, t, i, n) {
	const a = Math.cos,
		s = Math.sin,
		o = a(t / 2),
		l = s(t / 2),
		c = a((e + i) / 2),
		u = s((e + i) / 2),
		h = a((e - i) / 2),
		d = s((e - i) / 2),
		p = a((i - e) / 2),
		g = s((i - e) / 2);
	switch (n) {
	case 'XYX':
		r.set(o * u, l * h, l * d, o * c);
		break;
	case 'YZY':
		r.set(l * d, o * u, l * h, o * c);
		break;
	case 'ZXZ':
		r.set(l * h, l * d, o * u, o * c);
		break;
	case 'XZX':
		r.set(o * u, l * g, l * p, o * c);
		break;
	case 'YXY':
		r.set(l * p, o * u, l * g, o * c);
		break;
	case 'ZYZ':
		r.set(l * g, l * p, o * u, o * c);
		break;
	default:
		console.warn(
			'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' +
                    n
		);
	}
}
function hb(r, e) {
	switch (e.constructor) {
	case Float32Array:
		return r;
	case Uint16Array:
		return r / 65535;
	case Uint8Array:
		return r / 255;
	case Int16Array:
		return Math.max(r / 32767, -1);
	case Int8Array:
		return Math.max(r / 127, -1);
	default:
		throw new Error('Invalid component type.');
	}
}
function db(r, e) {
	switch (e.constructor) {
	case Float32Array:
		return r;
	case Uint16Array:
		return Math.round(r * 65535);
	case Uint8Array:
		return Math.round(r * 255);
	case Int16Array:
		return Math.round(r * 32767);
	case Int8Array:
		return Math.round(r * 127);
	default:
		throw new Error('Invalid component type.');
	}
}
var pb = Object.freeze({
	__proto__: null,
	DEG2RAD: es,
	RAD2DEG: vs,
	generateUUID: ir,
	clamp: Et,
	euclideanModulo: Cu,
	mapLinear: Jx,
	inverseLerp: Qx,
	lerp: ts,
	damp: eb,
	pingpong: tb,
	smoothstep: rb,
	smootherstep: ib,
	randInt: nb,
	randFloat: ab,
	randFloatSpread: sb,
	seededRandom: ob,
	degToRad: lb,
	radToDeg: cb,
	isPowerOfTwo: Wc,
	ceilPowerOfTwo: Cf,
	floorPowerOfTwo: Uo,
	setQuaternionFromProperEuler: ub,
	normalize: db,
	denormalize: hb
});
class me {
	constructor(e = 0, t = 0) {
		(this.x = e), (this.y = t);
	}
	get width() {
		return this.x;
	}
	set width(e) {
		this.x = e;
	}
	get height() {
		return this.y;
	}
	set height(e) {
		this.y = e;
	}
	set(e, t) {
		return (this.x = e), (this.y = t), this;
	}
	setScalar(e) {
		return (this.x = e), (this.y = e), this;
	}
	setX(e) {
		return (this.x = e), this;
	}
	setY(e) {
		return (this.y = e), this;
	}
	setComponent(e, t) {
		switch (e) {
		case 0:
			this.x = t;
			break;
		case 1:
			this.y = t;
			break;
		default:
			throw new Error('index is out of range: ' + e);
		}
		return this;
	}
	getComponent(e) {
		switch (e) {
		case 0:
			return this.x;
		case 1:
			return this.y;
		default:
			throw new Error('index is out of range: ' + e);
		}
	}
	clone() {
		return new this.constructor(this.x, this.y);
	}
	copy(e) {
		return (this.x = e.x), (this.y = e.y), this;
	}
	add(e, t) {
		return t !== void 0
			? (console.warn(
				'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.'
			),
			this.addVectors(e, t))
			: ((this.x += e.x), (this.y += e.y), this);
	}
	addScalar(e) {
		return (this.x += e), (this.y += e), this;
	}
	addVectors(e, t) {
		return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
	}
	addScaledVector(e, t) {
		return (this.x += e.x * t), (this.y += e.y * t), this;
	}
	sub(e, t) {
		return t !== void 0
			? (console.warn(
				'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'
			),
			this.subVectors(e, t))
			: ((this.x -= e.x), (this.y -= e.y), this);
	}
	subScalar(e) {
		return (this.x -= e), (this.y -= e), this;
	}
	subVectors(e, t) {
		return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
	}
	multiply(e) {
		return (this.x *= e.x), (this.y *= e.y), this;
	}
	multiplyScalar(e) {
		return (this.x *= e), (this.y *= e), this;
	}
	divide(e) {
		return (this.x /= e.x), (this.y /= e.y), this;
	}
	divideScalar(e) {
		return this.multiplyScalar(1 / e);
	}
	applyMatrix3(e) {
		const t = this.x,
			i = this.y,
			n = e.elements;
		return (
			(this.x = n[0] * t + n[3] * i + n[6]),
			(this.y = n[1] * t + n[4] * i + n[7]),
			this
		);
	}
	min(e) {
		return (
			(this.x = Math.min(this.x, e.x)),
			(this.y = Math.min(this.y, e.y)),
			this
		);
	}
	max(e) {
		return (
			(this.x = Math.max(this.x, e.x)),
			(this.y = Math.max(this.y, e.y)),
			this
		);
	}
	clamp(e, t) {
		return (
			(this.x = Math.max(e.x, Math.min(t.x, this.x))),
			(this.y = Math.max(e.y, Math.min(t.y, this.y))),
			this
		);
	}
	clampScalar(e, t) {
		return (
			(this.x = Math.max(e, Math.min(t, this.x))),
			(this.y = Math.max(e, Math.min(t, this.y))),
			this
		);
	}
	clampLength(e, t) {
		const i = this.length();
		return this.divideScalar(i || 1).multiplyScalar(
			Math.max(e, Math.min(t, i))
		);
	}
	floor() {
		return (
			(this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
		);
	}
	ceil() {
		return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
	}
	round() {
		return (
			(this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
		);
	}
	roundToZero() {
		return (
			(this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
			(this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
			this
		);
	}
	negate() {
		return (this.x = -this.x), (this.y = -this.y), this;
	}
	dot(e) {
		return this.x * e.x + this.y * e.y;
	}
	cross(e) {
		return this.x * e.y - this.y * e.x;
	}
	lengthSq() {
		return this.x * this.x + this.y * this.y;
	}
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	}
	manhattanLength() {
		return Math.abs(this.x) + Math.abs(this.y);
	}
	normalize() {
		return this.divideScalar(this.length() || 1);
	}
	angle() {
		return Math.atan2(-this.y, -this.x) + Math.PI;
	}
	distanceTo(e) {
		return Math.sqrt(this.distanceToSquared(e));
	}
	distanceToSquared(e) {
		const t = this.x - e.x,
			i = this.y - e.y;
		return t * t + i * i;
	}
	manhattanDistanceTo(e) {
		return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
	}
	setLength(e) {
		return this.normalize().multiplyScalar(e);
	}
	lerp(e, t) {
		return (
			(this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this
		);
	}
	lerpVectors(e, t, i) {
		return (
			(this.x = e.x + (t.x - e.x) * i),
			(this.y = e.y + (t.y - e.y) * i),
			this
		);
	}
	equals(e) {
		return e.x === this.x && e.y === this.y;
	}
	fromArray(e, t = 0) {
		return (this.x = e[t]), (this.y = e[t + 1]), this;
	}
	toArray(e = [], t = 0) {
		return (e[t] = this.x), (e[t + 1] = this.y), e;
	}
	fromBufferAttribute(e, t, i) {
		return (
			i !== void 0 &&
                console.warn(
                	'THREE.Vector2: offset has been removed from .fromBufferAttribute().'
                ),
			(this.x = e.getX(t)),
			(this.y = e.getY(t)),
			this
		);
	}
	rotateAround(e, t) {
		const i = Math.cos(t),
			n = Math.sin(t),
			a = this.x - e.x,
			s = this.y - e.y;
		return (
			(this.x = a * i - s * n + e.x), (this.y = a * n + s * i + e.y), this
		);
	}
	random() {
		return (this.x = Math.random()), (this.y = Math.random()), this;
	}
	*[Symbol.iterator]() {
		yield this.x, yield this.y;
	}
}
me.prototype.isVector2 = !0;
class kt {
	constructor() {
		(this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
		arguments.length > 0 &&
                console.error(
                	'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.'
                );
	}
	set(e, t, i, n, a, s, o, l, c) {
		const u = this.elements;
		return (
			(u[0] = e),
			(u[1] = n),
			(u[2] = o),
			(u[3] = t),
			(u[4] = a),
			(u[5] = l),
			(u[6] = i),
			(u[7] = s),
			(u[8] = c),
			this
		);
	}
	identity() {
		return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
	}
	copy(e) {
		const t = this.elements,
			i = e.elements;
		return (
			(t[0] = i[0]),
			(t[1] = i[1]),
			(t[2] = i[2]),
			(t[3] = i[3]),
			(t[4] = i[4]),
			(t[5] = i[5]),
			(t[6] = i[6]),
			(t[7] = i[7]),
			(t[8] = i[8]),
			this
		);
	}
	extractBasis(e, t, i) {
		return (
			e.setFromMatrix3Column(this, 0),
			t.setFromMatrix3Column(this, 1),
			i.setFromMatrix3Column(this, 2),
			this
		);
	}
	setFromMatrix4(e) {
		const t = e.elements;
		return (
			this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
			this
		);
	}
	multiply(e) {
		return this.multiplyMatrices(this, e);
	}
	premultiply(e) {
		return this.multiplyMatrices(e, this);
	}
	multiplyMatrices(e, t) {
		const i = e.elements,
			n = t.elements,
			a = this.elements,
			s = i[0],
			o = i[3],
			l = i[6],
			c = i[1],
			u = i[4],
			h = i[7],
			d = i[2],
			p = i[5],
			g = i[8],
			m = n[0],
			f = n[3],
			v = n[6],
			x = n[1],
			A = n[4],
			S = n[7],
			M = n[2],
			I = n[5],
			D = n[8];
		return (
			(a[0] = s * m + o * x + l * M),
			(a[3] = s * f + o * A + l * I),
			(a[6] = s * v + o * S + l * D),
			(a[1] = c * m + u * x + h * M),
			(a[4] = c * f + u * A + h * I),
			(a[7] = c * v + u * S + h * D),
			(a[2] = d * m + p * x + g * M),
			(a[5] = d * f + p * A + g * I),
			(a[8] = d * v + p * S + g * D),
			this
		);
	}
	multiplyScalar(e) {
		const t = this.elements;
		return (
			(t[0] *= e),
			(t[3] *= e),
			(t[6] *= e),
			(t[1] *= e),
			(t[4] *= e),
			(t[7] *= e),
			(t[2] *= e),
			(t[5] *= e),
			(t[8] *= e),
			this
		);
	}
	determinant() {
		const e = this.elements,
			t = e[0],
			i = e[1],
			n = e[2],
			a = e[3],
			s = e[4],
			o = e[5],
			l = e[6],
			c = e[7],
			u = e[8];
		return (
			t * s * u -
            t * o * c -
            i * a * u +
            i * o * l +
            n * a * c -
            n * s * l
		);
	}
	invert() {
		const e = this.elements,
			t = e[0],
			i = e[1],
			n = e[2],
			a = e[3],
			s = e[4],
			o = e[5],
			l = e[6],
			c = e[7],
			u = e[8],
			h = u * s - o * c,
			d = o * l - u * a,
			p = c * a - s * l,
			g = t * h + i * d + n * p;
		if (g === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
		const m = 1 / g;
		return (
			(e[0] = h * m),
			(e[1] = (n * c - u * i) * m),
			(e[2] = (o * i - n * s) * m),
			(e[3] = d * m),
			(e[4] = (u * t - n * l) * m),
			(e[5] = (n * a - o * t) * m),
			(e[6] = p * m),
			(e[7] = (i * l - c * t) * m),
			(e[8] = (s * t - i * a) * m),
			this
		);
	}
	transpose() {
		let e;
		const t = this.elements;
		return (
			(e = t[1]),
			(t[1] = t[3]),
			(t[3] = e),
			(e = t[2]),
			(t[2] = t[6]),
			(t[6] = e),
			(e = t[5]),
			(t[5] = t[7]),
			(t[7] = e),
			this
		);
	}
	getNormalMatrix(e) {
		return this.setFromMatrix4(e).invert().transpose();
	}
	transposeIntoArray(e) {
		const t = this.elements;
		return (
			(e[0] = t[0]),
			(e[1] = t[3]),
			(e[2] = t[6]),
			(e[3] = t[1]),
			(e[4] = t[4]),
			(e[5] = t[7]),
			(e[6] = t[2]),
			(e[7] = t[5]),
			(e[8] = t[8]),
			this
		);
	}
	setUvTransform(e, t, i, n, a, s, o) {
		const l = Math.cos(a),
			c = Math.sin(a);
		return (
			this.set(
				i * l,
				i * c,
				-i * (l * s + c * o) + s + e,
				-n * c,
				n * l,
				-n * (-c * s + l * o) + o + t,
				0,
				0,
				1
			),
			this
		);
	}
	scale(e, t) {
		const i = this.elements;
		return (
			(i[0] *= e),
			(i[3] *= e),
			(i[6] *= e),
			(i[1] *= t),
			(i[4] *= t),
			(i[7] *= t),
			this
		);
	}
	rotate(e) {
		const t = Math.cos(e),
			i = Math.sin(e),
			n = this.elements,
			a = n[0],
			s = n[3],
			o = n[6],
			l = n[1],
			c = n[4],
			u = n[7];
		return (
			(n[0] = t * a + i * l),
			(n[3] = t * s + i * c),
			(n[6] = t * o + i * u),
			(n[1] = -i * a + t * l),
			(n[4] = -i * s + t * c),
			(n[7] = -i * o + t * u),
			this
		);
	}
	translate(e, t) {
		const i = this.elements;
		return (
			(i[0] += e * i[2]),
			(i[3] += e * i[5]),
			(i[6] += e * i[8]),
			(i[1] += t * i[2]),
			(i[4] += t * i[5]),
			(i[7] += t * i[8]),
			this
		);
	}
	equals(e) {
		const t = this.elements,
			i = e.elements;
		for (let n = 0; n < 9; n++) if (t[n] !== i[n]) return !1;
		return !0;
	}
	fromArray(e, t = 0) {
		for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
		return this;
	}
	toArray(e = [], t = 0) {
		const i = this.elements;
		return (
			(e[t] = i[0]),
			(e[t + 1] = i[1]),
			(e[t + 2] = i[2]),
			(e[t + 3] = i[3]),
			(e[t + 4] = i[4]),
			(e[t + 5] = i[5]),
			(e[t + 6] = i[6]),
			(e[t + 7] = i[7]),
			(e[t + 8] = i[8]),
			e
		);
	}
	clone() {
		return new this.constructor().fromArray(this.elements);
	}
}
kt.prototype.isMatrix3 = !0;
function Pf(r) {
	for (let e = r.length - 1; e >= 0; --e) if (r[e] > 65535) return !0;
	return !1;
}
function ys(r) {
	return document.createElementNS('http://www.w3.org/1999/xhtml', r);
}
function nn(r) {
	return r < 0.04045
		? r * 0.0773993808
		: Math.pow(r * 0.9478672986 + 0.0521327014, 2.4);
}
function Ao(r) {
	return r < 0.0031308 ? r * 12.92 : 1.055 * Math.pow(r, 0.41666) - 0.055;
}
const Pl = { [jr]: { [Ji]: nn }, [Ji]: { [jr]: Ao } },
	cr = {
		legacyMode: !0,
		get workingColorSpace() {
			return Ji;
		},
		set workingColorSpace(r) {
			console.warn(
				'THREE.ColorManagement: .workingColorSpace is readonly.'
			);
		},
		convert: function (r, e, t) {
			if (this.legacyMode || e === t || !e || !t) return r;
			if (Pl[e] && Pl[e][t] !== void 0) {
				const i = Pl[e][t];
				return (r.r = i(r.r)), (r.g = i(r.g)), (r.b = i(r.b)), r;
			}
			throw new Error('Unsupported color space conversion.');
		},
		fromWorkingColorSpace: function (r, e) {
			return this.convert(r, this.workingColorSpace, e);
		},
		toWorkingColorSpace: function (r, e) {
			return this.convert(r, e, this.workingColorSpace);
		}
	},
	If = {
		aliceblue: 15792383,
		antiquewhite: 16444375,
		aqua: 65535,
		aquamarine: 8388564,
		azure: 15794175,
		beige: 16119260,
		bisque: 16770244,
		black: 0,
		blanchedalmond: 16772045,
		blue: 255,
		blueviolet: 9055202,
		brown: 10824234,
		burlywood: 14596231,
		cadetblue: 6266528,
		chartreuse: 8388352,
		chocolate: 13789470,
		coral: 16744272,
		cornflowerblue: 6591981,
		cornsilk: 16775388,
		crimson: 14423100,
		cyan: 65535,
		darkblue: 139,
		darkcyan: 35723,
		darkgoldenrod: 12092939,
		darkgray: 11119017,
		darkgreen: 25600,
		darkgrey: 11119017,
		darkkhaki: 12433259,
		darkmagenta: 9109643,
		darkolivegreen: 5597999,
		darkorange: 16747520,
		darkorchid: 10040012,
		darkred: 9109504,
		darksalmon: 15308410,
		darkseagreen: 9419919,
		darkslateblue: 4734347,
		darkslategray: 3100495,
		darkslategrey: 3100495,
		darkturquoise: 52945,
		darkviolet: 9699539,
		deeppink: 16716947,
		deepskyblue: 49151,
		dimgray: 6908265,
		dimgrey: 6908265,
		dodgerblue: 2003199,
		firebrick: 11674146,
		floralwhite: 16775920,
		forestgreen: 2263842,
		fuchsia: 16711935,
		gainsboro: 14474460,
		ghostwhite: 16316671,
		gold: 16766720,
		goldenrod: 14329120,
		gray: 8421504,
		green: 32768,
		greenyellow: 11403055,
		grey: 8421504,
		honeydew: 15794160,
		hotpink: 16738740,
		indianred: 13458524,
		indigo: 4915330,
		ivory: 16777200,
		khaki: 15787660,
		lavender: 15132410,
		lavenderblush: 16773365,
		lawngreen: 8190976,
		lemonchiffon: 16775885,
		lightblue: 11393254,
		lightcoral: 15761536,
		lightcyan: 14745599,
		lightgoldenrodyellow: 16448210,
		lightgray: 13882323,
		lightgreen: 9498256,
		lightgrey: 13882323,
		lightpink: 16758465,
		lightsalmon: 16752762,
		lightseagreen: 2142890,
		lightskyblue: 8900346,
		lightslategray: 7833753,
		lightslategrey: 7833753,
		lightsteelblue: 11584734,
		lightyellow: 16777184,
		lime: 65280,
		limegreen: 3329330,
		linen: 16445670,
		magenta: 16711935,
		maroon: 8388608,
		mediumaquamarine: 6737322,
		mediumblue: 205,
		mediumorchid: 12211667,
		mediumpurple: 9662683,
		mediumseagreen: 3978097,
		mediumslateblue: 8087790,
		mediumspringgreen: 64154,
		mediumturquoise: 4772300,
		mediumvioletred: 13047173,
		midnightblue: 1644912,
		mintcream: 16121850,
		mistyrose: 16770273,
		moccasin: 16770229,
		navajowhite: 16768685,
		navy: 128,
		oldlace: 16643558,
		olive: 8421376,
		olivedrab: 7048739,
		orange: 16753920,
		orangered: 16729344,
		orchid: 14315734,
		palegoldenrod: 15657130,
		palegreen: 10025880,
		paleturquoise: 11529966,
		palevioletred: 14381203,
		papayawhip: 16773077,
		peachpuff: 16767673,
		peru: 13468991,
		pink: 16761035,
		plum: 14524637,
		powderblue: 11591910,
		purple: 8388736,
		rebeccapurple: 6697881,
		red: 16711680,
		rosybrown: 12357519,
		royalblue: 4286945,
		saddlebrown: 9127187,
		salmon: 16416882,
		sandybrown: 16032864,
		seagreen: 3050327,
		seashell: 16774638,
		sienna: 10506797,
		silver: 12632256,
		skyblue: 8900331,
		slateblue: 6970061,
		slategray: 7372944,
		slategrey: 7372944,
		snow: 16775930,
		springgreen: 65407,
		steelblue: 4620980,
		tan: 13808780,
		teal: 32896,
		thistle: 14204888,
		tomato: 16737095,
		turquoise: 4251856,
		violet: 15631086,
		wheat: 16113331,
		white: 16777215,
		whitesmoke: 16119285,
		yellow: 16776960,
		yellowgreen: 10145074
	},
	_t = { r: 0, g: 0, b: 0 },
	ur = { h: 0, s: 0, l: 0 },
	Bs = { h: 0, s: 0, l: 0 };
function Il(r, e, t) {
	return (
		t < 0 && (t += 1),
		t > 1 && (t -= 1),
		t < 1 / 6
			? r + (e - r) * 6 * t
			: t < 1 / 2
				? e
				: t < 2 / 3
					? r + (e - r) * 6 * (2 / 3 - t)
					: r
	);
}
function Fs(r, e) {
	return (e.r = r.r), (e.g = r.g), (e.b = r.b), e;
}
class ke {
	constructor(e, t, i) {
		return t === void 0 && i === void 0
			? this.set(e)
			: this.setRGB(e, t, i);
	}
	set(e) {
		return (
			e && e.isColor
				? this.copy(e)
				: typeof e == 'number'
					? this.setHex(e)
					: typeof e == 'string' && this.setStyle(e),
			this
		);
	}
	setScalar(e) {
		return (this.r = e), (this.g = e), (this.b = e), this;
	}
	setHex(e, t = jr) {
		return (
			(e = Math.floor(e)),
			(this.r = ((e >> 16) & 255) / 255),
			(this.g = ((e >> 8) & 255) / 255),
			(this.b = (e & 255) / 255),
			cr.toWorkingColorSpace(this, t),
			this
		);
	}
	setRGB(e, t, i, n = Ji) {
		return (
			(this.r = e),
			(this.g = t),
			(this.b = i),
			cr.toWorkingColorSpace(this, n),
			this
		);
	}
	setHSL(e, t, i, n = Ji) {
		if (((e = Cu(e, 1)), (t = Et(t, 0, 1)), (i = Et(i, 0, 1)), t === 0))
			this.r = this.g = this.b = i;
		else {
			const a = i <= 0.5 ? i * (1 + t) : i + t - i * t,
				s = 2 * i - a;
			(this.r = Il(s, a, e + 1 / 3)),
			(this.g = Il(s, a, e)),
			(this.b = Il(s, a, e - 1 / 3));
		}
		return cr.toWorkingColorSpace(this, n), this;
	}
	setStyle(e, t = jr) {
		function i(a) {
			a !== void 0 &&
                parseFloat(a) < 1 &&
                console.warn(
                	'THREE.Color: Alpha component of ' + e + ' will be ignored.'
                );
		}
		let n;
		if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e))) {
			let a;
			const s = n[1],
				o = n[2];
			switch (s) {
			case 'rgb':
			case 'rgba':
				if (
					(a =
                            /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                            	o
                            ))
				)
					return (
						(this.r = Math.min(255, parseInt(a[1], 10)) / 255),
						(this.g = Math.min(255, parseInt(a[2], 10)) / 255),
						(this.b = Math.min(255, parseInt(a[3], 10)) / 255),
						cr.toWorkingColorSpace(this, t),
						i(a[4]),
						this
					);
				if (
					(a =
                            /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                            	o
                            ))
				)
					return (
						(this.r = Math.min(100, parseInt(a[1], 10)) / 100),
						(this.g = Math.min(100, parseInt(a[2], 10)) / 100),
						(this.b = Math.min(100, parseInt(a[3], 10)) / 100),
						cr.toWorkingColorSpace(this, t),
						i(a[4]),
						this
					);
				break;
			case 'hsl':
			case 'hsla':
				if (
					(a =
                            /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                            	o
                            ))
				) {
					const l = parseFloat(a[1]) / 360,
						c = parseInt(a[2], 10) / 100,
						u = parseInt(a[3], 10) / 100;
					return i(a[4]), this.setHSL(l, c, u, t);
				}
				break;
			}
		} else if ((n = /^\#([A-Fa-f\d]+)$/.exec(e))) {
			const a = n[1],
				s = a.length;
			if (s === 3)
				return (
					(this.r = parseInt(a.charAt(0) + a.charAt(0), 16) / 255),
					(this.g = parseInt(a.charAt(1) + a.charAt(1), 16) / 255),
					(this.b = parseInt(a.charAt(2) + a.charAt(2), 16) / 255),
					cr.toWorkingColorSpace(this, t),
					this
				);
			if (s === 6)
				return (
					(this.r = parseInt(a.charAt(0) + a.charAt(1), 16) / 255),
					(this.g = parseInt(a.charAt(2) + a.charAt(3), 16) / 255),
					(this.b = parseInt(a.charAt(4) + a.charAt(5), 16) / 255),
					cr.toWorkingColorSpace(this, t),
					this
				);
		}
		return e && e.length > 0 ? this.setColorName(e, t) : this;
	}
	setColorName(e, t = jr) {
		const i = If[e.toLowerCase()];
		return (
			i !== void 0
				? this.setHex(i, t)
				: console.warn('THREE.Color: Unknown color ' + e),
			this
		);
	}
	clone() {
		return new this.constructor(this.r, this.g, this.b);
	}
	copy(e) {
		return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
	}
	copySRGBToLinear(e) {
		return (this.r = nn(e.r)), (this.g = nn(e.g)), (this.b = nn(e.b)), this;
	}
	copyLinearToSRGB(e) {
		return (this.r = Ao(e.r)), (this.g = Ao(e.g)), (this.b = Ao(e.b)), this;
	}
	convertSRGBToLinear() {
		return this.copySRGBToLinear(this), this;
	}
	convertLinearToSRGB() {
		return this.copyLinearToSRGB(this), this;
	}
	getHex(e = jr) {
		return (
			cr.fromWorkingColorSpace(Fs(this, _t), e),
			(Et(_t.r * 255, 0, 255) << 16) ^
                (Et(_t.g * 255, 0, 255) << 8) ^
                (Et(_t.b * 255, 0, 255) << 0)
		);
	}
	getHexString(e = jr) {
		return ('000000' + this.getHex(e).toString(16)).slice(-6);
	}
	getHSL(e, t = Ji) {
		cr.fromWorkingColorSpace(Fs(this, _t), t);
		const i = _t.r,
			n = _t.g,
			a = _t.b,
			s = Math.max(i, n, a),
			o = Math.min(i, n, a);
		let l, c;
		const u = (o + s) / 2;
		if (o === s) (l = 0), (c = 0);
		else {
			const h = s - o;
			switch (((c = u <= 0.5 ? h / (s + o) : h / (2 - s - o)), s)) {
			case i:
				l = (n - a) / h + (n < a ? 6 : 0);
				break;
			case n:
				l = (a - i) / h + 2;
				break;
			case a:
				l = (i - n) / h + 4;
				break;
			}
			l /= 6;
		}
		return (e.h = l), (e.s = c), (e.l = u), e;
	}
	getRGB(e, t = Ji) {
		return (
			cr.fromWorkingColorSpace(Fs(this, _t), t),
			(e.r = _t.r),
			(e.g = _t.g),
			(e.b = _t.b),
			e
		);
	}
	getStyle(e = jr) {
		return (
			cr.fromWorkingColorSpace(Fs(this, _t), e),
			e !== jr
				? `color(${e} ${_t.r} ${_t.g} ${_t.b})`
				: `rgb(${(_t.r * 255) | 0},${(_t.g * 255) | 0},${
					(_t.b * 255) | 0
				})`
		);
	}
	offsetHSL(e, t, i) {
		return (
			this.getHSL(ur),
			(ur.h += e),
			(ur.s += t),
			(ur.l += i),
			this.setHSL(ur.h, ur.s, ur.l),
			this
		);
	}
	add(e) {
		return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
	}
	addColors(e, t) {
		return (
			(this.r = e.r + t.r),
			(this.g = e.g + t.g),
			(this.b = e.b + t.b),
			this
		);
	}
	addScalar(e) {
		return (this.r += e), (this.g += e), (this.b += e), this;
	}
	sub(e) {
		return (
			(this.r = Math.max(0, this.r - e.r)),
			(this.g = Math.max(0, this.g - e.g)),
			(this.b = Math.max(0, this.b - e.b)),
			this
		);
	}
	multiply(e) {
		return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
	}
	multiplyScalar(e) {
		return (this.r *= e), (this.g *= e), (this.b *= e), this;
	}
	lerp(e, t) {
		return (
			(this.r += (e.r - this.r) * t),
			(this.g += (e.g - this.g) * t),
			(this.b += (e.b - this.b) * t),
			this
		);
	}
	lerpColors(e, t, i) {
		return (
			(this.r = e.r + (t.r - e.r) * i),
			(this.g = e.g + (t.g - e.g) * i),
			(this.b = e.b + (t.b - e.b) * i),
			this
		);
	}
	lerpHSL(e, t) {
		this.getHSL(ur), e.getHSL(Bs);
		const i = ts(ur.h, Bs.h, t),
			n = ts(ur.s, Bs.s, t),
			a = ts(ur.l, Bs.l, t);
		return this.setHSL(i, n, a), this;
	}
	equals(e) {
		return e.r === this.r && e.g === this.g && e.b === this.b;
	}
	fromArray(e, t = 0) {
		return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
	}
	toArray(e = [], t = 0) {
		return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
	}
	fromBufferAttribute(e, t) {
		return (
			(this.r = e.getX(t)),
			(this.g = e.getY(t)),
			(this.b = e.getZ(t)),
			e.normalized === !0 &&
                ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
			this
		);
	}
	toJSON() {
		return this.getHex();
	}
}
ke.NAMES = If;
ke.prototype.isColor = !0;
ke.prototype.r = 1;
ke.prototype.g = 1;
ke.prototype.b = 1;
let bn;
class hn {
	static getDataURL(e) {
		if (/^data:/i.test(e.src) || typeof HTMLCanvasElement == 'undefined')
			return e.src;
		let t;
		if (e instanceof HTMLCanvasElement) t = e;
		else {
			bn === void 0 && (bn = ys('canvas')),
			(bn.width = e.width),
			(bn.height = e.height);
			const i = bn.getContext('2d');
			e instanceof ImageData
				? i.putImageData(e, 0, 0)
				: i.drawImage(e, 0, 0, e.width, e.height),
			(t = bn);
		}
		return t.width > 2048 || t.height > 2048
			? (console.warn(
				'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons',
				e
			),
			t.toDataURL('image/jpeg', 0.6))
			: t.toDataURL('image/png');
	}
	static sRGBToLinear(e) {
		if (
			(typeof HTMLImageElement != 'undefined' &&
                e instanceof HTMLImageElement) ||
            (typeof HTMLCanvasElement != 'undefined' &&
                e instanceof HTMLCanvasElement) ||
            (typeof ImageBitmap != 'undefined' && e instanceof ImageBitmap)
		) {
			const t = ys('canvas');
			(t.width = e.width), (t.height = e.height);
			const i = t.getContext('2d');
			i.drawImage(e, 0, 0, e.width, e.height);
			const n = i.getImageData(0, 0, e.width, e.height),
				a = n.data;
			for (let s = 0; s < a.length; s++) a[s] = nn(a[s] / 255) * 255;
			return i.putImageData(n, 0, 0), t;
		} else if (e.data) {
			const t = e.data.slice(0);
			for (let i = 0; i < t.length; i++)
				t instanceof Uint8Array || t instanceof Uint8ClampedArray
					? (t[i] = Math.floor(nn(t[i] / 255) * 255))
					: (t[i] = nn(t[i]));
			return { data: t, width: e.width, height: e.height };
		} else
			return (
				console.warn(
					'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.'
				),
				e
			);
	}
}
class Df {
	constructor(e = null) {
		(this.uuid = ir()), (this.data = e), (this.version = 0);
	}
	set needsUpdate(e) {
		e === !0 && this.version++;
	}
	toJSON(e) {
		const t = e === void 0 || typeof e == 'string';
		if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
		const i = { uuid: this.uuid, url: '' },
			n = this.data;
		if (n !== null) {
			let a;
			if (Array.isArray(n)) {
				a = [];
				for (let s = 0, o = n.length; s < o; s++)
					n[s].isDataTexture
						? a.push(Dl(n[s].image))
						: a.push(Dl(n[s]));
			} else a = Dl(n);
			i.url = a;
		}
		return t || (e.images[this.uuid] = i), i;
	}
}
function Dl(r) {
	return (typeof HTMLImageElement != 'undefined' &&
        r instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement != 'undefined' &&
            r instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap != 'undefined' && r instanceof ImageBitmap)
		? hn.getDataURL(r)
		: r.data
			? {
				data: Array.prototype.slice.call(r.data),
				width: r.width,
				height: r.height,
				type: r.data.constructor.name
			}
			: (console.warn('THREE.Texture: Unable to serialize Texture.'), {});
}
Df.prototype.isSource = !0;
let mb = 0;
class wt extends Di {
	constructor(
		e = wt.DEFAULT_IMAGE,
		t = wt.DEFAULT_MAPPING,
		i = Kt,
		n = Kt,
		a = Nt,
		s = ba,
		o = Qt,
		l = sn,
		c = 1,
		u = Qr
	) {
		super(),
		Object.defineProperty(this, 'id', { value: mb++ }),
		(this.uuid = ir()),
		(this.name = ''),
		(this.source = new Df(e)),
		(this.mipmaps = []),
		(this.mapping = t),
		(this.wrapS = i),
		(this.wrapT = n),
		(this.magFilter = a),
		(this.minFilter = s),
		(this.anisotropy = c),
		(this.format = o),
		(this.internalFormat = null),
		(this.type = l),
		(this.offset = new me(0, 0)),
		(this.repeat = new me(1, 1)),
		(this.center = new me(0, 0)),
		(this.rotation = 0),
		(this.matrixAutoUpdate = !0),
		(this.matrix = new kt()),
		(this.generateMipmaps = !0),
		(this.premultiplyAlpha = !1),
		(this.flipY = !0),
		(this.unpackAlignment = 4),
		(this.encoding = u),
		(this.userData = {}),
		(this.version = 0),
		(this.onUpdate = null),
		(this.isRenderTargetTexture = !1),
		(this.needsPMREMUpdate = !1);
	}
	get image() {
		return this.source.data;
	}
	set image(e) {
		this.source.data = e;
	}
	updateMatrix() {
		this.matrix.setUvTransform(
			this.offset.x,
			this.offset.y,
			this.repeat.x,
			this.repeat.y,
			this.rotation,
			this.center.x,
			this.center.y
		);
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(e) {
		return (
			(this.name = e.name),
			(this.source = e.source),
			(this.mipmaps = e.mipmaps.slice(0)),
			(this.mapping = e.mapping),
			(this.wrapS = e.wrapS),
			(this.wrapT = e.wrapT),
			(this.magFilter = e.magFilter),
			(this.minFilter = e.minFilter),
			(this.anisotropy = e.anisotropy),
			(this.format = e.format),
			(this.internalFormat = e.internalFormat),
			(this.type = e.type),
			this.offset.copy(e.offset),
			this.repeat.copy(e.repeat),
			this.center.copy(e.center),
			(this.rotation = e.rotation),
			(this.matrixAutoUpdate = e.matrixAutoUpdate),
			this.matrix.copy(e.matrix),
			(this.generateMipmaps = e.generateMipmaps),
			(this.premultiplyAlpha = e.premultiplyAlpha),
			(this.flipY = e.flipY),
			(this.unpackAlignment = e.unpackAlignment),
			(this.encoding = e.encoding),
			(this.userData = JSON.parse(JSON.stringify(e.userData))),
			(this.needsUpdate = !0),
			this
		);
	}
	toJSON(e) {
		const t = e === void 0 || typeof e == 'string';
		if (!t && e.textures[this.uuid] !== void 0)
			return e.textures[this.uuid];
		const i = {
			metadata: {
				version: 4.5,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},
			uuid: this.uuid,
			name: this.name,
			image: this.source.toJSON(e).uuid,
			mapping: this.mapping,
			repeat: [this.repeat.x, this.repeat.y],
			offset: [this.offset.x, this.offset.y],
			center: [this.center.x, this.center.y],
			rotation: this.rotation,
			wrap: [this.wrapS, this.wrapT],
			format: this.format,
			type: this.type,
			encoding: this.encoding,
			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,
			flipY: this.flipY,
			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment
		};
		return (
			JSON.stringify(this.userData) !== '{}' &&
                (i.userData = this.userData),
			t || (e.textures[this.uuid] = i),
			i
		);
	}
	dispose() {
		this.dispatchEvent({ type: 'dispose' });
	}
	transformUv(e) {
		if (this.mapping !== Af) return e;
		if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
			switch (this.wrapS) {
			case oa:
				e.x = e.x - Math.floor(e.x);
				break;
			case Kt:
				e.x = e.x < 0 ? 0 : 1;
				break;
			case Oo:
				Math.abs(Math.floor(e.x) % 2) === 1
					? (e.x = Math.ceil(e.x) - e.x)
					: (e.x = e.x - Math.floor(e.x));
				break;
			}
		if (e.y < 0 || e.y > 1)
			switch (this.wrapT) {
			case oa:
				e.y = e.y - Math.floor(e.y);
				break;
			case Kt:
				e.y = e.y < 0 ? 0 : 1;
				break;
			case Oo:
				Math.abs(Math.floor(e.y) % 2) === 1
					? (e.y = Math.ceil(e.y) - e.y)
					: (e.y = e.y - Math.floor(e.y));
				break;
			}
		return this.flipY && (e.y = 1 - e.y), e;
	}
	set needsUpdate(e) {
		e === !0 && (this.version++, (this.source.needsUpdate = !0));
	}
}
wt.DEFAULT_IMAGE = null;
wt.DEFAULT_MAPPING = Af;
wt.prototype.isTexture = !0;
class it {
	constructor(e = 0, t = 0, i = 0, n = 1) {
		(this.x = e), (this.y = t), (this.z = i), (this.w = n);
	}
	get width() {
		return this.z;
	}
	set width(e) {
		this.z = e;
	}
	get height() {
		return this.w;
	}
	set height(e) {
		this.w = e;
	}
	set(e, t, i, n) {
		return (this.x = e), (this.y = t), (this.z = i), (this.w = n), this;
	}
	setScalar(e) {
		return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
	}
	setX(e) {
		return (this.x = e), this;
	}
	setY(e) {
		return (this.y = e), this;
	}
	setZ(e) {
		return (this.z = e), this;
	}
	setW(e) {
		return (this.w = e), this;
	}
	setComponent(e, t) {
		switch (e) {
		case 0:
			this.x = t;
			break;
		case 1:
			this.y = t;
			break;
		case 2:
			this.z = t;
			break;
		case 3:
			this.w = t;
			break;
		default:
			throw new Error('index is out of range: ' + e);
		}
		return this;
	}
	getComponent(e) {
		switch (e) {
		case 0:
			return this.x;
		case 1:
			return this.y;
		case 2:
			return this.z;
		case 3:
			return this.w;
		default:
			throw new Error('index is out of range: ' + e);
		}
	}
	clone() {
		return new this.constructor(this.x, this.y, this.z, this.w);
	}
	copy(e) {
		return (
			(this.x = e.x),
			(this.y = e.y),
			(this.z = e.z),
			(this.w = e.w !== void 0 ? e.w : 1),
			this
		);
	}
	add(e, t) {
		return t !== void 0
			? (console.warn(
				'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.'
			),
			this.addVectors(e, t))
			: ((this.x += e.x),
			(this.y += e.y),
			(this.z += e.z),
			(this.w += e.w),
			this);
	}
	addScalar(e) {
		return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
	}
	addVectors(e, t) {
		return (
			(this.x = e.x + t.x),
			(this.y = e.y + t.y),
			(this.z = e.z + t.z),
			(this.w = e.w + t.w),
			this
		);
	}
	addScaledVector(e, t) {
		return (
			(this.x += e.x * t),
			(this.y += e.y * t),
			(this.z += e.z * t),
			(this.w += e.w * t),
			this
		);
	}
	sub(e, t) {
		return t !== void 0
			? (console.warn(
				'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'
			),
			this.subVectors(e, t))
			: ((this.x -= e.x),
			(this.y -= e.y),
			(this.z -= e.z),
			(this.w -= e.w),
			this);
	}
	subScalar(e) {
		return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
	}
	subVectors(e, t) {
		return (
			(this.x = e.x - t.x),
			(this.y = e.y - t.y),
			(this.z = e.z - t.z),
			(this.w = e.w - t.w),
			this
		);
	}
	multiply(e) {
		return (
			(this.x *= e.x),
			(this.y *= e.y),
			(this.z *= e.z),
			(this.w *= e.w),
			this
		);
	}
	multiplyScalar(e) {
		return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
	}
	applyMatrix4(e) {
		const t = this.x,
			i = this.y,
			n = this.z,
			a = this.w,
			s = e.elements;
		return (
			(this.x = s[0] * t + s[4] * i + s[8] * n + s[12] * a),
			(this.y = s[1] * t + s[5] * i + s[9] * n + s[13] * a),
			(this.z = s[2] * t + s[6] * i + s[10] * n + s[14] * a),
			(this.w = s[3] * t + s[7] * i + s[11] * n + s[15] * a),
			this
		);
	}
	divideScalar(e) {
		return this.multiplyScalar(1 / e);
	}
	setAxisAngleFromQuaternion(e) {
		this.w = 2 * Math.acos(e.w);
		const t = Math.sqrt(1 - e.w * e.w);
		return (
			t < 1e-4
				? ((this.x = 1), (this.y = 0), (this.z = 0))
				: ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
			this
		);
	}
	setAxisAngleFromRotationMatrix(e) {
		let t, i, n, a;
		const s = e.elements,
			o = s[0],
			l = s[4],
			c = s[8],
			u = s[1],
			h = s[5],
			d = s[9],
			p = s[2],
			g = s[6],
			m = s[10];
		if (
			Math.abs(l - u) < 0.01 &&
            Math.abs(c - p) < 0.01 &&
            Math.abs(d - g) < 0.01
		) {
			if (
				Math.abs(l + u) < 0.1 &&
                Math.abs(c + p) < 0.1 &&
                Math.abs(d + g) < 0.1 &&
                Math.abs(o + h + m - 3) < 0.1
			)
				return this.set(1, 0, 0, 0), this;
			t = Math.PI;
			const v = (o + 1) / 2,
				x = (h + 1) / 2,
				A = (m + 1) / 2,
				S = (l + u) / 4,
				M = (c + p) / 4,
				I = (d + g) / 4;
			return (
				v > x && v > A
					? v < 0.01
						? ((i = 0), (n = 0.707106781), (a = 0.707106781))
						: ((i = Math.sqrt(v)), (n = S / i), (a = M / i))
					: x > A
						? x < 0.01
							? ((i = 0.707106781), (n = 0), (a = 0.707106781))
							: ((n = Math.sqrt(x)), (i = S / n), (a = I / n))
						: A < 0.01
							? ((i = 0.707106781), (n = 0.707106781), (a = 0))
							: ((a = Math.sqrt(A)), (i = M / a), (n = I / a)),
				this.set(i, n, a, t),
				this
			);
		}
		let f = Math.sqrt(
			(g - d) * (g - d) + (c - p) * (c - p) + (u - l) * (u - l)
		);
		return (
			Math.abs(f) < 0.001 && (f = 1),
			(this.x = (g - d) / f),
			(this.y = (c - p) / f),
			(this.z = (u - l) / f),
			(this.w = Math.acos((o + h + m - 1) / 2)),
			this
		);
	}
	min(e) {
		return (
			(this.x = Math.min(this.x, e.x)),
			(this.y = Math.min(this.y, e.y)),
			(this.z = Math.min(this.z, e.z)),
			(this.w = Math.min(this.w, e.w)),
			this
		);
	}
	max(e) {
		return (
			(this.x = Math.max(this.x, e.x)),
			(this.y = Math.max(this.y, e.y)),
			(this.z = Math.max(this.z, e.z)),
			(this.w = Math.max(this.w, e.w)),
			this
		);
	}
	clamp(e, t) {
		return (
			(this.x = Math.max(e.x, Math.min(t.x, this.x))),
			(this.y = Math.max(e.y, Math.min(t.y, this.y))),
			(this.z = Math.max(e.z, Math.min(t.z, this.z))),
			(this.w = Math.max(e.w, Math.min(t.w, this.w))),
			this
		);
	}
	clampScalar(e, t) {
		return (
			(this.x = Math.max(e, Math.min(t, this.x))),
			(this.y = Math.max(e, Math.min(t, this.y))),
			(this.z = Math.max(e, Math.min(t, this.z))),
			(this.w = Math.max(e, Math.min(t, this.w))),
			this
		);
	}
	clampLength(e, t) {
		const i = this.length();
		return this.divideScalar(i || 1).multiplyScalar(
			Math.max(e, Math.min(t, i))
		);
	}
	floor() {
		return (
			(this.x = Math.floor(this.x)),
			(this.y = Math.floor(this.y)),
			(this.z = Math.floor(this.z)),
			(this.w = Math.floor(this.w)),
			this
		);
	}
	ceil() {
		return (
			(this.x = Math.ceil(this.x)),
			(this.y = Math.ceil(this.y)),
			(this.z = Math.ceil(this.z)),
			(this.w = Math.ceil(this.w)),
			this
		);
	}
	round() {
		return (
			(this.x = Math.round(this.x)),
			(this.y = Math.round(this.y)),
			(this.z = Math.round(this.z)),
			(this.w = Math.round(this.w)),
			this
		);
	}
	roundToZero() {
		return (
			(this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
			(this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
			(this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
			(this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
			this
		);
	}
	negate() {
		return (
			(this.x = -this.x),
			(this.y = -this.y),
			(this.z = -this.z),
			(this.w = -this.w),
			this
		);
	}
	dot(e) {
		return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
	}
	lengthSq() {
		return (
			this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
		);
	}
	length() {
		return Math.sqrt(
			this.x * this.x +
                this.y * this.y +
                this.z * this.z +
                this.w * this.w
		);
	}
	manhattanLength() {
		return (
			Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
		);
	}
	normalize() {
		return this.divideScalar(this.length() || 1);
	}
	setLength(e) {
		return this.normalize().multiplyScalar(e);
	}
	lerp(e, t) {
		return (
			(this.x += (e.x - this.x) * t),
			(this.y += (e.y - this.y) * t),
			(this.z += (e.z - this.z) * t),
			(this.w += (e.w - this.w) * t),
			this
		);
	}
	lerpVectors(e, t, i) {
		return (
			(this.x = e.x + (t.x - e.x) * i),
			(this.y = e.y + (t.y - e.y) * i),
			(this.z = e.z + (t.z - e.z) * i),
			(this.w = e.w + (t.w - e.w) * i),
			this
		);
	}
	equals(e) {
		return (
			e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
		);
	}
	fromArray(e, t = 0) {
		return (
			(this.x = e[t]),
			(this.y = e[t + 1]),
			(this.z = e[t + 2]),
			(this.w = e[t + 3]),
			this
		);
	}
	toArray(e = [], t = 0) {
		return (
			(e[t] = this.x),
			(e[t + 1] = this.y),
			(e[t + 2] = this.z),
			(e[t + 3] = this.w),
			e
		);
	}
	fromBufferAttribute(e, t, i) {
		return (
			i !== void 0 &&
                console.warn(
                	'THREE.Vector4: offset has been removed from .fromBufferAttribute().'
                ),
			(this.x = e.getX(t)),
			(this.y = e.getY(t)),
			(this.z = e.getZ(t)),
			(this.w = e.getW(t)),
			this
		);
	}
	random() {
		return (
			(this.x = Math.random()),
			(this.y = Math.random()),
			(this.z = Math.random()),
			(this.w = Math.random()),
			this
		);
	}
	*[Symbol.iterator]() {
		yield this.x, yield this.y, yield this.z, yield this.w;
	}
}
it.prototype.isVector4 = !0;
class Xt extends Di {
	constructor(e, t, i = {}) {
		super(),
		(this.width = e),
		(this.height = t),
		(this.depth = 1),
		(this.scissor = new it(0, 0, e, t)),
		(this.scissorTest = !1),
		(this.viewport = new it(0, 0, e, t));
		const n = { width: e, height: t, depth: 1 };
		(this.texture = new wt(
			n,
			i.mapping,
			i.wrapS,
			i.wrapT,
			i.magFilter,
			i.minFilter,
			i.format,
			i.type,
			i.anisotropy,
			i.encoding
		)),
		(this.texture.isRenderTargetTexture = !0),
		(this.texture.flipY = !1),
		(this.texture.generateMipmaps =
                i.generateMipmaps !== void 0 ? i.generateMipmaps : !1),
		(this.texture.internalFormat =
                i.internalFormat !== void 0 ? i.internalFormat : null),
		(this.texture.minFilter =
                i.minFilter !== void 0 ? i.minFilter : Nt),
		(this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : !0),
		(this.stencilBuffer =
                i.stencilBuffer !== void 0 ? i.stencilBuffer : !1),
		(this.depthTexture =
                i.depthTexture !== void 0 ? i.depthTexture : null),
		(this.samples = i.samples !== void 0 ? i.samples : 0);
	}
	setSize(e, t, i = 1) {
		(this.width !== e || this.height !== t || this.depth !== i) &&
            ((this.width = e),
            (this.height = t),
            (this.depth = i),
            (this.texture.image.width = e),
            (this.texture.image.height = t),
            (this.texture.image.depth = i),
            this.dispose()),
		this.viewport.set(0, 0, e, t),
		this.scissor.set(0, 0, e, t);
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(e) {
		return (
			(this.width = e.width),
			(this.height = e.height),
			(this.depth = e.depth),
			this.viewport.copy(e.viewport),
			(this.texture = e.texture.clone()),
			(this.texture.isRenderTargetTexture = !0),
			(this.texture.image = Object.assign({}, e.texture.image)),
			(this.depthBuffer = e.depthBuffer),
			(this.stencilBuffer = e.stencilBuffer),
			e.depthTexture !== null &&
                (this.depthTexture = e.depthTexture.clone()),
			(this.samples = e.samples),
			this
		);
	}
	dispose() {
		this.dispatchEvent({ type: 'dispose' });
	}
}
Xt.prototype.isWebGLRenderTarget = !0;
class il extends wt {
	constructor(e = null, t = 1, i = 1, n = 1) {
		super(null),
		(this.image = { data: e, width: t, height: i, depth: n }),
		(this.magFilter = Mt),
		(this.minFilter = Mt),
		(this.wrapR = Kt),
		(this.generateMipmaps = !1),
		(this.flipY = !1),
		(this.unpackAlignment = 1);
	}
}
il.prototype.isDataArrayTexture = !0;
class fb extends Xt {
	constructor(e, t, i) {
		super(e, t),
		(this.depth = i),
		(this.texture = new il(null, e, t, i)),
		(this.texture.isRenderTargetTexture = !0);
	}
}
fb.prototype.isWebGLArrayRenderTarget = !0;
class Pu extends wt {
	constructor(e = null, t = 1, i = 1, n = 1) {
		super(null),
		(this.image = { data: e, width: t, height: i, depth: n }),
		(this.magFilter = Mt),
		(this.minFilter = Mt),
		(this.wrapR = Kt),
		(this.generateMipmaps = !1),
		(this.flipY = !1),
		(this.unpackAlignment = 1);
	}
}
Pu.prototype.isData3DTexture = !0;
class gb extends Xt {
	constructor(e, t, i) {
		super(e, t),
		(this.depth = i),
		(this.texture = new Pu(null, e, t, i)),
		(this.texture.isRenderTargetTexture = !0);
	}
}
gb.prototype.isWebGL3DRenderTarget = !0;
class vb extends Xt {
	constructor(e, t, i, n = {}) {
		super(e, t, n);
		const a = this.texture;
		this.texture = [];
		for (let s = 0; s < i; s++)
			(this.texture[s] = a.clone()),
			(this.texture[s].isRenderTargetTexture = !0);
	}
	setSize(e, t, i = 1) {
		if (this.width !== e || this.height !== t || this.depth !== i) {
			(this.width = e), (this.height = t), (this.depth = i);
			for (let n = 0, a = this.texture.length; n < a; n++)
				(this.texture[n].image.width = e),
				(this.texture[n].image.height = t),
				(this.texture[n].image.depth = i);
			this.dispose();
		}
		return (
			this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this
		);
	}
	copy(e) {
		this.dispose(),
		(this.width = e.width),
		(this.height = e.height),
		(this.depth = e.depth),
		this.viewport.set(0, 0, this.width, this.height),
		this.scissor.set(0, 0, this.width, this.height),
		(this.depthBuffer = e.depthBuffer),
		(this.stencilBuffer = e.stencilBuffer),
		(this.depthTexture = e.depthTexture),
		(this.texture.length = 0);
		for (let t = 0, i = e.texture.length; t < i; t++)
			this.texture[t] = e.texture[t].clone();
		return this;
	}
}
vb.prototype.isWebGLMultipleRenderTargets = !0;
class Ct {
	constructor(e = 0, t = 0, i = 0, n = 1) {
		(this._x = e), (this._y = t), (this._z = i), (this._w = n);
	}
	static slerp(e, t, i, n) {
		return (
			console.warn(
				'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.'
			),
			i.slerpQuaternions(e, t, n)
		);
	}
	static slerpFlat(e, t, i, n, a, s, o) {
		let l = i[n + 0],
			c = i[n + 1],
			u = i[n + 2],
			h = i[n + 3];
		const d = a[s + 0],
			p = a[s + 1],
			g = a[s + 2],
			m = a[s + 3];
		if (o === 0) {
			(e[t + 0] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = h);
			return;
		}
		if (o === 1) {
			(e[t + 0] = d), (e[t + 1] = p), (e[t + 2] = g), (e[t + 3] = m);
			return;
		}
		if (h !== m || l !== d || c !== p || u !== g) {
			let f = 1 - o;
			const v = l * d + c * p + u * g + h * m,
				x = v >= 0 ? 1 : -1,
				A = 1 - v * v;
			if (A > Number.EPSILON) {
				const M = Math.sqrt(A),
					I = Math.atan2(M, v * x);
				(f = Math.sin(f * I) / M), (o = Math.sin(o * I) / M);
			}
			const S = o * x;
			if (
				((l = l * f + d * S),
				(c = c * f + p * S),
				(u = u * f + g * S),
				(h = h * f + m * S),
				f === 1 - o)
			) {
				const M = 1 / Math.sqrt(l * l + c * c + u * u + h * h);
				(l *= M), (c *= M), (u *= M), (h *= M);
			}
		}
		(e[t] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = h);
	}
	static multiplyQuaternionsFlat(e, t, i, n, a, s) {
		const o = i[n],
			l = i[n + 1],
			c = i[n + 2],
			u = i[n + 3],
			h = a[s],
			d = a[s + 1],
			p = a[s + 2],
			g = a[s + 3];
		return (
			(e[t] = o * g + u * h + l * p - c * d),
			(e[t + 1] = l * g + u * d + c * h - o * p),
			(e[t + 2] = c * g + u * p + o * d - l * h),
			(e[t + 3] = u * g - o * h - l * d - c * p),
			e
		);
	}
	get x() {
		return this._x;
	}
	set x(e) {
		(this._x = e), this._onChangeCallback();
	}
	get y() {
		return this._y;
	}
	set y(e) {
		(this._y = e), this._onChangeCallback();
	}
	get z() {
		return this._z;
	}
	set z(e) {
		(this._z = e), this._onChangeCallback();
	}
	get w() {
		return this._w;
	}
	set w(e) {
		(this._w = e), this._onChangeCallback();
	}
	set(e, t, i, n) {
		return (
			(this._x = e),
			(this._y = t),
			(this._z = i),
			(this._w = n),
			this._onChangeCallback(),
			this
		);
	}
	clone() {
		return new this.constructor(this._x, this._y, this._z, this._w);
	}
	copy(e) {
		return (
			(this._x = e.x),
			(this._y = e.y),
			(this._z = e.z),
			(this._w = e.w),
			this._onChangeCallback(),
			this
		);
	}
	setFromEuler(e, t) {
		if (!(e && e.isEuler))
			throw new Error(
				'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.'
			);
		const i = e._x,
			n = e._y,
			a = e._z,
			s = e._order,
			o = Math.cos,
			l = Math.sin,
			c = o(i / 2),
			u = o(n / 2),
			h = o(a / 2),
			d = l(i / 2),
			p = l(n / 2),
			g = l(a / 2);
		switch (s) {
		case 'XYZ':
			(this._x = d * u * h + c * p * g),
			(this._y = c * p * h - d * u * g),
			(this._z = c * u * g + d * p * h),
			(this._w = c * u * h - d * p * g);
			break;
		case 'YXZ':
			(this._x = d * u * h + c * p * g),
			(this._y = c * p * h - d * u * g),
			(this._z = c * u * g - d * p * h),
			(this._w = c * u * h + d * p * g);
			break;
		case 'ZXY':
			(this._x = d * u * h - c * p * g),
			(this._y = c * p * h + d * u * g),
			(this._z = c * u * g + d * p * h),
			(this._w = c * u * h - d * p * g);
			break;
		case 'ZYX':
			(this._x = d * u * h - c * p * g),
			(this._y = c * p * h + d * u * g),
			(this._z = c * u * g - d * p * h),
			(this._w = c * u * h + d * p * g);
			break;
		case 'YZX':
			(this._x = d * u * h + c * p * g),
			(this._y = c * p * h + d * u * g),
			(this._z = c * u * g - d * p * h),
			(this._w = c * u * h - d * p * g);
			break;
		case 'XZY':
			(this._x = d * u * h - c * p * g),
			(this._y = c * p * h - d * u * g),
			(this._z = c * u * g + d * p * h),
			(this._w = c * u * h + d * p * g);
			break;
		default:
			console.warn(
				'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' +
                        s
			);
		}
		return t !== !1 && this._onChangeCallback(), this;
	}
	setFromAxisAngle(e, t) {
		const i = t / 2,
			n = Math.sin(i);
		return (
			(this._x = e.x * n),
			(this._y = e.y * n),
			(this._z = e.z * n),
			(this._w = Math.cos(i)),
			this._onChangeCallback(),
			this
		);
	}
	setFromRotationMatrix(e) {
		const t = e.elements,
			i = t[0],
			n = t[4],
			a = t[8],
			s = t[1],
			o = t[5],
			l = t[9],
			c = t[2],
			u = t[6],
			h = t[10],
			d = i + o + h;
		if (d > 0) {
			const p = 0.5 / Math.sqrt(d + 1);
			(this._w = 0.25 / p),
			(this._x = (u - l) * p),
			(this._y = (a - c) * p),
			(this._z = (s - n) * p);
		} else if (i > o && i > h) {
			const p = 2 * Math.sqrt(1 + i - o - h);
			(this._w = (u - l) / p),
			(this._x = 0.25 * p),
			(this._y = (n + s) / p),
			(this._z = (a + c) / p);
		} else if (o > h) {
			const p = 2 * Math.sqrt(1 + o - i - h);
			(this._w = (a - c) / p),
			(this._x = (n + s) / p),
			(this._y = 0.25 * p),
			(this._z = (l + u) / p);
		} else {
			const p = 2 * Math.sqrt(1 + h - i - o);
			(this._w = (s - n) / p),
			(this._x = (a + c) / p),
			(this._y = (l + u) / p),
			(this._z = 0.25 * p);
		}
		return this._onChangeCallback(), this;
	}
	setFromUnitVectors(e, t) {
		let i = e.dot(t) + 1;
		return (
			i < Number.EPSILON
				? ((i = 0),
				Math.abs(e.x) > Math.abs(e.z)
					? ((this._x = -e.y),
					(this._y = e.x),
					(this._z = 0),
					(this._w = i))
					: ((this._x = 0),
					(this._y = -e.z),
					(this._z = e.y),
					(this._w = i)))
				: ((this._x = e.y * t.z - e.z * t.y),
				(this._y = e.z * t.x - e.x * t.z),
				(this._z = e.x * t.y - e.y * t.x),
				(this._w = i)),
			this.normalize()
		);
	}
	angleTo(e) {
		return 2 * Math.acos(Math.abs(Et(this.dot(e), -1, 1)));
	}
	rotateTowards(e, t) {
		const i = this.angleTo(e);
		if (i === 0) return this;
		const n = Math.min(1, t / i);
		return this.slerp(e, n), this;
	}
	identity() {
		return this.set(0, 0, 0, 1);
	}
	invert() {
		return this.conjugate();
	}
	conjugate() {
		return (
			(this._x *= -1),
			(this._y *= -1),
			(this._z *= -1),
			this._onChangeCallback(),
			this
		);
	}
	dot(e) {
		return (
			this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
		);
	}
	lengthSq() {
		return (
			this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
		);
	}
	length() {
		return Math.sqrt(
			this._x * this._x +
                this._y * this._y +
                this._z * this._z +
                this._w * this._w
		);
	}
	normalize() {
		let e = this.length();
		return (
			e === 0
				? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
				: ((e = 1 / e),
				(this._x = this._x * e),
				(this._y = this._y * e),
				(this._z = this._z * e),
				(this._w = this._w * e)),
			this._onChangeCallback(),
			this
		);
	}
	multiply(e, t) {
		return t !== void 0
			? (console.warn(
				'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.'
			),
			this.multiplyQuaternions(e, t))
			: this.multiplyQuaternions(this, e);
	}
	premultiply(e) {
		return this.multiplyQuaternions(e, this);
	}
	multiplyQuaternions(e, t) {
		const i = e._x,
			n = e._y,
			a = e._z,
			s = e._w,
			o = t._x,
			l = t._y,
			c = t._z,
			u = t._w;
		return (
			(this._x = i * u + s * o + n * c - a * l),
			(this._y = n * u + s * l + a * o - i * c),
			(this._z = a * u + s * c + i * l - n * o),
			(this._w = s * u - i * o - n * l - a * c),
			this._onChangeCallback(),
			this
		);
	}
	slerp(e, t) {
		if (t === 0) return this;
		if (t === 1) return this.copy(e);
		const i = this._x,
			n = this._y,
			a = this._z,
			s = this._w;
		let o = s * e._w + i * e._x + n * e._y + a * e._z;
		if (
			(o < 0
				? ((this._w = -e._w),
				(this._x = -e._x),
				(this._y = -e._y),
				(this._z = -e._z),
				(o = -o))
				: this.copy(e),
			o >= 1)
		)
			return (
				(this._w = s), (this._x = i), (this._y = n), (this._z = a), this
			);
		const l = 1 - o * o;
		if (l <= Number.EPSILON) {
			const p = 1 - t;
			return (
				(this._w = p * s + t * this._w),
				(this._x = p * i + t * this._x),
				(this._y = p * n + t * this._y),
				(this._z = p * a + t * this._z),
				this.normalize(),
				this._onChangeCallback(),
				this
			);
		}
		const c = Math.sqrt(l),
			u = Math.atan2(c, o),
			h = Math.sin((1 - t) * u) / c,
			d = Math.sin(t * u) / c;
		return (
			(this._w = s * h + this._w * d),
			(this._x = i * h + this._x * d),
			(this._y = n * h + this._y * d),
			(this._z = a * h + this._z * d),
			this._onChangeCallback(),
			this
		);
	}
	slerpQuaternions(e, t, i) {
		return this.copy(e).slerp(t, i);
	}
	random() {
		const e = Math.random(),
			t = Math.sqrt(1 - e),
			i = Math.sqrt(e),
			n = 2 * Math.PI * Math.random(),
			a = 2 * Math.PI * Math.random();
		return this.set(
			t * Math.cos(n),
			i * Math.sin(a),
			i * Math.cos(a),
			t * Math.sin(n)
		);
	}
	equals(e) {
		return (
			e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._w === this._w
		);
	}
	fromArray(e, t = 0) {
		return (
			(this._x = e[t]),
			(this._y = e[t + 1]),
			(this._z = e[t + 2]),
			(this._w = e[t + 3]),
			this._onChangeCallback(),
			this
		);
	}
	toArray(e = [], t = 0) {
		return (
			(e[t] = this._x),
			(e[t + 1] = this._y),
			(e[t + 2] = this._z),
			(e[t + 3] = this._w),
			e
		);
	}
	fromBufferAttribute(e, t) {
		return (
			(this._x = e.getX(t)),
			(this._y = e.getY(t)),
			(this._z = e.getZ(t)),
			(this._w = e.getW(t)),
			this
		);
	}
	_onChange(e) {
		return (this._onChangeCallback = e), this;
	}
	_onChangeCallback() {}
}
Ct.prototype.isQuaternion = !0;
class C {
	constructor(e = 0, t = 0, i = 0) {
		(this.x = e), (this.y = t), (this.z = i);
	}
	set(e, t, i) {
		return (
			i === void 0 && (i = this.z),
			(this.x = e),
			(this.y = t),
			(this.z = i),
			this
		);
	}
	setScalar(e) {
		return (this.x = e), (this.y = e), (this.z = e), this;
	}
	setX(e) {
		return (this.x = e), this;
	}
	setY(e) {
		return (this.y = e), this;
	}
	setZ(e) {
		return (this.z = e), this;
	}
	setComponent(e, t) {
		switch (e) {
		case 0:
			this.x = t;
			break;
		case 1:
			this.y = t;
			break;
		case 2:
			this.z = t;
			break;
		default:
			throw new Error('index is out of range: ' + e);
		}
		return this;
	}
	getComponent(e) {
		switch (e) {
		case 0:
			return this.x;
		case 1:
			return this.y;
		case 2:
			return this.z;
		default:
			throw new Error('index is out of range: ' + e);
		}
	}
	clone() {
		return new this.constructor(this.x, this.y, this.z);
	}
	copy(e) {
		return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
	}
	add(e, t) {
		return t !== void 0
			? (console.warn(
				'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.'
			),
			this.addVectors(e, t))
			: ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
	}
	addScalar(e) {
		return (this.x += e), (this.y += e), (this.z += e), this;
	}
	addVectors(e, t) {
		return (
			(this.x = e.x + t.x),
			(this.y = e.y + t.y),
			(this.z = e.z + t.z),
			this
		);
	}
	addScaledVector(e, t) {
		return (
			(this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this
		);
	}
	sub(e, t) {
		return t !== void 0
			? (console.warn(
				'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'
			),
			this.subVectors(e, t))
			: ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
	}
	subScalar(e) {
		return (this.x -= e), (this.y -= e), (this.z -= e), this;
	}
	subVectors(e, t) {
		return (
			(this.x = e.x - t.x),
			(this.y = e.y - t.y),
			(this.z = e.z - t.z),
			this
		);
	}
	multiply(e, t) {
		return t !== void 0
			? (console.warn(
				'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.'
			),
			this.multiplyVectors(e, t))
			: ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
	}
	multiplyScalar(e) {
		return (this.x *= e), (this.y *= e), (this.z *= e), this;
	}
	multiplyVectors(e, t) {
		return (
			(this.x = e.x * t.x),
			(this.y = e.y * t.y),
			(this.z = e.z * t.z),
			this
		);
	}
	applyEuler(e) {
		return (
			(e && e.isEuler) ||
                console.error(
                	'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.'
                ),
			this.applyQuaternion(Id.setFromEuler(e))
		);
	}
	applyAxisAngle(e, t) {
		return this.applyQuaternion(Id.setFromAxisAngle(e, t));
	}
	applyMatrix3(e) {
		const t = this.x,
			i = this.y,
			n = this.z,
			a = e.elements;
		return (
			(this.x = a[0] * t + a[3] * i + a[6] * n),
			(this.y = a[1] * t + a[4] * i + a[7] * n),
			(this.z = a[2] * t + a[5] * i + a[8] * n),
			this
		);
	}
	applyNormalMatrix(e) {
		return this.applyMatrix3(e).normalize();
	}
	applyMatrix4(e) {
		const t = this.x,
			i = this.y,
			n = this.z,
			a = e.elements,
			s = 1 / (a[3] * t + a[7] * i + a[11] * n + a[15]);
		return (
			(this.x = (a[0] * t + a[4] * i + a[8] * n + a[12]) * s),
			(this.y = (a[1] * t + a[5] * i + a[9] * n + a[13]) * s),
			(this.z = (a[2] * t + a[6] * i + a[10] * n + a[14]) * s),
			this
		);
	}
	applyQuaternion(e) {
		const t = this.x,
			i = this.y,
			n = this.z,
			a = e.x,
			s = e.y,
			o = e.z,
			l = e.w,
			c = l * t + s * n - o * i,
			u = l * i + o * t - a * n,
			h = l * n + a * i - s * t,
			d = -a * t - s * i - o * n;
		return (
			(this.x = c * l + d * -a + u * -o - h * -s),
			(this.y = u * l + d * -s + h * -a - c * -o),
			(this.z = h * l + d * -o + c * -s - u * -a),
			this
		);
	}
	project(e) {
		return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
			e.projectionMatrix
		);
	}
	unproject(e) {
		return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
			e.matrixWorld
		);
	}
	transformDirection(e) {
		const t = this.x,
			i = this.y,
			n = this.z,
			a = e.elements;
		return (
			(this.x = a[0] * t + a[4] * i + a[8] * n),
			(this.y = a[1] * t + a[5] * i + a[9] * n),
			(this.z = a[2] * t + a[6] * i + a[10] * n),
			this.normalize()
		);
	}
	divide(e) {
		return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
	}
	divideScalar(e) {
		return this.multiplyScalar(1 / e);
	}
	min(e) {
		return (
			(this.x = Math.min(this.x, e.x)),
			(this.y = Math.min(this.y, e.y)),
			(this.z = Math.min(this.z, e.z)),
			this
		);
	}
	max(e) {
		return (
			(this.x = Math.max(this.x, e.x)),
			(this.y = Math.max(this.y, e.y)),
			(this.z = Math.max(this.z, e.z)),
			this
		);
	}
	clamp(e, t) {
		return (
			(this.x = Math.max(e.x, Math.min(t.x, this.x))),
			(this.y = Math.max(e.y, Math.min(t.y, this.y))),
			(this.z = Math.max(e.z, Math.min(t.z, this.z))),
			this
		);
	}
	clampScalar(e, t) {
		return (
			(this.x = Math.max(e, Math.min(t, this.x))),
			(this.y = Math.max(e, Math.min(t, this.y))),
			(this.z = Math.max(e, Math.min(t, this.z))),
			this
		);
	}
	clampLength(e, t) {
		const i = this.length();
		return this.divideScalar(i || 1).multiplyScalar(
			Math.max(e, Math.min(t, i))
		);
	}
	floor() {
		return (
			(this.x = Math.floor(this.x)),
			(this.y = Math.floor(this.y)),
			(this.z = Math.floor(this.z)),
			this
		);
	}
	ceil() {
		return (
			(this.x = Math.ceil(this.x)),
			(this.y = Math.ceil(this.y)),
			(this.z = Math.ceil(this.z)),
			this
		);
	}
	round() {
		return (
			(this.x = Math.round(this.x)),
			(this.y = Math.round(this.y)),
			(this.z = Math.round(this.z)),
			this
		);
	}
	roundToZero() {
		return (
			(this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
			(this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
			(this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
			this
		);
	}
	negate() {
		return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
	}
	dot(e) {
		return this.x * e.x + this.y * e.y + this.z * e.z;
	}
	lengthSq() {
		return this.x * this.x + this.y * this.y + this.z * this.z;
	}
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	}
	manhattanLength() {
		return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
	}
	normalize() {
		return this.divideScalar(this.length() || 1);
	}
	setLength(e) {
		return this.normalize().multiplyScalar(e);
	}
	lerp(e, t) {
		return (
			(this.x += (e.x - this.x) * t),
			(this.y += (e.y - this.y) * t),
			(this.z += (e.z - this.z) * t),
			this
		);
	}
	lerpVectors(e, t, i) {
		return (
			(this.x = e.x + (t.x - e.x) * i),
			(this.y = e.y + (t.y - e.y) * i),
			(this.z = e.z + (t.z - e.z) * i),
			this
		);
	}
	cross(e, t) {
		return t !== void 0
			? (console.warn(
				'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.'
			),
			this.crossVectors(e, t))
			: this.crossVectors(this, e);
	}
	crossVectors(e, t) {
		const i = e.x,
			n = e.y,
			a = e.z,
			s = t.x,
			o = t.y,
			l = t.z;
		return (
			(this.x = n * l - a * o),
			(this.y = a * s - i * l),
			(this.z = i * o - n * s),
			this
		);
	}
	projectOnVector(e) {
		const t = e.lengthSq();
		if (t === 0) return this.set(0, 0, 0);
		const i = e.dot(this) / t;
		return this.copy(e).multiplyScalar(i);
	}
	projectOnPlane(e) {
		return Ol.copy(this).projectOnVector(e), this.sub(Ol);
	}
	reflect(e) {
		return this.sub(Ol.copy(e).multiplyScalar(2 * this.dot(e)));
	}
	angleTo(e) {
		const t = Math.sqrt(this.lengthSq() * e.lengthSq());
		if (t === 0) return Math.PI / 2;
		const i = this.dot(e) / t;
		return Math.acos(Et(i, -1, 1));
	}
	distanceTo(e) {
		return Math.sqrt(this.distanceToSquared(e));
	}
	distanceToSquared(e) {
		const t = this.x - e.x,
			i = this.y - e.y,
			n = this.z - e.z;
		return t * t + i * i + n * n;
	}
	manhattanDistanceTo(e) {
		return (
			Math.abs(this.x - e.x) +
            Math.abs(this.y - e.y) +
            Math.abs(this.z - e.z)
		);
	}
	setFromSpherical(e) {
		return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
	}
	setFromSphericalCoords(e, t, i) {
		const n = Math.sin(t) * e;
		return (
			(this.x = n * Math.sin(i)),
			(this.y = Math.cos(t) * e),
			(this.z = n * Math.cos(i)),
			this
		);
	}
	setFromCylindrical(e) {
		return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
	}
	setFromCylindricalCoords(e, t, i) {
		return (
			(this.x = e * Math.sin(t)),
			(this.y = i),
			(this.z = e * Math.cos(t)),
			this
		);
	}
	setFromMatrixPosition(e) {
		const t = e.elements;
		return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
	}
	setFromMatrixScale(e) {
		const t = this.setFromMatrixColumn(e, 0).length(),
			i = this.setFromMatrixColumn(e, 1).length(),
			n = this.setFromMatrixColumn(e, 2).length();
		return (this.x = t), (this.y = i), (this.z = n), this;
	}
	setFromMatrixColumn(e, t) {
		return this.fromArray(e.elements, t * 4);
	}
	setFromMatrix3Column(e, t) {
		return this.fromArray(e.elements, t * 3);
	}
	setFromEuler(e) {
		return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
	}
	equals(e) {
		return e.x === this.x && e.y === this.y && e.z === this.z;
	}
	fromArray(e, t = 0) {
		return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
	}
	toArray(e = [], t = 0) {
		return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
	}
	fromBufferAttribute(e, t, i) {
		return (
			i !== void 0 &&
                console.warn(
                	'THREE.Vector3: offset has been removed from .fromBufferAttribute().'
                ),
			(this.x = e.getX(t)),
			(this.y = e.getY(t)),
			(this.z = e.getZ(t)),
			this
		);
	}
	random() {
		return (
			(this.x = Math.random()),
			(this.y = Math.random()),
			(this.z = Math.random()),
			this
		);
	}
	randomDirection() {
		const e = (Math.random() - 0.5) * 2,
			t = Math.random() * Math.PI * 2,
			i = Math.sqrt(1 - e ** 2);
		return (
			(this.x = i * Math.cos(t)),
			(this.y = i * Math.sin(t)),
			(this.z = e),
			this
		);
	}
	*[Symbol.iterator]() {
		yield this.x, yield this.y, yield this.z;
	}
}
C.prototype.isVector3 = !0;
const Ol = new C(),
	Id = new Ct();
class or {
	constructor(
		e = new C(1 / 0, 1 / 0, 1 / 0),
		t = new C(-1 / 0, -1 / 0, -1 / 0)
	) {
		(this.min = e), (this.max = t);
	}
	set(e, t) {
		return this.min.copy(e), this.max.copy(t), this;
	}
	setFromArray(e) {
		let t = 1 / 0,
			i = 1 / 0,
			n = 1 / 0,
			a = -1 / 0,
			s = -1 / 0,
			o = -1 / 0;
		for (let l = 0, c = e.length; l < c; l += 3) {
			const u = e[l],
				h = e[l + 1],
				d = e[l + 2];
			u < t && (t = u),
			h < i && (i = h),
			d < n && (n = d),
			u > a && (a = u),
			h > s && (s = h),
			d > o && (o = d);
		}
		return this.min.set(t, i, n), this.max.set(a, s, o), this;
	}
	setFromBufferAttribute(e) {
		let t = 1 / 0,
			i = 1 / 0,
			n = 1 / 0,
			a = -1 / 0,
			s = -1 / 0,
			o = -1 / 0;
		for (let l = 0, c = e.count; l < c; l++) {
			const u = e.getX(l),
				h = e.getY(l),
				d = e.getZ(l);
			u < t && (t = u),
			h < i && (i = h),
			d < n && (n = d),
			u > a && (a = u),
			h > s && (s = h),
			d > o && (o = d);
		}
		return this.min.set(t, i, n), this.max.set(a, s, o), this;
	}
	setFromPoints(e) {
		this.makeEmpty();
		for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
		return this;
	}
	setFromCenterAndSize(e, t) {
		const i = Gi.copy(t).multiplyScalar(0.5);
		return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
	}
	setFromObject(e, t = !1) {
		return this.makeEmpty(), this.expandByObject(e, t);
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(e) {
		return this.min.copy(e.min), this.max.copy(e.max), this;
	}
	makeEmpty() {
		return (
			(this.min.x = this.min.y = this.min.z = 1 / 0),
			(this.max.x = this.max.y = this.max.z = -1 / 0),
			this
		);
	}
	isEmpty() {
		return (
			this.max.x < this.min.x ||
            this.max.y < this.min.y ||
            this.max.z < this.min.z
		);
	}
	getCenter(e) {
		return this.isEmpty()
			? e.set(0, 0, 0)
			: e.addVectors(this.min, this.max).multiplyScalar(0.5);
	}
	getSize(e) {
		return this.isEmpty()
			? e.set(0, 0, 0)
			: e.subVectors(this.max, this.min);
	}
	expandByPoint(e) {
		return this.min.min(e), this.max.max(e), this;
	}
	expandByVector(e) {
		return this.min.sub(e), this.max.add(e), this;
	}
	expandByScalar(e) {
		return this.min.addScalar(-e), this.max.addScalar(e), this;
	}
	expandByObject(e, t = !1) {
		e.updateWorldMatrix(!1, !1);
		const i = e.geometry;
		if (i !== void 0)
			if (t && i.attributes != null && i.attributes.position !== void 0) {
				const a = i.attributes.position;
				for (let s = 0, o = a.count; s < o; s++)
					Gi.fromBufferAttribute(a, s).applyMatrix4(e.matrixWorld),
					this.expandByPoint(Gi);
			} else
				i.boundingBox === null && i.computeBoundingBox(),
				Nl.copy(i.boundingBox),
				Nl.applyMatrix4(e.matrixWorld),
				this.union(Nl);
		const n = e.children;
		for (let a = 0, s = n.length; a < s; a++) this.expandByObject(n[a], t);
		return this;
	}
	containsPoint(e) {
		return !(
			e.x < this.min.x ||
            e.x > this.max.x ||
            e.y < this.min.y ||
            e.y > this.max.y ||
            e.z < this.min.z ||
            e.z > this.max.z
		);
	}
	containsBox(e) {
		return (
			this.min.x <= e.min.x &&
            e.max.x <= this.max.x &&
            this.min.y <= e.min.y &&
            e.max.y <= this.max.y &&
            this.min.z <= e.min.z &&
            e.max.z <= this.max.z
		);
	}
	getParameter(e, t) {
		return t.set(
			(e.x - this.min.x) / (this.max.x - this.min.x),
			(e.y - this.min.y) / (this.max.y - this.min.y),
			(e.z - this.min.z) / (this.max.z - this.min.z)
		);
	}
	intersectsBox(e) {
		return !(
			e.max.x < this.min.x ||
            e.min.x > this.max.x ||
            e.max.y < this.min.y ||
            e.min.y > this.max.y ||
            e.max.z < this.min.z ||
            e.min.z > this.max.z
		);
	}
	intersectsSphere(e) {
		return (
			this.clampPoint(e.center, Gi),
			Gi.distanceToSquared(e.center) <= e.radius * e.radius
		);
	}
	intersectsPlane(e) {
		let t, i;
		return (
			e.normal.x > 0
				? ((t = e.normal.x * this.min.x), (i = e.normal.x * this.max.x))
				: ((t = e.normal.x * this.max.x),
				(i = e.normal.x * this.min.x)),
			e.normal.y > 0
				? ((t += e.normal.y * this.min.y),
				(i += e.normal.y * this.max.y))
				: ((t += e.normal.y * this.max.y),
				(i += e.normal.y * this.min.y)),
			e.normal.z > 0
				? ((t += e.normal.z * this.min.z),
				(i += e.normal.z * this.max.z))
				: ((t += e.normal.z * this.max.z),
				(i += e.normal.z * this.min.z)),
			t <= -e.constant && i >= -e.constant
		);
	}
	intersectsTriangle(e) {
		if (this.isEmpty()) return !1;
		this.getCenter(Da),
		Hs.subVectors(this.max, Da),
		wn.subVectors(e.a, Da),
		_n.subVectors(e.b, Da),
		Mn.subVectors(e.c, Da),
		oi.subVectors(_n, wn),
		li.subVectors(Mn, _n),
		Vi.subVectors(wn, Mn);
		let t = [
			0,
			-oi.z,
			oi.y,
			0,
			-li.z,
			li.y,
			0,
			-Vi.z,
			Vi.y,
			oi.z,
			0,
			-oi.x,
			li.z,
			0,
			-li.x,
			Vi.z,
			0,
			-Vi.x,
			-oi.y,
			oi.x,
			0,
			-li.y,
			li.x,
			0,
			-Vi.y,
			Vi.x,
			0
		];
		return !zl(t, wn, _n, Mn, Hs) ||
            ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !zl(t, wn, _n, Mn, Hs))
			? !1
			: (Gs.crossVectors(oi, li),
			(t = [Gs.x, Gs.y, Gs.z]),
			zl(t, wn, _n, Mn, Hs));
	}
	clampPoint(e, t) {
		return t.copy(e).clamp(this.min, this.max);
	}
	distanceToPoint(e) {
		return Gi.copy(e).clamp(this.min, this.max).sub(e).length();
	}
	getBoundingSphere(e) {
		return (
			this.getCenter(e.center),
			(e.radius = this.getSize(Gi).length() * 0.5),
			e
		);
	}
	intersect(e) {
		return (
			this.min.max(e.min),
			this.max.min(e.max),
			this.isEmpty() && this.makeEmpty(),
			this
		);
	}
	union(e) {
		return this.min.min(e.min), this.max.max(e.max), this;
	}
	applyMatrix4(e) {
		return this.isEmpty()
			? this
			: (Ur[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
			Ur[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
			Ur[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
			Ur[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
			Ur[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
			Ur[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
			Ur[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
			Ur[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
			this.setFromPoints(Ur),
			this);
	}
	translate(e) {
		return this.min.add(e), this.max.add(e), this;
	}
	equals(e) {
		return e.min.equals(this.min) && e.max.equals(this.max);
	}
}
or.prototype.isBox3 = !0;
const Ur = [
		new C(),
		new C(),
		new C(),
		new C(),
		new C(),
		new C(),
		new C(),
		new C()
	],
	Gi = new C(),
	Nl = new or(),
	wn = new C(),
	_n = new C(),
	Mn = new C(),
	oi = new C(),
	li = new C(),
	Vi = new C(),
	Da = new C(),
	Hs = new C(),
	Gs = new C(),
	Wi = new C();
function zl(r, e, t, i, n) {
	for (let a = 0, s = r.length - 3; a <= s; a += 3) {
		Wi.fromArray(r, a);
		const o =
                n.x * Math.abs(Wi.x) +
                n.y * Math.abs(Wi.y) +
                n.z * Math.abs(Wi.z),
			l = e.dot(Wi),
			c = t.dot(Wi),
			u = i.dot(Wi);
		if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > o) return !1;
	}
	return !0;
}
const yb = new or(),
	Dd = new C(),
	Vs = new C(),
	Ul = new C();
class dn {
	constructor(e = new C(), t = -1) {
		(this.center = e), (this.radius = t);
	}
	set(e, t) {
		return this.center.copy(e), (this.radius = t), this;
	}
	setFromPoints(e, t) {
		const i = this.center;
		t !== void 0 ? i.copy(t) : yb.setFromPoints(e).getCenter(i);
		let n = 0;
		for (let a = 0, s = e.length; a < s; a++)
			n = Math.max(n, i.distanceToSquared(e[a]));
		return (this.radius = Math.sqrt(n)), this;
	}
	copy(e) {
		return this.center.copy(e.center), (this.radius = e.radius), this;
	}
	isEmpty() {
		return this.radius < 0;
	}
	makeEmpty() {
		return this.center.set(0, 0, 0), (this.radius = -1), this;
	}
	containsPoint(e) {
		return e.distanceToSquared(this.center) <= this.radius * this.radius;
	}
	distanceToPoint(e) {
		return e.distanceTo(this.center) - this.radius;
	}
	intersectsSphere(e) {
		const t = this.radius + e.radius;
		return e.center.distanceToSquared(this.center) <= t * t;
	}
	intersectsBox(e) {
		return e.intersectsSphere(this);
	}
	intersectsPlane(e) {
		return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
	}
	clampPoint(e, t) {
		const i = this.center.distanceToSquared(e);
		return (
			t.copy(e),
			i > this.radius * this.radius &&
                (t.sub(this.center).normalize(),
                t.multiplyScalar(this.radius).add(this.center)),
			t
		);
	}
	getBoundingBox(e) {
		return this.isEmpty()
			? (e.makeEmpty(), e)
			: (e.set(this.center, this.center),
			e.expandByScalar(this.radius),
			e);
	}
	applyMatrix4(e) {
		return (
			this.center.applyMatrix4(e),
			(this.radius = this.radius * e.getMaxScaleOnAxis()),
			this
		);
	}
	translate(e) {
		return this.center.add(e), this;
	}
	expandByPoint(e) {
		Ul.subVectors(e, this.center);
		const t = Ul.lengthSq();
		if (t > this.radius * this.radius) {
			const i = Math.sqrt(t),
				n = (i - this.radius) * 0.5;
			this.center.add(Ul.multiplyScalar(n / i)), (this.radius += n);
		}
		return this;
	}
	union(e) {
		return (
			this.center.equals(e.center) === !0
				? Vs.set(0, 0, 1).multiplyScalar(e.radius)
				: Vs.subVectors(e.center, this.center)
					.normalize()
					.multiplyScalar(e.radius),
			this.expandByPoint(Dd.copy(e.center).add(Vs)),
			this.expandByPoint(Dd.copy(e.center).sub(Vs)),
			this
		);
	}
	equals(e) {
		return e.center.equals(this.center) && e.radius === this.radius;
	}
	clone() {
		return new this.constructor().copy(this);
	}
}
const Br = new C(),
	Bl = new C(),
	Ws = new C(),
	ci = new C(),
	Fl = new C(),
	js = new C(),
	Hl = new C();
class wa {
	constructor(e = new C(), t = new C(0, 0, -1)) {
		(this.origin = e), (this.direction = t);
	}
	set(e, t) {
		return this.origin.copy(e), this.direction.copy(t), this;
	}
	copy(e) {
		return (
			this.origin.copy(e.origin), this.direction.copy(e.direction), this
		);
	}
	at(e, t) {
		return t.copy(this.direction).multiplyScalar(e).add(this.origin);
	}
	lookAt(e) {
		return this.direction.copy(e).sub(this.origin).normalize(), this;
	}
	recast(e) {
		return this.origin.copy(this.at(e, Br)), this;
	}
	closestPointToPoint(e, t) {
		t.subVectors(e, this.origin);
		const i = t.dot(this.direction);
		return i < 0
			? t.copy(this.origin)
			: t.copy(this.direction).multiplyScalar(i).add(this.origin);
	}
	distanceToPoint(e) {
		return Math.sqrt(this.distanceSqToPoint(e));
	}
	distanceSqToPoint(e) {
		const t = Br.subVectors(e, this.origin).dot(this.direction);
		return t < 0
			? this.origin.distanceToSquared(e)
			: (Br.copy(this.direction).multiplyScalar(t).add(this.origin),
			Br.distanceToSquared(e));
	}
	distanceSqToSegment(e, t, i, n) {
		Bl.copy(e).add(t).multiplyScalar(0.5),
		Ws.copy(t).sub(e).normalize(),
		ci.copy(this.origin).sub(Bl);
		const a = e.distanceTo(t) * 0.5,
			s = -this.direction.dot(Ws),
			o = ci.dot(this.direction),
			l = -ci.dot(Ws),
			c = ci.lengthSq(),
			u = Math.abs(1 - s * s);
		let h, d, p, g;
		if (u > 0)
			if (((h = s * l - o), (d = s * o - l), (g = a * u), h >= 0))
				if (d >= -g)
					if (d <= g) {
						const m = 1 / u;
						(h *= m),
						(d *= m),
						(p =
                                h * (h + s * d + 2 * o) +
                                d * (s * h + d + 2 * l) +
                                c);
					} else
						(d = a),
						(h = Math.max(0, -(s * d + o))),
						(p = -h * h + d * (d + 2 * l) + c);
				else
					(d = -a),
					(h = Math.max(0, -(s * d + o))),
					(p = -h * h + d * (d + 2 * l) + c);
			else
				d <= -g
					? ((h = Math.max(0, -(-s * a + o))),
					(d = h > 0 ? -a : Math.min(Math.max(-a, -l), a)),
					(p = -h * h + d * (d + 2 * l) + c))
					: d <= g
						? ((h = 0),
						(d = Math.min(Math.max(-a, -l), a)),
						(p = d * (d + 2 * l) + c))
						: ((h = Math.max(0, -(s * a + o))),
						(d = h > 0 ? a : Math.min(Math.max(-a, -l), a)),
						(p = -h * h + d * (d + 2 * l) + c));
		else
			(d = s > 0 ? -a : a),
			(h = Math.max(0, -(s * d + o))),
			(p = -h * h + d * (d + 2 * l) + c);
		return (
			i && i.copy(this.direction).multiplyScalar(h).add(this.origin),
			n && n.copy(Ws).multiplyScalar(d).add(Bl),
			p
		);
	}
	intersectSphere(e, t) {
		Br.subVectors(e.center, this.origin);
		const i = Br.dot(this.direction),
			n = Br.dot(Br) - i * i,
			a = e.radius * e.radius;
		if (n > a) return null;
		const s = Math.sqrt(a - n),
			o = i - s,
			l = i + s;
		return o < 0 && l < 0 ? null : o < 0 ? this.at(l, t) : this.at(o, t);
	}
	intersectsSphere(e) {
		return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
	}
	distanceToPlane(e) {
		const t = e.normal.dot(this.direction);
		if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
		const i = -(this.origin.dot(e.normal) + e.constant) / t;
		return i >= 0 ? i : null;
	}
	intersectPlane(e, t) {
		const i = this.distanceToPlane(e);
		return i === null ? null : this.at(i, t);
	}
	intersectsPlane(e) {
		const t = e.distanceToPoint(this.origin);
		return t === 0 || e.normal.dot(this.direction) * t < 0;
	}
	intersectBox(e, t) {
		let i, n, a, s, o, l;
		const c = 1 / this.direction.x,
			u = 1 / this.direction.y,
			h = 1 / this.direction.z,
			d = this.origin;
		return (
			c >= 0
				? ((i = (e.min.x - d.x) * c), (n = (e.max.x - d.x) * c))
				: ((i = (e.max.x - d.x) * c), (n = (e.min.x - d.x) * c)),
			u >= 0
				? ((a = (e.min.y - d.y) * u), (s = (e.max.y - d.y) * u))
				: ((a = (e.max.y - d.y) * u), (s = (e.min.y - d.y) * u)),
			i > s ||
            a > n ||
            ((a > i || i !== i) && (i = a),
            (s < n || n !== n) && (n = s),
            h >= 0
            	? ((o = (e.min.z - d.z) * h), (l = (e.max.z - d.z) * h))
            	: ((o = (e.max.z - d.z) * h), (l = (e.min.z - d.z) * h)),
            i > l || o > n) ||
            ((o > i || i !== i) && (i = o),
            (l < n || n !== n) && (n = l),
            n < 0)
				? null
				: this.at(i >= 0 ? i : n, t)
		);
	}
	intersectsBox(e) {
		return this.intersectBox(e, Br) !== null;
	}
	intersectTriangle(e, t, i, n, a) {
		Fl.subVectors(t, e), js.subVectors(i, e), Hl.crossVectors(Fl, js);
		let s = this.direction.dot(Hl),
			o;
		if (s > 0) {
			if (n) return null;
			o = 1;
		} else if (s < 0) (o = -1), (s = -s);
		else return null;
		ci.subVectors(this.origin, e);
		const l = o * this.direction.dot(js.crossVectors(ci, js));
		if (l < 0) return null;
		const c = o * this.direction.dot(Fl.cross(ci));
		if (c < 0 || l + c > s) return null;
		const u = -o * ci.dot(Hl);
		return u < 0 ? null : this.at(u / s, a);
	}
	applyMatrix4(e) {
		return (
			this.origin.applyMatrix4(e),
			this.direction.transformDirection(e),
			this
		);
	}
	equals(e) {
		return (
			e.origin.equals(this.origin) && e.direction.equals(this.direction)
		);
	}
	clone() {
		return new this.constructor().copy(this);
	}
}
class Pe {
	constructor() {
		(this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
		arguments.length > 0 &&
                console.error(
                	'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.'
                );
	}
	set(e, t, i, n, a, s, o, l, c, u, h, d, p, g, m, f) {
		const v = this.elements;
		return (
			(v[0] = e),
			(v[4] = t),
			(v[8] = i),
			(v[12] = n),
			(v[1] = a),
			(v[5] = s),
			(v[9] = o),
			(v[13] = l),
			(v[2] = c),
			(v[6] = u),
			(v[10] = h),
			(v[14] = d),
			(v[3] = p),
			(v[7] = g),
			(v[11] = m),
			(v[15] = f),
			this
		);
	}
	identity() {
		return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
	}
	clone() {
		return new Pe().fromArray(this.elements);
	}
	copy(e) {
		const t = this.elements,
			i = e.elements;
		return (
			(t[0] = i[0]),
			(t[1] = i[1]),
			(t[2] = i[2]),
			(t[3] = i[3]),
			(t[4] = i[4]),
			(t[5] = i[5]),
			(t[6] = i[6]),
			(t[7] = i[7]),
			(t[8] = i[8]),
			(t[9] = i[9]),
			(t[10] = i[10]),
			(t[11] = i[11]),
			(t[12] = i[12]),
			(t[13] = i[13]),
			(t[14] = i[14]),
			(t[15] = i[15]),
			this
		);
	}
	copyPosition(e) {
		const t = this.elements,
			i = e.elements;
		return (t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this;
	}
	setFromMatrix3(e) {
		const t = e.elements;
		return (
			this.set(
				t[0],
				t[3],
				t[6],
				0,
				t[1],
				t[4],
				t[7],
				0,
				t[2],
				t[5],
				t[8],
				0,
				0,
				0,
				0,
				1
			),
			this
		);
	}
	extractBasis(e, t, i) {
		return (
			e.setFromMatrixColumn(this, 0),
			t.setFromMatrixColumn(this, 1),
			i.setFromMatrixColumn(this, 2),
			this
		);
	}
	makeBasis(e, t, i) {
		return (
			this.set(
				e.x,
				t.x,
				i.x,
				0,
				e.y,
				t.y,
				i.y,
				0,
				e.z,
				t.z,
				i.z,
				0,
				0,
				0,
				0,
				1
			),
			this
		);
	}
	extractRotation(e) {
		const t = this.elements,
			i = e.elements,
			n = 1 / Sn.setFromMatrixColumn(e, 0).length(),
			a = 1 / Sn.setFromMatrixColumn(e, 1).length(),
			s = 1 / Sn.setFromMatrixColumn(e, 2).length();
		return (
			(t[0] = i[0] * n),
			(t[1] = i[1] * n),
			(t[2] = i[2] * n),
			(t[3] = 0),
			(t[4] = i[4] * a),
			(t[5] = i[5] * a),
			(t[6] = i[6] * a),
			(t[7] = 0),
			(t[8] = i[8] * s),
			(t[9] = i[9] * s),
			(t[10] = i[10] * s),
			(t[11] = 0),
			(t[12] = 0),
			(t[13] = 0),
			(t[14] = 0),
			(t[15] = 1),
			this
		);
	}
	makeRotationFromEuler(e) {
		(e && e.isEuler) ||
            console.error(
            	'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.'
            );
		const t = this.elements,
			i = e.x,
			n = e.y,
			a = e.z,
			s = Math.cos(i),
			o = Math.sin(i),
			l = Math.cos(n),
			c = Math.sin(n),
			u = Math.cos(a),
			h = Math.sin(a);
		if (e.order === 'XYZ') {
			const d = s * u,
				p = s * h,
				g = o * u,
				m = o * h;
			(t[0] = l * u),
			(t[4] = -l * h),
			(t[8] = c),
			(t[1] = p + g * c),
			(t[5] = d - m * c),
			(t[9] = -o * l),
			(t[2] = m - d * c),
			(t[6] = g + p * c),
			(t[10] = s * l);
		} else if (e.order === 'YXZ') {
			const d = l * u,
				p = l * h,
				g = c * u,
				m = c * h;
			(t[0] = d + m * o),
			(t[4] = g * o - p),
			(t[8] = s * c),
			(t[1] = s * h),
			(t[5] = s * u),
			(t[9] = -o),
			(t[2] = p * o - g),
			(t[6] = m + d * o),
			(t[10] = s * l);
		} else if (e.order === 'ZXY') {
			const d = l * u,
				p = l * h,
				g = c * u,
				m = c * h;
			(t[0] = d - m * o),
			(t[4] = -s * h),
			(t[8] = g + p * o),
			(t[1] = p + g * o),
			(t[5] = s * u),
			(t[9] = m - d * o),
			(t[2] = -s * c),
			(t[6] = o),
			(t[10] = s * l);
		} else if (e.order === 'ZYX') {
			const d = s * u,
				p = s * h,
				g = o * u,
				m = o * h;
			(t[0] = l * u),
			(t[4] = g * c - p),
			(t[8] = d * c + m),
			(t[1] = l * h),
			(t[5] = m * c + d),
			(t[9] = p * c - g),
			(t[2] = -c),
			(t[6] = o * l),
			(t[10] = s * l);
		} else if (e.order === 'YZX') {
			const d = s * l,
				p = s * c,
				g = o * l,
				m = o * c;
			(t[0] = l * u),
			(t[4] = m - d * h),
			(t[8] = g * h + p),
			(t[1] = h),
			(t[5] = s * u),
			(t[9] = -o * u),
			(t[2] = -c * u),
			(t[6] = p * h + g),
			(t[10] = d - m * h);
		} else if (e.order === 'XZY') {
			const d = s * l,
				p = s * c,
				g = o * l,
				m = o * c;
			(t[0] = l * u),
			(t[4] = -h),
			(t[8] = c * u),
			(t[1] = d * h + m),
			(t[5] = s * u),
			(t[9] = p * h - g),
			(t[2] = g * h - p),
			(t[6] = o * u),
			(t[10] = m * h + d);
		}
		return (
			(t[3] = 0),
			(t[7] = 0),
			(t[11] = 0),
			(t[12] = 0),
			(t[13] = 0),
			(t[14] = 0),
			(t[15] = 1),
			this
		);
	}
	makeRotationFromQuaternion(e) {
		return this.compose(xb, e, bb);
	}
	lookAt(e, t, i) {
		const n = this.elements;
		return (
			Vt.subVectors(e, t),
			Vt.lengthSq() === 0 && (Vt.z = 1),
			Vt.normalize(),
			ui.crossVectors(i, Vt),
			ui.lengthSq() === 0 &&
                (Math.abs(i.z) === 1 ? (Vt.x += 1e-4) : (Vt.z += 1e-4),
                Vt.normalize(),
                ui.crossVectors(i, Vt)),
			ui.normalize(),
			Xs.crossVectors(Vt, ui),
			(n[0] = ui.x),
			(n[4] = Xs.x),
			(n[8] = Vt.x),
			(n[1] = ui.y),
			(n[5] = Xs.y),
			(n[9] = Vt.y),
			(n[2] = ui.z),
			(n[6] = Xs.z),
			(n[10] = Vt.z),
			this
		);
	}
	multiply(e, t) {
		return t !== void 0
			? (console.warn(
				'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.'
			),
			this.multiplyMatrices(e, t))
			: this.multiplyMatrices(this, e);
	}
	premultiply(e) {
		return this.multiplyMatrices(e, this);
	}
	multiplyMatrices(e, t) {
		const i = e.elements,
			n = t.elements,
			a = this.elements,
			s = i[0],
			o = i[4],
			l = i[8],
			c = i[12],
			u = i[1],
			h = i[5],
			d = i[9],
			p = i[13],
			g = i[2],
			m = i[6],
			f = i[10],
			v = i[14],
			x = i[3],
			A = i[7],
			S = i[11],
			M = i[15],
			I = n[0],
			D = n[4],
			G = n[8],
			re = n[12],
			B = n[1],
			b = n[5],
			E = n[9],
			j = n[13],
			z = n[2],
			V = n[6],
			H = n[10],
			k = n[14],
			P = n[3],
			Z = n[7],
			J = n[11],
			fe = n[15];
		return (
			(a[0] = s * I + o * B + l * z + c * P),
			(a[4] = s * D + o * b + l * V + c * Z),
			(a[8] = s * G + o * E + l * H + c * J),
			(a[12] = s * re + o * j + l * k + c * fe),
			(a[1] = u * I + h * B + d * z + p * P),
			(a[5] = u * D + h * b + d * V + p * Z),
			(a[9] = u * G + h * E + d * H + p * J),
			(a[13] = u * re + h * j + d * k + p * fe),
			(a[2] = g * I + m * B + f * z + v * P),
			(a[6] = g * D + m * b + f * V + v * Z),
			(a[10] = g * G + m * E + f * H + v * J),
			(a[14] = g * re + m * j + f * k + v * fe),
			(a[3] = x * I + A * B + S * z + M * P),
			(a[7] = x * D + A * b + S * V + M * Z),
			(a[11] = x * G + A * E + S * H + M * J),
			(a[15] = x * re + A * j + S * k + M * fe),
			this
		);
	}
	multiplyScalar(e) {
		const t = this.elements;
		return (
			(t[0] *= e),
			(t[4] *= e),
			(t[8] *= e),
			(t[12] *= e),
			(t[1] *= e),
			(t[5] *= e),
			(t[9] *= e),
			(t[13] *= e),
			(t[2] *= e),
			(t[6] *= e),
			(t[10] *= e),
			(t[14] *= e),
			(t[3] *= e),
			(t[7] *= e),
			(t[11] *= e),
			(t[15] *= e),
			this
		);
	}
	determinant() {
		const e = this.elements,
			t = e[0],
			i = e[4],
			n = e[8],
			a = e[12],
			s = e[1],
			o = e[5],
			l = e[9],
			c = e[13],
			u = e[2],
			h = e[6],
			d = e[10],
			p = e[14],
			g = e[3],
			m = e[7],
			f = e[11],
			v = e[15];
		return (
			g *
                (+a * l * h -
                    n * c * h -
                    a * o * d +
                    i * c * d +
                    n * o * p -
                    i * l * p) +
            m *
                (+t * l * p -
                    t * c * d +
                    a * s * d -
                    n * s * p +
                    n * c * u -
                    a * l * u) +
            f *
                (+t * c * h -
                    t * o * p -
                    a * s * h +
                    i * s * p +
                    a * o * u -
                    i * c * u) +
            v *
                (-n * o * u -
                    t * l * h +
                    t * o * d +
                    n * s * h -
                    i * s * d +
                    i * l * u)
		);
	}
	transpose() {
		const e = this.elements;
		let t;
		return (
			(t = e[1]),
			(e[1] = e[4]),
			(e[4] = t),
			(t = e[2]),
			(e[2] = e[8]),
			(e[8] = t),
			(t = e[6]),
			(e[6] = e[9]),
			(e[9] = t),
			(t = e[3]),
			(e[3] = e[12]),
			(e[12] = t),
			(t = e[7]),
			(e[7] = e[13]),
			(e[13] = t),
			(t = e[11]),
			(e[11] = e[14]),
			(e[14] = t),
			this
		);
	}
	setPosition(e, t, i) {
		const n = this.elements;
		return (
			e.isVector3
				? ((n[12] = e.x), (n[13] = e.y), (n[14] = e.z))
				: ((n[12] = e), (n[13] = t), (n[14] = i)),
			this
		);
	}
	invert() {
		const e = this.elements,
			t = e[0],
			i = e[1],
			n = e[2],
			a = e[3],
			s = e[4],
			o = e[5],
			l = e[6],
			c = e[7],
			u = e[8],
			h = e[9],
			d = e[10],
			p = e[11],
			g = e[12],
			m = e[13],
			f = e[14],
			v = e[15],
			x =
                h * f * c -
                m * d * c +
                m * l * p -
                o * f * p -
                h * l * v +
                o * d * v,
			A =
                g * d * c -
                u * f * c -
                g * l * p +
                s * f * p +
                u * l * v -
                s * d * v,
			S =
                u * m * c -
                g * h * c +
                g * o * p -
                s * m * p -
                u * o * v +
                s * h * v,
			M =
                g * h * l -
                u * m * l -
                g * o * d +
                s * m * d +
                u * o * f -
                s * h * f,
			I = t * x + i * A + n * S + a * M;
		if (I === 0)
			return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
		const D = 1 / I;
		return (
			(e[0] = x * D),
			(e[1] =
                (m * d * a -
                    h * f * a -
                    m * n * p +
                    i * f * p +
                    h * n * v -
                    i * d * v) *
                D),
			(e[2] =
                (o * f * a -
                    m * l * a +
                    m * n * c -
                    i * f * c -
                    o * n * v +
                    i * l * v) *
                D),
			(e[3] =
                (h * l * a -
                    o * d * a -
                    h * n * c +
                    i * d * c +
                    o * n * p -
                    i * l * p) *
                D),
			(e[4] = A * D),
			(e[5] =
                (u * f * a -
                    g * d * a +
                    g * n * p -
                    t * f * p -
                    u * n * v +
                    t * d * v) *
                D),
			(e[6] =
                (g * l * a -
                    s * f * a -
                    g * n * c +
                    t * f * c +
                    s * n * v -
                    t * l * v) *
                D),
			(e[7] =
                (s * d * a -
                    u * l * a +
                    u * n * c -
                    t * d * c -
                    s * n * p +
                    t * l * p) *
                D),
			(e[8] = S * D),
			(e[9] =
                (g * h * a -
                    u * m * a -
                    g * i * p +
                    t * m * p +
                    u * i * v -
                    t * h * v) *
                D),
			(e[10] =
                (s * m * a -
                    g * o * a +
                    g * i * c -
                    t * m * c -
                    s * i * v +
                    t * o * v) *
                D),
			(e[11] =
                (u * o * a -
                    s * h * a -
                    u * i * c +
                    t * h * c +
                    s * i * p -
                    t * o * p) *
                D),
			(e[12] = M * D),
			(e[13] =
                (u * m * n -
                    g * h * n +
                    g * i * d -
                    t * m * d -
                    u * i * f +
                    t * h * f) *
                D),
			(e[14] =
                (g * o * n -
                    s * m * n -
                    g * i * l +
                    t * m * l +
                    s * i * f -
                    t * o * f) *
                D),
			(e[15] =
                (s * h * n -
                    u * o * n +
                    u * i * l -
                    t * h * l -
                    s * i * d +
                    t * o * d) *
                D),
			this
		);
	}
	scale(e) {
		const t = this.elements,
			i = e.x,
			n = e.y,
			a = e.z;
		return (
			(t[0] *= i),
			(t[4] *= n),
			(t[8] *= a),
			(t[1] *= i),
			(t[5] *= n),
			(t[9] *= a),
			(t[2] *= i),
			(t[6] *= n),
			(t[10] *= a),
			(t[3] *= i),
			(t[7] *= n),
			(t[11] *= a),
			this
		);
	}
	getMaxScaleOnAxis() {
		const e = this.elements,
			t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
			i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
			n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
		return Math.sqrt(Math.max(t, i, n));
	}
	makeTranslation(e, t, i) {
		return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this;
	}
	makeRotationX(e) {
		const t = Math.cos(e),
			i = Math.sin(e);
		return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
	}
	makeRotationY(e) {
		const t = Math.cos(e),
			i = Math.sin(e);
		return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
	}
	makeRotationZ(e) {
		const t = Math.cos(e),
			i = Math.sin(e);
		return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
	}
	makeRotationAxis(e, t) {
		const i = Math.cos(t),
			n = Math.sin(t),
			a = 1 - i,
			s = e.x,
			o = e.y,
			l = e.z,
			c = a * s,
			u = a * o;
		return (
			this.set(
				c * s + i,
				c * o - n * l,
				c * l + n * o,
				0,
				c * o + n * l,
				u * o + i,
				u * l - n * s,
				0,
				c * l - n * o,
				u * l + n * s,
				a * l * l + i,
				0,
				0,
				0,
				0,
				1
			),
			this
		);
	}
	makeScale(e, t, i) {
		return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
	}
	makeShear(e, t, i, n, a, s) {
		return this.set(1, i, a, 0, e, 1, s, 0, t, n, 1, 0, 0, 0, 0, 1), this;
	}
	compose(e, t, i) {
		const n = this.elements,
			a = t._x,
			s = t._y,
			o = t._z,
			l = t._w,
			c = a + a,
			u = s + s,
			h = o + o,
			d = a * c,
			p = a * u,
			g = a * h,
			m = s * u,
			f = s * h,
			v = o * h,
			x = l * c,
			A = l * u,
			S = l * h,
			M = i.x,
			I = i.y,
			D = i.z;
		return (
			(n[0] = (1 - (m + v)) * M),
			(n[1] = (p + S) * M),
			(n[2] = (g - A) * M),
			(n[3] = 0),
			(n[4] = (p - S) * I),
			(n[5] = (1 - (d + v)) * I),
			(n[6] = (f + x) * I),
			(n[7] = 0),
			(n[8] = (g + A) * D),
			(n[9] = (f - x) * D),
			(n[10] = (1 - (d + m)) * D),
			(n[11] = 0),
			(n[12] = e.x),
			(n[13] = e.y),
			(n[14] = e.z),
			(n[15] = 1),
			this
		);
	}
	decompose(e, t, i) {
		const n = this.elements;
		let a = Sn.set(n[0], n[1], n[2]).length();
		const s = Sn.set(n[4], n[5], n[6]).length(),
			o = Sn.set(n[8], n[9], n[10]).length();
		this.determinant() < 0 && (a = -a),
		(e.x = n[12]),
		(e.y = n[13]),
		(e.z = n[14]),
		hr.copy(this);
		const l = 1 / a,
			c = 1 / s,
			u = 1 / o;
		return (
			(hr.elements[0] *= l),
			(hr.elements[1] *= l),
			(hr.elements[2] *= l),
			(hr.elements[4] *= c),
			(hr.elements[5] *= c),
			(hr.elements[6] *= c),
			(hr.elements[8] *= u),
			(hr.elements[9] *= u),
			(hr.elements[10] *= u),
			t.setFromRotationMatrix(hr),
			(i.x = a),
			(i.y = s),
			(i.z = o),
			this
		);
	}
	makePerspective(e, t, i, n, a, s) {
		s === void 0 &&
            console.warn(
            	'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.'
            );
		const o = this.elements,
			l = (2 * a) / (t - e),
			c = (2 * a) / (i - n),
			u = (t + e) / (t - e),
			h = (i + n) / (i - n),
			d = -(s + a) / (s - a),
			p = (-2 * s * a) / (s - a);
		return (
			(o[0] = l),
			(o[4] = 0),
			(o[8] = u),
			(o[12] = 0),
			(o[1] = 0),
			(o[5] = c),
			(o[9] = h),
			(o[13] = 0),
			(o[2] = 0),
			(o[6] = 0),
			(o[10] = d),
			(o[14] = p),
			(o[3] = 0),
			(o[7] = 0),
			(o[11] = -1),
			(o[15] = 0),
			this
		);
	}
	makeOrthographic(e, t, i, n, a, s) {
		const o = this.elements,
			l = 1 / (t - e),
			c = 1 / (i - n),
			u = 1 / (s - a),
			h = (t + e) * l,
			d = (i + n) * c,
			p = (s + a) * u;
		return (
			(o[0] = 2 * l),
			(o[4] = 0),
			(o[8] = 0),
			(o[12] = -h),
			(o[1] = 0),
			(o[5] = 2 * c),
			(o[9] = 0),
			(o[13] = -d),
			(o[2] = 0),
			(o[6] = 0),
			(o[10] = -2 * u),
			(o[14] = -p),
			(o[3] = 0),
			(o[7] = 0),
			(o[11] = 0),
			(o[15] = 1),
			this
		);
	}
	equals(e) {
		const t = this.elements,
			i = e.elements;
		for (let n = 0; n < 16; n++) if (t[n] !== i[n]) return !1;
		return !0;
	}
	fromArray(e, t = 0) {
		for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
		return this;
	}
	toArray(e = [], t = 0) {
		const i = this.elements;
		return (
			(e[t] = i[0]),
			(e[t + 1] = i[1]),
			(e[t + 2] = i[2]),
			(e[t + 3] = i[3]),
			(e[t + 4] = i[4]),
			(e[t + 5] = i[5]),
			(e[t + 6] = i[6]),
			(e[t + 7] = i[7]),
			(e[t + 8] = i[8]),
			(e[t + 9] = i[9]),
			(e[t + 10] = i[10]),
			(e[t + 11] = i[11]),
			(e[t + 12] = i[12]),
			(e[t + 13] = i[13]),
			(e[t + 14] = i[14]),
			(e[t + 15] = i[15]),
			e
		);
	}
}
Pe.prototype.isMatrix4 = !0;
const Sn = new C(),
	hr = new Pe(),
	xb = new C(0, 0, 0),
	bb = new C(1, 1, 1),
	ui = new C(),
	Xs = new C(),
	Vt = new C(),
	Od = new Pe(),
	Nd = new Ct();
class pn {
	constructor(e = 0, t = 0, i = 0, n = pn.DefaultOrder) {
		(this._x = e), (this._y = t), (this._z = i), (this._order = n);
	}
	get x() {
		return this._x;
	}
	set x(e) {
		(this._x = e), this._onChangeCallback();
	}
	get y() {
		return this._y;
	}
	set y(e) {
		(this._y = e), this._onChangeCallback();
	}
	get z() {
		return this._z;
	}
	set z(e) {
		(this._z = e), this._onChangeCallback();
	}
	get order() {
		return this._order;
	}
	set order(e) {
		(this._order = e), this._onChangeCallback();
	}
	set(e, t, i, n = this._order) {
		return (
			(this._x = e),
			(this._y = t),
			(this._z = i),
			(this._order = n),
			this._onChangeCallback(),
			this
		);
	}
	clone() {
		return new this.constructor(this._x, this._y, this._z, this._order);
	}
	copy(e) {
		return (
			(this._x = e._x),
			(this._y = e._y),
			(this._z = e._z),
			(this._order = e._order),
			this._onChangeCallback(),
			this
		);
	}
	setFromRotationMatrix(e, t = this._order, i = !0) {
		const n = e.elements,
			a = n[0],
			s = n[4],
			o = n[8],
			l = n[1],
			c = n[5],
			u = n[9],
			h = n[2],
			d = n[6],
			p = n[10];
		switch (t) {
		case 'XYZ':
			(this._y = Math.asin(Et(o, -1, 1))),
			Math.abs(o) < 0.9999999
				? ((this._x = Math.atan2(-u, p)),
				(this._z = Math.atan2(-s, a)))
				: ((this._x = Math.atan2(d, c)), (this._z = 0));
			break;
		case 'YXZ':
			(this._x = Math.asin(-Et(u, -1, 1))),
			Math.abs(u) < 0.9999999
				? ((this._y = Math.atan2(o, p)),
				(this._z = Math.atan2(l, c)))
				: ((this._y = Math.atan2(-h, a)), (this._z = 0));
			break;
		case 'ZXY':
			(this._x = Math.asin(Et(d, -1, 1))),
			Math.abs(d) < 0.9999999
				? ((this._y = Math.atan2(-h, p)),
				(this._z = Math.atan2(-s, c)))
				: ((this._y = 0), (this._z = Math.atan2(l, a)));
			break;
		case 'ZYX':
			(this._y = Math.asin(-Et(h, -1, 1))),
			Math.abs(h) < 0.9999999
				? ((this._x = Math.atan2(d, p)),
				(this._z = Math.atan2(l, a)))
				: ((this._x = 0), (this._z = Math.atan2(-s, c)));
			break;
		case 'YZX':
			(this._z = Math.asin(Et(l, -1, 1))),
			Math.abs(l) < 0.9999999
				? ((this._x = Math.atan2(-u, c)),
				(this._y = Math.atan2(-h, a)))
				: ((this._x = 0), (this._y = Math.atan2(o, p)));
			break;
		case 'XZY':
			(this._z = Math.asin(-Et(s, -1, 1))),
			Math.abs(s) < 0.9999999
				? ((this._x = Math.atan2(d, c)),
				(this._y = Math.atan2(o, a)))
				: ((this._x = Math.atan2(-u, p)), (this._y = 0));
			break;
		default:
			console.warn(
				'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' +
                        t
			);
		}
		return (this._order = t), i === !0 && this._onChangeCallback(), this;
	}
	setFromQuaternion(e, t, i) {
		return (
			Od.makeRotationFromQuaternion(e),
			this.setFromRotationMatrix(Od, t, i)
		);
	}
	setFromVector3(e, t = this._order) {
		return this.set(e.x, e.y, e.z, t);
	}
	reorder(e) {
		return Nd.setFromEuler(this), this.setFromQuaternion(Nd, e);
	}
	equals(e) {
		return (
			e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._order === this._order
		);
	}
	fromArray(e) {
		return (
			(this._x = e[0]),
			(this._y = e[1]),
			(this._z = e[2]),
			e[3] !== void 0 && (this._order = e[3]),
			this._onChangeCallback(),
			this
		);
	}
	toArray(e = [], t = 0) {
		return (
			(e[t] = this._x),
			(e[t + 1] = this._y),
			(e[t + 2] = this._z),
			(e[t + 3] = this._order),
			e
		);
	}
	_onChange(e) {
		return (this._onChangeCallback = e), this;
	}
	_onChangeCallback() {}
}
pn.prototype.isEuler = !0;
pn.DefaultOrder = 'XYZ';
pn.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];
class Of {
	constructor() {
		this.mask = 1;
	}
	set(e) {
		this.mask = ((1 << e) | 0) >>> 0;
	}
	enable(e) {
		this.mask |= (1 << e) | 0;
	}
	enableAll() {
		this.mask = -1;
	}
	toggle(e) {
		this.mask ^= (1 << e) | 0;
	}
	disable(e) {
		this.mask &= ~((1 << e) | 0);
	}
	disableAll() {
		this.mask = 0;
	}
	test(e) {
		return (this.mask & e.mask) !== 0;
	}
	isEnabled(e) {
		return (this.mask & ((1 << e) | 0)) !== 0;
	}
}
let wb = 0;
const zd = new C(),
	Tn = new Ct(),
	Fr = new Pe(),
	qs = new C(),
	Oa = new C(),
	_b = new C(),
	Mb = new Ct(),
	Ud = new C(1, 0, 0),
	Bd = new C(0, 1, 0),
	Fd = new C(0, 0, 1),
	Sb = { type: 'added' },
	Hd = { type: 'removed' };
class Je extends Di {
	constructor() {
		super(),
		Object.defineProperty(this, 'id', { value: wb++ }),
		(this.uuid = ir()),
		(this.name = ''),
		(this.type = 'Object3D'),
		(this.parent = null),
		(this.children = []),
		(this.up = Je.DefaultUp.clone());
		const e = new C(),
			t = new pn(),
			i = new Ct(),
			n = new C(1, 1, 1);
		function a() {
			i.setFromEuler(t, !1);
		}
		function s() {
			t.setFromQuaternion(i, void 0, !1);
		}
		t._onChange(a),
		i._onChange(s),
		Object.defineProperties(this, {
			position: { configurable: !0, enumerable: !0, value: e },
			rotation: { configurable: !0, enumerable: !0, value: t },
			quaternion: { configurable: !0, enumerable: !0, value: i },
			scale: { configurable: !0, enumerable: !0, value: n },
			modelViewMatrix: { value: new Pe() },
			normalMatrix: { value: new kt() }
		}),
		(this.matrix = new Pe()),
		(this.matrixWorld = new Pe()),
		(this.matrixAutoUpdate = Je.DefaultMatrixAutoUpdate),
		(this.matrixWorldNeedsUpdate = !1),
		(this.layers = new Of()),
		(this.visible = !0),
		(this.castShadow = !1),
		(this.receiveShadow = !1),
		(this.frustumCulled = !0),
		(this.renderOrder = 0),
		(this.animations = []),
		(this.userData = {});
	}
	onBeforeRender() {}
	onAfterRender() {}
	applyMatrix4(e) {
		this.matrixAutoUpdate && this.updateMatrix(),
		this.matrix.premultiply(e),
		this.matrix.decompose(this.position, this.quaternion, this.scale);
	}
	applyQuaternion(e) {
		return this.quaternion.premultiply(e), this;
	}
	setRotationFromAxisAngle(e, t) {
		this.quaternion.setFromAxisAngle(e, t);
	}
	setRotationFromEuler(e) {
		this.quaternion.setFromEuler(e, !0);
	}
	setRotationFromMatrix(e) {
		this.quaternion.setFromRotationMatrix(e);
	}
	setRotationFromQuaternion(e) {
		this.quaternion.copy(e);
	}
	rotateOnAxis(e, t) {
		return Tn.setFromAxisAngle(e, t), this.quaternion.multiply(Tn), this;
	}
	rotateOnWorldAxis(e, t) {
		return Tn.setFromAxisAngle(e, t), this.quaternion.premultiply(Tn), this;
	}
	rotateX(e) {
		return this.rotateOnAxis(Ud, e);
	}
	rotateY(e) {
		return this.rotateOnAxis(Bd, e);
	}
	rotateZ(e) {
		return this.rotateOnAxis(Fd, e);
	}
	translateOnAxis(e, t) {
		return (
			zd.copy(e).applyQuaternion(this.quaternion),
			this.position.add(zd.multiplyScalar(t)),
			this
		);
	}
	translateX(e) {
		return this.translateOnAxis(Ud, e);
	}
	translateY(e) {
		return this.translateOnAxis(Bd, e);
	}
	translateZ(e) {
		return this.translateOnAxis(Fd, e);
	}
	localToWorld(e) {
		return e.applyMatrix4(this.matrixWorld);
	}
	worldToLocal(e) {
		return e.applyMatrix4(Fr.copy(this.matrixWorld).invert());
	}
	lookAt(e, t, i) {
		e.isVector3 ? qs.copy(e) : qs.set(e, t, i);
		const n = this.parent;
		this.updateWorldMatrix(!0, !1),
		Oa.setFromMatrixPosition(this.matrixWorld),
		this.isCamera || this.isLight
			? Fr.lookAt(Oa, qs, this.up)
			: Fr.lookAt(qs, Oa, this.up),
		this.quaternion.setFromRotationMatrix(Fr),
		n &&
                (Fr.extractRotation(n.matrixWorld),
                Tn.setFromRotationMatrix(Fr),
                this.quaternion.premultiply(Tn.invert()));
	}
	add(e) {
		if (arguments.length > 1) {
			for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
			return this;
		}
		return e === this
			? (console.error(
				'THREE.Object3D.add: object can\'t be added as a child of itself.',
				e
			),
			this)
			: (e && e.isObject3D
				? (e.parent !== null && e.parent.remove(e),
				(e.parent = this),
				this.children.push(e),
				e.dispatchEvent(Sb))
				: console.error(
					'THREE.Object3D.add: object not an instance of THREE.Object3D.',
					e
				),
			this);
	}
	remove(e) {
		if (arguments.length > 1) {
			for (let i = 0; i < arguments.length; i++)
				this.remove(arguments[i]);
			return this;
		}
		const t = this.children.indexOf(e);
		return (
			t !== -1 &&
                ((e.parent = null),
                this.children.splice(t, 1),
                e.dispatchEvent(Hd)),
			this
		);
	}
	removeFromParent() {
		const e = this.parent;
		return e !== null && e.remove(this), this;
	}
	clear() {
		for (let e = 0; e < this.children.length; e++) {
			const t = this.children[e];
			(t.parent = null), t.dispatchEvent(Hd);
		}
		return (this.children.length = 0), this;
	}
	attach(e) {
		return (
			this.updateWorldMatrix(!0, !1),
			Fr.copy(this.matrixWorld).invert(),
			e.parent !== null &&
                (e.parent.updateWorldMatrix(!0, !1),
                Fr.multiply(e.parent.matrixWorld)),
			e.applyMatrix4(Fr),
			this.add(e),
			e.updateWorldMatrix(!1, !0),
			this
		);
	}
	getObjectById(e) {
		return this.getObjectByProperty('id', e);
	}
	getObjectByName(e) {
		return this.getObjectByProperty('name', e);
	}
	getObjectByProperty(e, t) {
		if (this[e] === t) return this;
		for (let i = 0, n = this.children.length; i < n; i++) {
			const a = this.children[i].getObjectByProperty(e, t);
			if (a !== void 0) return a;
		}
	}
	getWorldPosition(e) {
		return (
			this.updateWorldMatrix(!0, !1),
			e.setFromMatrixPosition(this.matrixWorld)
		);
	}
	getWorldQuaternion(e) {
		return (
			this.updateWorldMatrix(!0, !1),
			this.matrixWorld.decompose(Oa, e, _b),
			e
		);
	}
	getWorldScale(e) {
		return (
			this.updateWorldMatrix(!0, !1),
			this.matrixWorld.decompose(Oa, Mb, e),
			e
		);
	}
	getWorldDirection(e) {
		this.updateWorldMatrix(!0, !1);
		const t = this.matrixWorld.elements;
		return e.set(t[8], t[9], t[10]).normalize();
	}
	raycast() {}
	traverse(e) {
		e(this);
		const t = this.children;
		for (let i = 0, n = t.length; i < n; i++) t[i].traverse(e);
	}
	traverseVisible(e) {
		if (this.visible === !1) return;
		e(this);
		const t = this.children;
		for (let i = 0, n = t.length; i < n; i++) t[i].traverseVisible(e);
	}
	traverseAncestors(e) {
		const t = this.parent;
		t !== null && (e(t), t.traverseAncestors(e));
	}
	updateMatrix() {
		this.matrix.compose(this.position, this.quaternion, this.scale),
		(this.matrixWorldNeedsUpdate = !0);
	}
	updateMatrixWorld(e) {
		this.matrixAutoUpdate && this.updateMatrix(),
		(this.matrixWorldNeedsUpdate || e) &&
                (this.parent === null
                	? this.matrixWorld.copy(this.matrix)
                	: this.matrixWorld.multiplyMatrices(
                		this.parent.matrixWorld,
                		this.matrix
                	),
                (this.matrixWorldNeedsUpdate = !1),
                (e = !0));
		const t = this.children;
		for (let i = 0, n = t.length; i < n; i++) t[i].updateMatrixWorld(e);
	}
	updateWorldMatrix(e, t) {
		const i = this.parent;
		if (
			(e === !0 && i !== null && i.updateWorldMatrix(!0, !1),
			this.matrixAutoUpdate && this.updateMatrix(),
			this.parent === null
				? this.matrixWorld.copy(this.matrix)
				: this.matrixWorld.multiplyMatrices(
					this.parent.matrixWorld,
					this.matrix
				),
			t === !0)
		) {
			const n = this.children;
			for (let a = 0, s = n.length; a < s; a++)
				n[a].updateWorldMatrix(!1, !0);
		}
	}
	toJSON(e) {
		const t = e === void 0 || typeof e == 'string',
			i = {};
		t &&
            ((e = {
            	geometries: {},
            	materials: {},
            	textures: {},
            	images: {},
            	shapes: {},
            	skeletons: {},
            	animations: {},
            	nodes: {}
            }),
            (i.metadata = {
            	version: 4.5,
            	type: 'Object',
            	generator: 'Object3D.toJSON'
            }));
		const n = {};
		(n.uuid = this.uuid),
		(n.type = this.type),
		this.name !== '' && (n.name = this.name),
		this.castShadow === !0 && (n.castShadow = !0),
		this.receiveShadow === !0 && (n.receiveShadow = !0),
		this.visible === !1 && (n.visible = !1),
		this.frustumCulled === !1 && (n.frustumCulled = !1),
		this.renderOrder !== 0 && (n.renderOrder = this.renderOrder),
		JSON.stringify(this.userData) !== '{}' &&
                (n.userData = this.userData),
		(n.layers = this.layers.mask),
		(n.matrix = this.matrix.toArray()),
		this.matrixAutoUpdate === !1 && (n.matrixAutoUpdate = !1),
		this.isInstancedMesh &&
                ((n.type = 'InstancedMesh'),
                (n.count = this.count),
                (n.instanceMatrix = this.instanceMatrix.toJSON()),
                this.instanceColor !== null &&
                    (n.instanceColor = this.instanceColor.toJSON()));
		function a(o, l) {
			return o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(e)), l.uuid;
		}
		if (this.isScene)
			this.background &&
                (this.background.isColor
                	? (n.background = this.background.toJSON())
                	: this.background.isTexture &&
                      (n.background = this.background.toJSON(e).uuid)),
			this.environment &&
                    this.environment.isTexture &&
                    (n.environment = this.environment.toJSON(e).uuid);
		else if (this.isMesh || this.isLine || this.isPoints) {
			n.geometry = a(e.geometries, this.geometry);
			const o = this.geometry.parameters;
			if (o !== void 0 && o.shapes !== void 0) {
				const l = o.shapes;
				if (Array.isArray(l))
					for (let c = 0, u = l.length; c < u; c++) {
						const h = l[c];
						a(e.shapes, h);
					}
				else a(e.shapes, l);
			}
		}
		if (
			(this.isSkinnedMesh &&
                ((n.bindMode = this.bindMode),
                (n.bindMatrix = this.bindMatrix.toArray()),
                this.skeleton !== void 0 &&
                    (a(e.skeletons, this.skeleton),
                    (n.skeleton = this.skeleton.uuid))),
			this.material !== void 0)
		)
			if (Array.isArray(this.material)) {
				const o = [];
				for (let l = 0, c = this.material.length; l < c; l++)
					o.push(a(e.materials, this.material[l]));
				n.material = o;
			} else n.material = a(e.materials, this.material);
		if (this.children.length > 0) {
			n.children = [];
			for (let o = 0; o < this.children.length; o++)
				n.children.push(this.children[o].toJSON(e).object);
		}
		if (this.animations.length > 0) {
			n.animations = [];
			for (let o = 0; o < this.animations.length; o++) {
				const l = this.animations[o];
				n.animations.push(a(e.animations, l));
			}
		}
		if (t) {
			const o = s(e.geometries),
				l = s(e.materials),
				c = s(e.textures),
				u = s(e.images),
				h = s(e.shapes),
				d = s(e.skeletons),
				p = s(e.animations),
				g = s(e.nodes);
			o.length > 0 && (i.geometries = o),
			l.length > 0 && (i.materials = l),
			c.length > 0 && (i.textures = c),
			u.length > 0 && (i.images = u),
			h.length > 0 && (i.shapes = h),
			d.length > 0 && (i.skeletons = d),
			p.length > 0 && (i.animations = p),
			g.length > 0 && (i.nodes = g);
		}
		return (i.object = n), i;
		function s(o) {
			const l = [];
			for (const c in o) {
				const u = o[c];
				delete u.metadata, l.push(u);
			}
			return l;
		}
	}
	clone(e) {
		return new this.constructor().copy(this, e);
	}
	copy(e, t = !0) {
		if (
			((this.name = e.name),
			this.up.copy(e.up),
			this.position.copy(e.position),
			(this.rotation.order = e.rotation.order),
			this.quaternion.copy(e.quaternion),
			this.scale.copy(e.scale),
			this.matrix.copy(e.matrix),
			this.matrixWorld.copy(e.matrixWorld),
			(this.matrixAutoUpdate = e.matrixAutoUpdate),
			(this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
			(this.layers.mask = e.layers.mask),
			(this.visible = e.visible),
			(this.castShadow = e.castShadow),
			(this.receiveShadow = e.receiveShadow),
			(this.frustumCulled = e.frustumCulled),
			(this.renderOrder = e.renderOrder),
			(this.userData = JSON.parse(JSON.stringify(e.userData))),
			t === !0)
		)
			for (let i = 0; i < e.children.length; i++) {
				const n = e.children[i];
				this.add(n.clone());
			}
		return this;
	}
}
Je.DefaultUp = new C(0, 1, 0);
Je.DefaultMatrixAutoUpdate = !0;
Je.prototype.isObject3D = !0;
const dr = new C(),
	Hr = new C(),
	Gl = new C(),
	Gr = new C(),
	En = new C(),
	An = new C(),
	Gd = new C(),
	Vl = new C(),
	Wl = new C(),
	jl = new C();
class vt {
	constructor(e = new C(), t = new C(), i = new C()) {
		(this.a = e), (this.b = t), (this.c = i);
	}
	static getNormal(e, t, i, n) {
		n.subVectors(i, t), dr.subVectors(e, t), n.cross(dr);
		const a = n.lengthSq();
		return a > 0 ? n.multiplyScalar(1 / Math.sqrt(a)) : n.set(0, 0, 0);
	}
	static getBarycoord(e, t, i, n, a) {
		dr.subVectors(n, t), Hr.subVectors(i, t), Gl.subVectors(e, t);
		const s = dr.dot(dr),
			o = dr.dot(Hr),
			l = dr.dot(Gl),
			c = Hr.dot(Hr),
			u = Hr.dot(Gl),
			h = s * c - o * o;
		if (h === 0) return a.set(-2, -1, -1);
		const d = 1 / h,
			p = (c * l - o * u) * d,
			g = (s * u - o * l) * d;
		return a.set(1 - p - g, g, p);
	}
	static containsPoint(e, t, i, n) {
		return (
			this.getBarycoord(e, t, i, n, Gr),
			Gr.x >= 0 && Gr.y >= 0 && Gr.x + Gr.y <= 1
		);
	}
	static getUV(e, t, i, n, a, s, o, l) {
		return (
			this.getBarycoord(e, t, i, n, Gr),
			l.set(0, 0),
			l.addScaledVector(a, Gr.x),
			l.addScaledVector(s, Gr.y),
			l.addScaledVector(o, Gr.z),
			l
		);
	}
	static isFrontFacing(e, t, i, n) {
		return (
			dr.subVectors(i, t), Hr.subVectors(e, t), dr.cross(Hr).dot(n) < 0
		);
	}
	set(e, t, i) {
		return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
	}
	setFromPointsAndIndices(e, t, i, n) {
		return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this;
	}
	setFromAttributeAndIndices(e, t, i, n) {
		return (
			this.a.fromBufferAttribute(e, t),
			this.b.fromBufferAttribute(e, i),
			this.c.fromBufferAttribute(e, n),
			this
		);
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(e) {
		return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
	}
	getArea() {
		return (
			dr.subVectors(this.c, this.b),
			Hr.subVectors(this.a, this.b),
			dr.cross(Hr).length() * 0.5
		);
	}
	getMidpoint(e) {
		return e
			.addVectors(this.a, this.b)
			.add(this.c)
			.multiplyScalar(1 / 3);
	}
	getNormal(e) {
		return vt.getNormal(this.a, this.b, this.c, e);
	}
	getPlane(e) {
		return e.setFromCoplanarPoints(this.a, this.b, this.c);
	}
	getBarycoord(e, t) {
		return vt.getBarycoord(e, this.a, this.b, this.c, t);
	}
	getUV(e, t, i, n, a) {
		return vt.getUV(e, this.a, this.b, this.c, t, i, n, a);
	}
	containsPoint(e) {
		return vt.containsPoint(e, this.a, this.b, this.c);
	}
	isFrontFacing(e) {
		return vt.isFrontFacing(this.a, this.b, this.c, e);
	}
	intersectsBox(e) {
		return e.intersectsTriangle(this);
	}
	closestPointToPoint(e, t) {
		const i = this.a,
			n = this.b,
			a = this.c;
		let s, o;
		En.subVectors(n, i), An.subVectors(a, i), Vl.subVectors(e, i);
		const l = En.dot(Vl),
			c = An.dot(Vl);
		if (l <= 0 && c <= 0) return t.copy(i);
		Wl.subVectors(e, n);
		const u = En.dot(Wl),
			h = An.dot(Wl);
		if (u >= 0 && h <= u) return t.copy(n);
		const d = l * h - u * c;
		if (d <= 0 && l >= 0 && u <= 0)
			return (s = l / (l - u)), t.copy(i).addScaledVector(En, s);
		jl.subVectors(e, a);
		const p = En.dot(jl),
			g = An.dot(jl);
		if (g >= 0 && p <= g) return t.copy(a);
		const m = p * c - l * g;
		if (m <= 0 && c >= 0 && g <= 0)
			return (o = c / (c - g)), t.copy(i).addScaledVector(An, o);
		const f = u * g - p * h;
		if (f <= 0 && h - u >= 0 && p - g >= 0)
			return (
				Gd.subVectors(a, n),
				(o = (h - u) / (h - u + (p - g))),
				t.copy(n).addScaledVector(Gd, o)
			);
		const v = 1 / (f + m + d);
		return (
			(s = m * v),
			(o = d * v),
			t.copy(i).addScaledVector(En, s).addScaledVector(An, o)
		);
	}
	equals(e) {
		return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
	}
}
let Tb = 0;
class dt extends Di {
	constructor() {
		super(),
		Object.defineProperty(this, 'id', { value: Tb++ }),
		(this.uuid = ir()),
		(this.name = ''),
		(this.type = 'Material'),
		(this.fog = !0),
		(this.blending = ea),
		(this.side = na),
		(this.vertexColors = !1),
		(this.opacity = 1),
		(this.transparent = !1),
		(this.blendSrc = Tf),
		(this.blendDst = Ef),
		(this.blendEquation = Wn),
		(this.blendSrcAlpha = null),
		(this.blendDstAlpha = null),
		(this.blendEquationAlpha = null),
		(this.depthFunc = Uc),
		(this.depthTest = !0),
		(this.depthWrite = !0),
		(this.stencilWriteMask = 255),
		(this.stencilFunc = Kx),
		(this.stencilRef = 0),
		(this.stencilFuncMask = 255),
		(this.stencilFail = Cl),
		(this.stencilZFail = Cl),
		(this.stencilZPass = Cl),
		(this.stencilWrite = !1),
		(this.clippingPlanes = null),
		(this.clipIntersection = !1),
		(this.clipShadows = !1),
		(this.shadowSide = null),
		(this.colorWrite = !0),
		(this.precision = null),
		(this.polygonOffset = !1),
		(this.polygonOffsetFactor = 0),
		(this.polygonOffsetUnits = 0),
		(this.dithering = !1),
		(this.alphaToCoverage = !1),
		(this.premultipliedAlpha = !1),
		(this.visible = !0),
		(this.toneMapped = !0),
		(this.userData = {}),
		(this.version = 0),
		(this._alphaTest = 0);
	}
	get alphaTest() {
		return this._alphaTest;
	}
	set alphaTest(e) {
		this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
	}
	onBuild() {}
	onBeforeRender() {}
	onBeforeCompile() {}
	customProgramCacheKey() {
		return this.onBeforeCompile.toString();
	}
	setValues(e) {
		if (e !== void 0)
			for (const t in e) {
				const i = e[t];
				if (i === void 0) {
					console.warn(
						'THREE.Material: \'' + t + '\' parameter is undefined.'
					);
					continue;
				}
				if (t === 'shading') {
					console.warn(
						'THREE.' +
                            this.type +
                            ': .shading has been removed. Use the boolean .flatShading instead.'
					),
					(this.flatShading = i === Sf);
					continue;
				}
				const n = this[t];
				if (n === void 0) {
					console.warn(
						'THREE.' +
                            this.type +
                            ': \'' +
                            t +
                            '\' is not a property of this material.'
					);
					continue;
				}
				n && n.isColor
					? n.set(i)
					: n && n.isVector3 && i && i.isVector3
						? n.copy(i)
						: (this[t] = i);
			}
	}
	toJSON(e) {
		const t = e === void 0 || typeof e == 'string';
		t && (e = { textures: {}, images: {} });
		const i = {
			metadata: {
				version: 4.5,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};
		(i.uuid = this.uuid),
		(i.type = this.type),
		this.name !== '' && (i.name = this.name),
		this.color && this.color.isColor && (i.color = this.color.getHex()),
		this.roughness !== void 0 && (i.roughness = this.roughness),
		this.metalness !== void 0 && (i.metalness = this.metalness),
		this.sheen !== void 0 && (i.sheen = this.sheen),
		this.sheenColor &&
                this.sheenColor.isColor &&
                (i.sheenColor = this.sheenColor.getHex()),
		this.sheenRoughness !== void 0 &&
                (i.sheenRoughness = this.sheenRoughness),
		this.emissive &&
                this.emissive.isColor &&
                (i.emissive = this.emissive.getHex()),
		this.emissiveIntensity &&
                this.emissiveIntensity !== 1 &&
                (i.emissiveIntensity = this.emissiveIntensity),
		this.specular &&
                this.specular.isColor &&
                (i.specular = this.specular.getHex()),
		this.specularIntensity !== void 0 &&
                (i.specularIntensity = this.specularIntensity),
		this.specularColor &&
                this.specularColor.isColor &&
                (i.specularColor = this.specularColor.getHex()),
		this.shininess !== void 0 && (i.shininess = this.shininess),
		this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
		this.clearcoatRoughness !== void 0 &&
                (i.clearcoatRoughness = this.clearcoatRoughness),
		this.clearcoatMap &&
                this.clearcoatMap.isTexture &&
                (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
		this.clearcoatRoughnessMap &&
                this.clearcoatRoughnessMap.isTexture &&
                (i.clearcoatRoughnessMap =
                    this.clearcoatRoughnessMap.toJSON(e).uuid),
		this.clearcoatNormalMap &&
                this.clearcoatNormalMap.isTexture &&
                ((i.clearcoatNormalMap =
                    this.clearcoatNormalMap.toJSON(e).uuid),
                (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
		this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
		this.matcap &&
                this.matcap.isTexture &&
                (i.matcap = this.matcap.toJSON(e).uuid),
		this.alphaMap &&
                this.alphaMap.isTexture &&
                (i.alphaMap = this.alphaMap.toJSON(e).uuid),
		this.lightMap &&
                this.lightMap.isTexture &&
                ((i.lightMap = this.lightMap.toJSON(e).uuid),
                (i.lightMapIntensity = this.lightMapIntensity)),
		this.aoMap &&
                this.aoMap.isTexture &&
                ((i.aoMap = this.aoMap.toJSON(e).uuid),
                (i.aoMapIntensity = this.aoMapIntensity)),
		this.bumpMap &&
                this.bumpMap.isTexture &&
                ((i.bumpMap = this.bumpMap.toJSON(e).uuid),
                (i.bumpScale = this.bumpScale)),
		this.normalMap &&
                this.normalMap.isTexture &&
                ((i.normalMap = this.normalMap.toJSON(e).uuid),
                (i.normalMapType = this.normalMapType),
                (i.normalScale = this.normalScale.toArray())),
		this.displacementMap &&
                this.displacementMap.isTexture &&
                ((i.displacementMap = this.displacementMap.toJSON(e).uuid),
                (i.displacementScale = this.displacementScale),
                (i.displacementBias = this.displacementBias)),
		this.roughnessMap &&
                this.roughnessMap.isTexture &&
                (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
		this.metalnessMap &&
                this.metalnessMap.isTexture &&
                (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
		this.emissiveMap &&
                this.emissiveMap.isTexture &&
                (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
		this.specularMap &&
                this.specularMap.isTexture &&
                (i.specularMap = this.specularMap.toJSON(e).uuid),
		this.specularIntensityMap &&
                this.specularIntensityMap.isTexture &&
                (i.specularIntensityMap =
                    this.specularIntensityMap.toJSON(e).uuid),
		this.specularColorMap &&
                this.specularColorMap.isTexture &&
                (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
		this.envMap &&
                this.envMap.isTexture &&
                ((i.envMap = this.envMap.toJSON(e).uuid),
                this.combine !== void 0 && (i.combine = this.combine)),
		this.envMapIntensity !== void 0 &&
                (i.envMapIntensity = this.envMapIntensity),
		this.reflectivity !== void 0 &&
                (i.reflectivity = this.reflectivity),
		this.refractionRatio !== void 0 &&
                (i.refractionRatio = this.refractionRatio),
		this.gradientMap &&
                this.gradientMap.isTexture &&
                (i.gradientMap = this.gradientMap.toJSON(e).uuid),
		this.transmission !== void 0 &&
                (i.transmission = this.transmission),
		this.transmissionMap &&
                this.transmissionMap.isTexture &&
                (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
		this.thickness !== void 0 && (i.thickness = this.thickness),
		this.thicknessMap &&
                this.thicknessMap.isTexture &&
                (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
		this.attenuationDistance !== void 0 &&
                (i.attenuationDistance = this.attenuationDistance),
		this.attenuationColor !== void 0 &&
                (i.attenuationColor = this.attenuationColor.getHex()),
		this.size !== void 0 && (i.size = this.size),
		this.shadowSide !== null && (i.shadowSide = this.shadowSide),
		this.sizeAttenuation !== void 0 &&
                (i.sizeAttenuation = this.sizeAttenuation),
		this.blending !== ea && (i.blending = this.blending),
		this.side !== na && (i.side = this.side),
		this.vertexColors && (i.vertexColors = !0),
		this.opacity < 1 && (i.opacity = this.opacity),
		this.transparent === !0 && (i.transparent = this.transparent),
		(i.depthFunc = this.depthFunc),
		(i.depthTest = this.depthTest),
		(i.depthWrite = this.depthWrite),
		(i.colorWrite = this.colorWrite),
		(i.stencilWrite = this.stencilWrite),
		(i.stencilWriteMask = this.stencilWriteMask),
		(i.stencilFunc = this.stencilFunc),
		(i.stencilRef = this.stencilRef),
		(i.stencilFuncMask = this.stencilFuncMask),
		(i.stencilFail = this.stencilFail),
		(i.stencilZFail = this.stencilZFail),
		(i.stencilZPass = this.stencilZPass),
		this.rotation !== void 0 &&
                this.rotation !== 0 &&
                (i.rotation = this.rotation),
		this.polygonOffset === !0 && (i.polygonOffset = !0),
		this.polygonOffsetFactor !== 0 &&
                (i.polygonOffsetFactor = this.polygonOffsetFactor),
		this.polygonOffsetUnits !== 0 &&
                (i.polygonOffsetUnits = this.polygonOffsetUnits),
		this.linewidth !== void 0 &&
                this.linewidth !== 1 &&
                (i.linewidth = this.linewidth),
		this.dashSize !== void 0 && (i.dashSize = this.dashSize),
		this.gapSize !== void 0 && (i.gapSize = this.gapSize),
		this.scale !== void 0 && (i.scale = this.scale),
		this.dithering === !0 && (i.dithering = !0),
		this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
		this.alphaToCoverage === !0 &&
                (i.alphaToCoverage = this.alphaToCoverage),
		this.premultipliedAlpha === !0 &&
                (i.premultipliedAlpha = this.premultipliedAlpha),
		this.wireframe === !0 && (i.wireframe = this.wireframe),
		this.wireframeLinewidth > 1 &&
                (i.wireframeLinewidth = this.wireframeLinewidth),
		this.wireframeLinecap !== 'round' &&
                (i.wireframeLinecap = this.wireframeLinecap),
		this.wireframeLinejoin !== 'round' &&
                (i.wireframeLinejoin = this.wireframeLinejoin),
		this.flatShading === !0 && (i.flatShading = this.flatShading),
		this.visible === !1 && (i.visible = !1),
		this.toneMapped === !1 && (i.toneMapped = !1),
		JSON.stringify(this.userData) !== '{}' &&
                (i.userData = this.userData);
		function n(a) {
			const s = [];
			for (const o in a) {
				const l = a[o];
				delete l.metadata, s.push(l);
			}
			return s;
		}
		if (t) {
			const a = n(e.textures),
				s = n(e.images);
			a.length > 0 && (i.textures = a), s.length > 0 && (i.images = s);
		}
		return i;
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(e) {
		(this.name = e.name),
		(this.fog = e.fog),
		(this.blending = e.blending),
		(this.side = e.side),
		(this.vertexColors = e.vertexColors),
		(this.opacity = e.opacity),
		(this.transparent = e.transparent),
		(this.blendSrc = e.blendSrc),
		(this.blendDst = e.blendDst),
		(this.blendEquation = e.blendEquation),
		(this.blendSrcAlpha = e.blendSrcAlpha),
		(this.blendDstAlpha = e.blendDstAlpha),
		(this.blendEquationAlpha = e.blendEquationAlpha),
		(this.depthFunc = e.depthFunc),
		(this.depthTest = e.depthTest),
		(this.depthWrite = e.depthWrite),
		(this.stencilWriteMask = e.stencilWriteMask),
		(this.stencilFunc = e.stencilFunc),
		(this.stencilRef = e.stencilRef),
		(this.stencilFuncMask = e.stencilFuncMask),
		(this.stencilFail = e.stencilFail),
		(this.stencilZFail = e.stencilZFail),
		(this.stencilZPass = e.stencilZPass),
		(this.stencilWrite = e.stencilWrite);
		const t = e.clippingPlanes;
		let i = null;
		if (t !== null) {
			const n = t.length;
			i = new Array(n);
			for (let a = 0; a !== n; ++a) i[a] = t[a].clone();
		}
		return (
			(this.clippingPlanes = i),
			(this.clipIntersection = e.clipIntersection),
			(this.clipShadows = e.clipShadows),
			(this.shadowSide = e.shadowSide),
			(this.colorWrite = e.colorWrite),
			(this.precision = e.precision),
			(this.polygonOffset = e.polygonOffset),
			(this.polygonOffsetFactor = e.polygonOffsetFactor),
			(this.polygonOffsetUnits = e.polygonOffsetUnits),
			(this.dithering = e.dithering),
			(this.alphaTest = e.alphaTest),
			(this.alphaToCoverage = e.alphaToCoverage),
			(this.premultipliedAlpha = e.premultipliedAlpha),
			(this.visible = e.visible),
			(this.toneMapped = e.toneMapped),
			(this.userData = JSON.parse(JSON.stringify(e.userData))),
			this
		);
	}
	dispose() {
		this.dispatchEvent({ type: 'dispose' });
	}
	set needsUpdate(e) {
		e === !0 && this.version++;
	}
}
dt.prototype.isMaterial = !0;
dt.fromType = function () {
	return null;
};
class Cr extends dt {
	constructor(e) {
		super(),
		(this.type = 'MeshBasicMaterial'),
		(this.color = new ke(16777215)),
		(this.map = null),
		(this.lightMap = null),
		(this.lightMapIntensity = 1),
		(this.aoMap = null),
		(this.aoMapIntensity = 1),
		(this.specularMap = null),
		(this.alphaMap = null),
		(this.envMap = null),
		(this.combine = tl),
		(this.reflectivity = 1),
		(this.refractionRatio = 0.98),
		(this.wireframe = !1),
		(this.wireframeLinewidth = 1),
		(this.wireframeLinecap = 'round'),
		(this.wireframeLinejoin = 'round'),
		this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			this.color.copy(e.color),
			(this.map = e.map),
			(this.lightMap = e.lightMap),
			(this.lightMapIntensity = e.lightMapIntensity),
			(this.aoMap = e.aoMap),
			(this.aoMapIntensity = e.aoMapIntensity),
			(this.specularMap = e.specularMap),
			(this.alphaMap = e.alphaMap),
			(this.envMap = e.envMap),
			(this.combine = e.combine),
			(this.reflectivity = e.reflectivity),
			(this.refractionRatio = e.refractionRatio),
			(this.wireframe = e.wireframe),
			(this.wireframeLinewidth = e.wireframeLinewidth),
			(this.wireframeLinecap = e.wireframeLinecap),
			(this.wireframeLinejoin = e.wireframeLinejoin),
			this
		);
	}
}
Cr.prototype.isMeshBasicMaterial = !0;
const ft = new C(),
	Ys = new me();
class mt {
	constructor(e, t, i) {
		if (Array.isArray(e))
			throw new TypeError(
				'THREE.BufferAttribute: array should be a Typed Array.'
			);
		(this.name = ''),
		(this.array = e),
		(this.itemSize = t),
		(this.count = e !== void 0 ? e.length / t : 0),
		(this.normalized = i === !0),
		(this.usage = gs),
		(this.updateRange = { offset: 0, count: -1 }),
		(this.version = 0);
	}
	onUploadCallback() {}
	set needsUpdate(e) {
		e === !0 && this.version++;
	}
	setUsage(e) {
		return (this.usage = e), this;
	}
	copy(e) {
		return (
			(this.name = e.name),
			(this.array = new e.array.constructor(e.array)),
			(this.itemSize = e.itemSize),
			(this.count = e.count),
			(this.normalized = e.normalized),
			(this.usage = e.usage),
			this
		);
	}
	copyAt(e, t, i) {
		(e *= this.itemSize), (i *= t.itemSize);
		for (let n = 0, a = this.itemSize; n < a; n++)
			this.array[e + n] = t.array[i + n];
		return this;
	}
	copyArray(e) {
		return this.array.set(e), this;
	}
	copyColorsArray(e) {
		const t = this.array;
		let i = 0;
		for (let n = 0, a = e.length; n < a; n++) {
			let s = e[n];
			s === void 0 &&
                (console.warn(
                	'THREE.BufferAttribute.copyColorsArray(): color is undefined',
                	n
                ),
                (s = new ke())),
			(t[i++] = s.r),
			(t[i++] = s.g),
			(t[i++] = s.b);
		}
		return this;
	}
	copyVector2sArray(e) {
		const t = this.array;
		let i = 0;
		for (let n = 0, a = e.length; n < a; n++) {
			let s = e[n];
			s === void 0 &&
                (console.warn(
                	'THREE.BufferAttribute.copyVector2sArray(): vector is undefined',
                	n
                ),
                (s = new me())),
			(t[i++] = s.x),
			(t[i++] = s.y);
		}
		return this;
	}
	copyVector3sArray(e) {
		const t = this.array;
		let i = 0;
		for (let n = 0, a = e.length; n < a; n++) {
			let s = e[n];
			s === void 0 &&
                (console.warn(
                	'THREE.BufferAttribute.copyVector3sArray(): vector is undefined',
                	n
                ),
                (s = new C())),
			(t[i++] = s.x),
			(t[i++] = s.y),
			(t[i++] = s.z);
		}
		return this;
	}
	copyVector4sArray(e) {
		const t = this.array;
		let i = 0;
		for (let n = 0, a = e.length; n < a; n++) {
			let s = e[n];
			s === void 0 &&
                (console.warn(
                	'THREE.BufferAttribute.copyVector4sArray(): vector is undefined',
                	n
                ),
                (s = new it())),
			(t[i++] = s.x),
			(t[i++] = s.y),
			(t[i++] = s.z),
			(t[i++] = s.w);
		}
		return this;
	}
	applyMatrix3(e) {
		if (this.itemSize === 2)
			for (let t = 0, i = this.count; t < i; t++)
				Ys.fromBufferAttribute(this, t),
				Ys.applyMatrix3(e),
				this.setXY(t, Ys.x, Ys.y);
		else if (this.itemSize === 3)
			for (let t = 0, i = this.count; t < i; t++)
				ft.fromBufferAttribute(this, t),
				ft.applyMatrix3(e),
				this.setXYZ(t, ft.x, ft.y, ft.z);
		return this;
	}
	applyMatrix4(e) {
		for (let t = 0, i = this.count; t < i; t++)
			ft.fromBufferAttribute(this, t),
			ft.applyMatrix4(e),
			this.setXYZ(t, ft.x, ft.y, ft.z);
		return this;
	}
	applyNormalMatrix(e) {
		for (let t = 0, i = this.count; t < i; t++)
			ft.fromBufferAttribute(this, t),
			ft.applyNormalMatrix(e),
			this.setXYZ(t, ft.x, ft.y, ft.z);
		return this;
	}
	transformDirection(e) {
		for (let t = 0, i = this.count; t < i; t++)
			ft.fromBufferAttribute(this, t),
			ft.transformDirection(e),
			this.setXYZ(t, ft.x, ft.y, ft.z);
		return this;
	}
	set(e, t = 0) {
		return this.array.set(e, t), this;
	}
	getX(e) {
		return this.array[e * this.itemSize];
	}
	setX(e, t) {
		return (this.array[e * this.itemSize] = t), this;
	}
	getY(e) {
		return this.array[e * this.itemSize + 1];
	}
	setY(e, t) {
		return (this.array[e * this.itemSize + 1] = t), this;
	}
	getZ(e) {
		return this.array[e * this.itemSize + 2];
	}
	setZ(e, t) {
		return (this.array[e * this.itemSize + 2] = t), this;
	}
	getW(e) {
		return this.array[e * this.itemSize + 3];
	}
	setW(e, t) {
		return (this.array[e * this.itemSize + 3] = t), this;
	}
	setXY(e, t, i) {
		return (
			(e *= this.itemSize),
			(this.array[e + 0] = t),
			(this.array[e + 1] = i),
			this
		);
	}
	setXYZ(e, t, i, n) {
		return (
			(e *= this.itemSize),
			(this.array[e + 0] = t),
			(this.array[e + 1] = i),
			(this.array[e + 2] = n),
			this
		);
	}
	setXYZW(e, t, i, n, a) {
		return (
			(e *= this.itemSize),
			(this.array[e + 0] = t),
			(this.array[e + 1] = i),
			(this.array[e + 2] = n),
			(this.array[e + 3] = a),
			this
		);
	}
	onUpload(e) {
		return (this.onUploadCallback = e), this;
	}
	clone() {
		return new this.constructor(this.array, this.itemSize).copy(this);
	}
	toJSON() {
		const e = {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.prototype.slice.call(this.array),
			normalized: this.normalized
		};
		return (
			this.name !== '' && (e.name = this.name),
			this.usage !== gs && (e.usage = this.usage),
			(this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
                (e.updateRange = this.updateRange),
			e
		);
	}
}
mt.prototype.isBufferAttribute = !0;
class Nf extends mt {
	constructor(e, t, i) {
		super(new Uint16Array(e), t, i);
	}
}
class zf extends mt {
	constructor(e, t, i) {
		super(new Uint32Array(e), t, i);
	}
}
class Eb extends mt {
	constructor(e, t, i) {
		super(new Uint16Array(e), t, i);
	}
}
Eb.prototype.isFloat16BufferAttribute = !0;
class yt extends mt {
	constructor(e, t, i) {
		super(new Float32Array(e), t, i);
	}
}
let Ab = 0;
const $t = new Pe(),
	Xl = new Je(),
	Ln = new C(),
	Wt = new or(),
	Na = new or(),
	Tt = new C();
class ot extends Di {
	constructor() {
		super(),
		Object.defineProperty(this, 'id', { value: Ab++ }),
		(this.uuid = ir()),
		(this.name = ''),
		(this.type = 'BufferGeometry'),
		(this.index = null),
		(this.attributes = {}),
		(this.morphAttributes = {}),
		(this.morphTargetsRelative = !1),
		(this.groups = []),
		(this.boundingBox = null),
		(this.boundingSphere = null),
		(this.drawRange = { start: 0, count: 1 / 0 }),
		(this.userData = {});
	}
	getIndex() {
		return this.index;
	}
	setIndex(e) {
		return (
			Array.isArray(e)
				? (this.index = new (Pf(e) ? zf : Nf)(e, 1))
				: (this.index = e),
			this
		);
	}
	getAttribute(e) {
		return this.attributes[e];
	}
	setAttribute(e, t) {
		return (this.attributes[e] = t), this;
	}
	deleteAttribute(e) {
		return delete this.attributes[e], this;
	}
	hasAttribute(e) {
		return this.attributes[e] !== void 0;
	}
	addGroup(e, t, i = 0) {
		this.groups.push({ start: e, count: t, materialIndex: i });
	}
	clearGroups() {
		this.groups = [];
	}
	setDrawRange(e, t) {
		(this.drawRange.start = e), (this.drawRange.count = t);
	}
	applyMatrix4(e) {
		const t = this.attributes.position;
		t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
		const i = this.attributes.normal;
		if (i !== void 0) {
			const a = new kt().getNormalMatrix(e);
			i.applyNormalMatrix(a), (i.needsUpdate = !0);
		}
		const n = this.attributes.tangent;
		return (
			n !== void 0 && (n.transformDirection(e), (n.needsUpdate = !0)),
			this.boundingBox !== null && this.computeBoundingBox(),
			this.boundingSphere !== null && this.computeBoundingSphere(),
			this
		);
	}
	applyQuaternion(e) {
		return $t.makeRotationFromQuaternion(e), this.applyMatrix4($t), this;
	}
	rotateX(e) {
		return $t.makeRotationX(e), this.applyMatrix4($t), this;
	}
	rotateY(e) {
		return $t.makeRotationY(e), this.applyMatrix4($t), this;
	}
	rotateZ(e) {
		return $t.makeRotationZ(e), this.applyMatrix4($t), this;
	}
	translate(e, t, i) {
		return $t.makeTranslation(e, t, i), this.applyMatrix4($t), this;
	}
	scale(e, t, i) {
		return $t.makeScale(e, t, i), this.applyMatrix4($t), this;
	}
	lookAt(e) {
		return (
			Xl.lookAt(e), Xl.updateMatrix(), this.applyMatrix4(Xl.matrix), this
		);
	}
	center() {
		return (
			this.computeBoundingBox(),
			this.boundingBox.getCenter(Ln).negate(),
			this.translate(Ln.x, Ln.y, Ln.z),
			this
		);
	}
	setFromPoints(e) {
		const t = [];
		for (let i = 0, n = e.length; i < n; i++) {
			const a = e[i];
			t.push(a.x, a.y, a.z || 0);
		}
		return this.setAttribute('position', new yt(t, 3)), this;
	}
	computeBoundingBox() {
		this.boundingBox === null && (this.boundingBox = new or());
		const e = this.attributes.position,
			t = this.morphAttributes.position;
		if (e && e.isGLBufferAttribute) {
			console.error(
				'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
				this
			),
			this.boundingBox.set(
				new C(-1 / 0, -1 / 0, -1 / 0),
				new C(1 / 0, 1 / 0, 1 / 0)
			);
			return;
		}
		if (e !== void 0) {
			if ((this.boundingBox.setFromBufferAttribute(e), t))
				for (let i = 0, n = t.length; i < n; i++) {
					const a = t[i];
					Wt.setFromBufferAttribute(a),
					this.morphTargetsRelative
						? (Tt.addVectors(this.boundingBox.min, Wt.min),
						this.boundingBox.expandByPoint(Tt),
						Tt.addVectors(this.boundingBox.max, Wt.max),
						this.boundingBox.expandByPoint(Tt))
						: (this.boundingBox.expandByPoint(Wt.min),
						this.boundingBox.expandByPoint(Wt.max));
				}
		} else this.boundingBox.makeEmpty();
		(isNaN(this.boundingBox.min.x) ||
            isNaN(this.boundingBox.min.y) ||
            isNaN(this.boundingBox.min.z)) &&
            console.error(
            	'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
            	this
            );
	}
	computeBoundingSphere() {
		this.boundingSphere === null && (this.boundingSphere = new dn());
		const e = this.attributes.position,
			t = this.morphAttributes.position;
		if (e && e.isGLBufferAttribute) {
			console.error(
				'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
				this
			),
			this.boundingSphere.set(new C(), 1 / 0);
			return;
		}
		if (e) {
			const i = this.boundingSphere.center;
			if ((Wt.setFromBufferAttribute(e), t))
				for (let a = 0, s = t.length; a < s; a++) {
					const o = t[a];
					Na.setFromBufferAttribute(o),
					this.morphTargetsRelative
						? (Tt.addVectors(Wt.min, Na.min),
						Wt.expandByPoint(Tt),
						Tt.addVectors(Wt.max, Na.max),
						Wt.expandByPoint(Tt))
						: (Wt.expandByPoint(Na.min),
						Wt.expandByPoint(Na.max));
				}
			Wt.getCenter(i);
			let n = 0;
			for (let a = 0, s = e.count; a < s; a++)
				Tt.fromBufferAttribute(e, a),
				(n = Math.max(n, i.distanceToSquared(Tt)));
			if (t)
				for (let a = 0, s = t.length; a < s; a++) {
					const o = t[a],
						l = this.morphTargetsRelative;
					for (let c = 0, u = o.count; c < u; c++)
						Tt.fromBufferAttribute(o, c),
						l && (Ln.fromBufferAttribute(e, c), Tt.add(Ln)),
						(n = Math.max(n, i.distanceToSquared(Tt)));
				}
			(this.boundingSphere.radius = Math.sqrt(n)),
			isNaN(this.boundingSphere.radius) &&
                    console.error(
                    	'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                    	this
                    );
		}
	}
	computeTangents() {
		const e = this.index,
			t = this.attributes;
		if (
			e === null ||
            t.position === void 0 ||
            t.normal === void 0 ||
            t.uv === void 0
		) {
			console.error(
				'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)'
			);
			return;
		}
		const i = e.array,
			n = t.position.array,
			a = t.normal.array,
			s = t.uv.array,
			o = n.length / 3;
		this.hasAttribute('tangent') === !1 &&
            this.setAttribute('tangent', new mt(new Float32Array(4 * o), 4));
		const l = this.getAttribute('tangent').array,
			c = [],
			u = [];
		for (let B = 0; B < o; B++) (c[B] = new C()), (u[B] = new C());
		const h = new C(),
			d = new C(),
			p = new C(),
			g = new me(),
			m = new me(),
			f = new me(),
			v = new C(),
			x = new C();
		function A(B, b, E) {
			h.fromArray(n, B * 3),
			d.fromArray(n, b * 3),
			p.fromArray(n, E * 3),
			g.fromArray(s, B * 2),
			m.fromArray(s, b * 2),
			f.fromArray(s, E * 2),
			d.sub(h),
			p.sub(h),
			m.sub(g),
			f.sub(g);
			const j = 1 / (m.x * f.y - f.x * m.y);
			!isFinite(j) ||
                (v
                	.copy(d)
                	.multiplyScalar(f.y)
                	.addScaledVector(p, -m.y)
                	.multiplyScalar(j),
                x
                	.copy(p)
                	.multiplyScalar(m.x)
                	.addScaledVector(d, -f.x)
                	.multiplyScalar(j),
                c[B].add(v),
                c[b].add(v),
                c[E].add(v),
                u[B].add(x),
                u[b].add(x),
                u[E].add(x));
		}
		let S = this.groups;
		S.length === 0 && (S = [{ start: 0, count: i.length }]);
		for (let B = 0, b = S.length; B < b; ++B) {
			const E = S[B],
				j = E.start,
				z = E.count;
			for (let V = j, H = j + z; V < H; V += 3)
				A(i[V + 0], i[V + 1], i[V + 2]);
		}
		const M = new C(),
			I = new C(),
			D = new C(),
			G = new C();
		function re(B) {
			D.fromArray(a, B * 3), G.copy(D);
			const b = c[B];
			M.copy(b),
			M.sub(D.multiplyScalar(D.dot(b))).normalize(),
			I.crossVectors(G, b);
			const E = I.dot(u[B]) < 0 ? -1 : 1;
			(l[B * 4] = M.x),
			(l[B * 4 + 1] = M.y),
			(l[B * 4 + 2] = M.z),
			(l[B * 4 + 3] = E);
		}
		for (let B = 0, b = S.length; B < b; ++B) {
			const E = S[B],
				j = E.start,
				z = E.count;
			for (let V = j, H = j + z; V < H; V += 3)
				re(i[V + 0]), re(i[V + 1]), re(i[V + 2]);
		}
	}
	computeVertexNormals() {
		const e = this.index,
			t = this.getAttribute('position');
		if (t !== void 0) {
			let i = this.getAttribute('normal');
			if (i === void 0)
				(i = new mt(new Float32Array(t.count * 3), 3)),
				this.setAttribute('normal', i);
			else for (let d = 0, p = i.count; d < p; d++) i.setXYZ(d, 0, 0, 0);
			const n = new C(),
				a = new C(),
				s = new C(),
				o = new C(),
				l = new C(),
				c = new C(),
				u = new C(),
				h = new C();
			if (e)
				for (let d = 0, p = e.count; d < p; d += 3) {
					const g = e.getX(d + 0),
						m = e.getX(d + 1),
						f = e.getX(d + 2);
					n.fromBufferAttribute(t, g),
					a.fromBufferAttribute(t, m),
					s.fromBufferAttribute(t, f),
					u.subVectors(s, a),
					h.subVectors(n, a),
					u.cross(h),
					o.fromBufferAttribute(i, g),
					l.fromBufferAttribute(i, m),
					c.fromBufferAttribute(i, f),
					o.add(u),
					l.add(u),
					c.add(u),
					i.setXYZ(g, o.x, o.y, o.z),
					i.setXYZ(m, l.x, l.y, l.z),
					i.setXYZ(f, c.x, c.y, c.z);
				}
			else
				for (let d = 0, p = t.count; d < p; d += 3)
					n.fromBufferAttribute(t, d + 0),
					a.fromBufferAttribute(t, d + 1),
					s.fromBufferAttribute(t, d + 2),
					u.subVectors(s, a),
					h.subVectors(n, a),
					u.cross(h),
					i.setXYZ(d + 0, u.x, u.y, u.z),
					i.setXYZ(d + 1, u.x, u.y, u.z),
					i.setXYZ(d + 2, u.x, u.y, u.z);
			this.normalizeNormals(), (i.needsUpdate = !0);
		}
	}
	merge(e, t) {
		if (!(e && e.isBufferGeometry)) {
			console.error(
				'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',
				e
			);
			return;
		}
		t === void 0 &&
            ((t = 0),
            console.warn(
            	'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
            ));
		const i = this.attributes;
		for (const n in i) {
			if (e.attributes[n] === void 0) continue;
			const a = i[n].array,
				s = e.attributes[n],
				o = s.array,
				l = s.itemSize * t,
				c = Math.min(o.length, a.length - l);
			for (let u = 0, h = l; u < c; u++, h++) a[h] = o[u];
		}
		return this;
	}
	normalizeNormals() {
		const e = this.attributes.normal;
		for (let t = 0, i = e.count; t < i; t++)
			Tt.fromBufferAttribute(e, t),
			Tt.normalize(),
			e.setXYZ(t, Tt.x, Tt.y, Tt.z);
	}
	toNonIndexed() {
		function e(o, l) {
			const c = o.array,
				u = o.itemSize,
				h = o.normalized,
				d = new c.constructor(l.length * u);
			let p = 0,
				g = 0;
			for (let m = 0, f = l.length; m < f; m++) {
				o.isInterleavedBufferAttribute
					? (p = l[m] * o.data.stride + o.offset)
					: (p = l[m] * u);
				for (let v = 0; v < u; v++) d[g++] = c[p++];
			}
			return new mt(d, u, h);
		}
		if (this.index === null)
			return (
				console.warn(
					'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.'
				),
				this
			);
		const t = new ot(),
			i = this.index.array,
			n = this.attributes;
		for (const o in n) {
			const l = n[o],
				c = e(l, i);
			t.setAttribute(o, c);
		}
		const a = this.morphAttributes;
		for (const o in a) {
			const l = [],
				c = a[o];
			for (let u = 0, h = c.length; u < h; u++) {
				const d = c[u],
					p = e(d, i);
				l.push(p);
			}
			t.morphAttributes[o] = l;
		}
		t.morphTargetsRelative = this.morphTargetsRelative;
		const s = this.groups;
		for (let o = 0, l = s.length; o < l; o++) {
			const c = s[o];
			t.addGroup(c.start, c.count, c.materialIndex);
		}
		return t;
	}
	toJSON() {
		const e = {
			metadata: {
				version: 4.5,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};
		if (
			((e.uuid = this.uuid),
			(e.type = this.type),
			this.name !== '' && (e.name = this.name),
			Object.keys(this.userData).length > 0 &&
                (e.userData = this.userData),
			this.parameters !== void 0)
		) {
			const l = this.parameters;
			for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
			return e;
		}
		e.data = { attributes: {} };
		const t = this.index;
		t !== null &&
            (e.data.index = {
            	type: t.array.constructor.name,
            	array: Array.prototype.slice.call(t.array)
            });
		const i = this.attributes;
		for (const l in i) {
			const c = i[l];
			e.data.attributes[l] = c.toJSON(e.data);
		}
		const n = {};
		let a = !1;
		for (const l in this.morphAttributes) {
			const c = this.morphAttributes[l],
				u = [];
			for (let h = 0, d = c.length; h < d; h++) {
				const p = c[h];
				u.push(p.toJSON(e.data));
			}
			u.length > 0 && ((n[l] = u), (a = !0));
		}
		a &&
            ((e.data.morphAttributes = n),
            (e.data.morphTargetsRelative = this.morphTargetsRelative));
		const s = this.groups;
		s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
		const o = this.boundingSphere;
		return (
			o !== null &&
                (e.data.boundingSphere = {
                	center: o.center.toArray(),
                	radius: o.radius
                }),
			e
		);
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(e) {
		(this.index = null),
		(this.attributes = {}),
		(this.morphAttributes = {}),
		(this.groups = []),
		(this.boundingBox = null),
		(this.boundingSphere = null);
		const t = {};
		this.name = e.name;
		const i = e.index;
		i !== null && this.setIndex(i.clone(t));
		const n = e.attributes;
		for (const c in n) {
			const u = n[c];
			this.setAttribute(c, u.clone(t));
		}
		const a = e.morphAttributes;
		for (const c in a) {
			const u = [],
				h = a[c];
			for (let d = 0, p = h.length; d < p; d++) u.push(h[d].clone(t));
			this.morphAttributes[c] = u;
		}
		this.morphTargetsRelative = e.morphTargetsRelative;
		const s = e.groups;
		for (let c = 0, u = s.length; c < u; c++) {
			const h = s[c];
			this.addGroup(h.start, h.count, h.materialIndex);
		}
		const o = e.boundingBox;
		o !== null && (this.boundingBox = o.clone());
		const l = e.boundingSphere;
		return (
			l !== null && (this.boundingSphere = l.clone()),
			(this.drawRange.start = e.drawRange.start),
			(this.drawRange.count = e.drawRange.count),
			(this.userData = e.userData),
			e.parameters !== void 0 &&
                (this.parameters = Object.assign({}, e.parameters)),
			this
		);
	}
	dispose() {
		this.dispatchEvent({ type: 'dispose' });
	}
}
ot.prototype.isBufferGeometry = !0;
const Vd = new Pe(),
	Rn = new wa(),
	ql = new dn(),
	hi = new C(),
	di = new C(),
	pi = new C(),
	Yl = new C(),
	Zl = new C(),
	$l = new C(),
	Zs = new C(),
	$s = new C(),
	Ks = new C(),
	Js = new me(),
	Qs = new me(),
	eo = new me(),
	Kl = new C(),
	to = new C();
class rt extends Je {
	constructor(e = new ot(), t = new Cr()) {
		super(),
		(this.type = 'Mesh'),
		(this.geometry = e),
		(this.material = t),
		this.updateMorphTargets();
	}
	copy(e) {
		return (
			super.copy(e),
			e.morphTargetInfluences !== void 0 &&
                (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
			e.morphTargetDictionary !== void 0 &&
                (this.morphTargetDictionary = Object.assign(
                	{},
                	e.morphTargetDictionary
                )),
			(this.material = e.material),
			(this.geometry = e.geometry),
			this
		);
	}
	updateMorphTargets() {
		const e = this.geometry;
		if (e.isBufferGeometry) {
			const t = e.morphAttributes,
				i = Object.keys(t);
			if (i.length > 0) {
				const n = t[i[0]];
				if (n !== void 0) {
					(this.morphTargetInfluences = []),
					(this.morphTargetDictionary = {});
					for (let a = 0, s = n.length; a < s; a++) {
						const o = n[a].name || String(a);
						this.morphTargetInfluences.push(0),
						(this.morphTargetDictionary[o] = a);
					}
				}
			}
		} else {
			const t = e.morphTargets;
			t !== void 0 &&
                t.length > 0 &&
                console.error(
                	'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
                );
		}
	}
	raycast(e, t) {
		const i = this.geometry,
			n = this.material,
			a = this.matrixWorld;
		if (
			n === void 0 ||
            (i.boundingSphere === null && i.computeBoundingSphere(),
            ql.copy(i.boundingSphere),
            ql.applyMatrix4(a),
            e.ray.intersectsSphere(ql) === !1) ||
            (Vd.copy(a).invert(),
            Rn.copy(e.ray).applyMatrix4(Vd),
            i.boundingBox !== null && Rn.intersectsBox(i.boundingBox) === !1)
		)
			return;
		let s;
		if (i.isBufferGeometry) {
			const o = i.index,
				l = i.attributes.position,
				c = i.morphAttributes.position,
				u = i.morphTargetsRelative,
				h = i.attributes.uv,
				d = i.attributes.uv2,
				p = i.groups,
				g = i.drawRange;
			if (o !== null)
				if (Array.isArray(n))
					for (let m = 0, f = p.length; m < f; m++) {
						const v = p[m],
							x = n[v.materialIndex],
							A = Math.max(v.start, g.start),
							S = Math.min(
								o.count,
								Math.min(v.start + v.count, g.start + g.count)
							);
						for (let M = A, I = S; M < I; M += 3) {
							const D = o.getX(M),
								G = o.getX(M + 1),
								re = o.getX(M + 2);
							(s = ro(this, x, e, Rn, l, c, u, h, d, D, G, re)),
							s &&
                                    ((s.faceIndex = Math.floor(M / 3)),
                                    (s.face.materialIndex = v.materialIndex),
                                    t.push(s));
						}
					}
				else {
					const m = Math.max(0, g.start),
						f = Math.min(o.count, g.start + g.count);
					for (let v = m, x = f; v < x; v += 3) {
						const A = o.getX(v),
							S = o.getX(v + 1),
							M = o.getX(v + 2);
						(s = ro(this, n, e, Rn, l, c, u, h, d, A, S, M)),
						s && ((s.faceIndex = Math.floor(v / 3)), t.push(s));
					}
				}
			else if (l !== void 0)
				if (Array.isArray(n))
					for (let m = 0, f = p.length; m < f; m++) {
						const v = p[m],
							x = n[v.materialIndex],
							A = Math.max(v.start, g.start),
							S = Math.min(
								l.count,
								Math.min(v.start + v.count, g.start + g.count)
							);
						for (let M = A, I = S; M < I; M += 3) {
							const D = M,
								G = M + 1,
								re = M + 2;
							(s = ro(this, x, e, Rn, l, c, u, h, d, D, G, re)),
							s &&
                                    ((s.faceIndex = Math.floor(M / 3)),
                                    (s.face.materialIndex = v.materialIndex),
                                    t.push(s));
						}
					}
				else {
					const m = Math.max(0, g.start),
						f = Math.min(l.count, g.start + g.count);
					for (let v = m, x = f; v < x; v += 3) {
						const A = v,
							S = v + 1,
							M = v + 2;
						(s = ro(this, n, e, Rn, l, c, u, h, d, A, S, M)),
						s && ((s.faceIndex = Math.floor(v / 3)), t.push(s));
					}
				}
		} else
			i.isGeometry &&
                console.error(
                	'THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
                );
	}
}
rt.prototype.isMesh = !0;
function Lb(r, e, t, i, n, a, s, o) {
	let l;
	if (
		(e.side === rr
			? (l = i.intersectTriangle(s, a, n, !0, o))
			: (l = i.intersectTriangle(n, a, s, e.side !== an, o)),
		l === null)
	)
		return null;
	to.copy(o), to.applyMatrix4(r.matrixWorld);
	const c = t.ray.origin.distanceTo(to);
	return c < t.near || c > t.far
		? null
		: { distance: c, point: to.clone(), object: r };
}
function ro(r, e, t, i, n, a, s, o, l, c, u, h) {
	hi.fromBufferAttribute(n, c),
	di.fromBufferAttribute(n, u),
	pi.fromBufferAttribute(n, h);
	const d = r.morphTargetInfluences;
	if (a && d) {
		Zs.set(0, 0, 0), $s.set(0, 0, 0), Ks.set(0, 0, 0);
		for (let g = 0, m = a.length; g < m; g++) {
			const f = d[g],
				v = a[g];
			f !== 0 &&
                (Yl.fromBufferAttribute(v, c),
                Zl.fromBufferAttribute(v, u),
                $l.fromBufferAttribute(v, h),
                s
                	? (Zs.addScaledVector(Yl, f),
                	$s.addScaledVector(Zl, f),
                	Ks.addScaledVector($l, f))
                	: (Zs.addScaledVector(Yl.sub(hi), f),
                	$s.addScaledVector(Zl.sub(di), f),
                	Ks.addScaledVector($l.sub(pi), f)));
		}
		hi.add(Zs), di.add($s), pi.add(Ks);
	}
	r.isSkinnedMesh &&
        (r.boneTransform(c, hi),
        r.boneTransform(u, di),
        r.boneTransform(h, pi));
	const p = Lb(r, e, t, i, hi, di, pi, Kl);
	if (p) {
		o &&
            (Js.fromBufferAttribute(o, c),
            Qs.fromBufferAttribute(o, u),
            eo.fromBufferAttribute(o, h),
            (p.uv = vt.getUV(Kl, hi, di, pi, Js, Qs, eo, new me()))),
		l &&
                (Js.fromBufferAttribute(l, c),
                Qs.fromBufferAttribute(l, u),
                eo.fromBufferAttribute(l, h),
                (p.uv2 = vt.getUV(Kl, hi, di, pi, Js, Qs, eo, new me())));
		const g = { a: c, b: u, c: h, normal: new C(), materialIndex: 0 };
		vt.getNormal(hi, di, pi, g.normal), (p.face = g);
	}
	return p;
}
class _a extends ot {
	constructor(e = 1, t = 1, i = 1, n = 1, a = 1, s = 1) {
		super(),
		(this.type = 'BoxGeometry'),
		(this.parameters = {
			width: e,
			height: t,
			depth: i,
			widthSegments: n,
			heightSegments: a,
			depthSegments: s
		});
		const o = this;
		(n = Math.floor(n)), (a = Math.floor(a)), (s = Math.floor(s));
		const l = [],
			c = [],
			u = [],
			h = [];
		let d = 0,
			p = 0;
		g('z', 'y', 'x', -1, -1, i, t, e, s, a, 0),
		g('z', 'y', 'x', 1, -1, i, t, -e, s, a, 1),
		g('x', 'z', 'y', 1, 1, e, i, t, n, s, 2),
		g('x', 'z', 'y', 1, -1, e, i, -t, n, s, 3),
		g('x', 'y', 'z', 1, -1, e, t, i, n, a, 4),
		g('x', 'y', 'z', -1, -1, e, t, -i, n, a, 5),
		this.setIndex(l),
		this.setAttribute('position', new yt(c, 3)),
		this.setAttribute('normal', new yt(u, 3)),
		this.setAttribute('uv', new yt(h, 2));
		function g(m, f, v, x, A, S, M, I, D, G, re) {
			const B = S / D,
				b = M / G,
				E = S / 2,
				j = M / 2,
				z = I / 2,
				V = D + 1,
				H = G + 1;
			let k = 0,
				P = 0;
			const Z = new C();
			for (let J = 0; J < H; J++) {
				const fe = J * b - j;
				for (let ce = 0; ce < V; ce++) {
					const xe = ce * B - E;
					(Z[m] = xe * x),
					(Z[f] = fe * A),
					(Z[v] = z),
					c.push(Z.x, Z.y, Z.z),
					(Z[m] = 0),
					(Z[f] = 0),
					(Z[v] = I > 0 ? 1 : -1),
					u.push(Z.x, Z.y, Z.z),
					h.push(ce / D),
					h.push(1 - J / G),
					(k += 1);
				}
			}
			for (let J = 0; J < G; J++)
				for (let fe = 0; fe < D; fe++) {
					const ce = d + fe + V * J,
						xe = d + fe + V * (J + 1),
						W = d + (fe + 1) + V * (J + 1),
						ue = d + (fe + 1) + V * J;
					l.push(ce, xe, ue), l.push(xe, W, ue), (P += 6);
				}
			o.addGroup(p, P, re), (p += P), (d += k);
		}
	}
	static fromJSON(e) {
		return new _a(
			e.width,
			e.height,
			e.depth,
			e.widthSegments,
			e.heightSegments,
			e.depthSegments
		);
	}
}
function ua(r) {
	const e = {};
	for (const t in r) {
		e[t] = {};
		for (const i in r[t]) {
			const n = r[t][i];
			n &&
            (n.isColor ||
                n.isMatrix3 ||
                n.isMatrix4 ||
                n.isVector2 ||
                n.isVector3 ||
                n.isVector4 ||
                n.isTexture ||
                n.isQuaternion)
				? (e[t][i] = n.clone())
				: Array.isArray(n)
					? (e[t][i] = n.slice())
					: (e[t][i] = n);
		}
	}
	return e;
}
function Dt(r) {
	const e = {};
	for (let t = 0; t < r.length; t++) {
		const i = ua(r[t]);
		for (const n in i) e[n] = i[n];
	}
	return e;
}
const Rb = { clone: ua, merge: Dt };
var kb = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
	Cb = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class br extends dt {
	constructor(e) {
		super(),
		(this.type = 'ShaderMaterial'),
		(this.defines = {}),
		(this.uniforms = {}),
		(this.vertexShader = kb),
		(this.fragmentShader = Cb),
		(this.linewidth = 1),
		(this.wireframe = !1),
		(this.wireframeLinewidth = 1),
		(this.fog = !1),
		(this.lights = !1),
		(this.clipping = !1),
		(this.extensions = {
			derivatives: !1,
			fragDepth: !1,
			drawBuffers: !1,
			shaderTextureLOD: !1
		}),
		(this.defaultAttributeValues = {
			color: [1, 1, 1],
			uv: [0, 0],
			uv2: [0, 0]
		}),
		(this.index0AttributeName = void 0),
		(this.uniformsNeedUpdate = !1),
		(this.glslVersion = null),
		e !== void 0 &&
                (e.attributes !== void 0 &&
                    console.error(
                    	'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.'
                    ),
                this.setValues(e));
	}
	copy(e) {
		return (
			super.copy(e),
			(this.fragmentShader = e.fragmentShader),
			(this.vertexShader = e.vertexShader),
			(this.uniforms = ua(e.uniforms)),
			(this.defines = Object.assign({}, e.defines)),
			(this.wireframe = e.wireframe),
			(this.wireframeLinewidth = e.wireframeLinewidth),
			(this.lights = e.lights),
			(this.clipping = e.clipping),
			(this.extensions = Object.assign({}, e.extensions)),
			(this.glslVersion = e.glslVersion),
			this
		);
	}
	toJSON(e) {
		const t = super.toJSON(e);
		(t.glslVersion = this.glslVersion), (t.uniforms = {});
		for (const n in this.uniforms) {
			const a = this.uniforms[n].value;
			a && a.isTexture
				? (t.uniforms[n] = { type: 't', value: a.toJSON(e).uuid })
				: a && a.isColor
					? (t.uniforms[n] = { type: 'c', value: a.getHex() })
					: a && a.isVector2
						? (t.uniforms[n] = { type: 'v2', value: a.toArray() })
						: a && a.isVector3
							? (t.uniforms[n] = { type: 'v3', value: a.toArray() })
							: a && a.isVector4
								? (t.uniforms[n] = { type: 'v4', value: a.toArray() })
								: a && a.isMatrix3
									? (t.uniforms[n] = { type: 'm3', value: a.toArray() })
									: a && a.isMatrix4
										? (t.uniforms[n] = { type: 'm4', value: a.toArray() })
										: (t.uniforms[n] = { value: a });
		}
		Object.keys(this.defines).length > 0 && (t.defines = this.defines),
		(t.vertexShader = this.vertexShader),
		(t.fragmentShader = this.fragmentShader);
		const i = {};
		for (const n in this.extensions)
			this.extensions[n] === !0 && (i[n] = !0);
		return Object.keys(i).length > 0 && (t.extensions = i), t;
	}
}
br.prototype.isShaderMaterial = !0;
class Iu extends Je {
	constructor() {
		super(),
		(this.type = 'Camera'),
		(this.matrixWorldInverse = new Pe()),
		(this.projectionMatrix = new Pe()),
		(this.projectionMatrixInverse = new Pe());
	}
	copy(e, t) {
		return (
			super.copy(e, t),
			this.matrixWorldInverse.copy(e.matrixWorldInverse),
			this.projectionMatrix.copy(e.projectionMatrix),
			this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
			this
		);
	}
	getWorldDirection(e) {
		this.updateWorldMatrix(!0, !1);
		const t = this.matrixWorld.elements;
		return e.set(-t[8], -t[9], -t[10]).normalize();
	}
	updateMatrixWorld(e) {
		super.updateMatrixWorld(e),
		this.matrixWorldInverse.copy(this.matrixWorld).invert();
	}
	updateWorldMatrix(e, t) {
		super.updateWorldMatrix(e, t),
		this.matrixWorldInverse.copy(this.matrixWorld).invert();
	}
	clone() {
		return new this.constructor().copy(this);
	}
}
Iu.prototype.isCamera = !0;
class zt extends Iu {
	constructor(e = 50, t = 1, i = 0.1, n = 2e3) {
		super(),
		(this.type = 'PerspectiveCamera'),
		(this.fov = e),
		(this.zoom = 1),
		(this.near = i),
		(this.far = n),
		(this.focus = 10),
		(this.aspect = t),
		(this.view = null),
		(this.filmGauge = 35),
		(this.filmOffset = 0),
		this.updateProjectionMatrix();
	}
	copy(e, t) {
		return (
			super.copy(e, t),
			(this.fov = e.fov),
			(this.zoom = e.zoom),
			(this.near = e.near),
			(this.far = e.far),
			(this.focus = e.focus),
			(this.aspect = e.aspect),
			(this.view = e.view === null ? null : Object.assign({}, e.view)),
			(this.filmGauge = e.filmGauge),
			(this.filmOffset = e.filmOffset),
			this
		);
	}
	setFocalLength(e) {
		const t = (0.5 * this.getFilmHeight()) / e;
		(this.fov = vs * 2 * Math.atan(t)), this.updateProjectionMatrix();
	}
	getFocalLength() {
		const e = Math.tan(es * 0.5 * this.fov);
		return (0.5 * this.getFilmHeight()) / e;
	}
	getEffectiveFOV() {
		return vs * 2 * Math.atan(Math.tan(es * 0.5 * this.fov) / this.zoom);
	}
	getFilmWidth() {
		return this.filmGauge * Math.min(this.aspect, 1);
	}
	getFilmHeight() {
		return this.filmGauge / Math.max(this.aspect, 1);
	}
	setViewOffset(e, t, i, n, a, s) {
		(this.aspect = e / t),
		this.view === null &&
                (this.view = {
                	enabled: !0,
                	fullWidth: 1,
                	fullHeight: 1,
                	offsetX: 0,
                	offsetY: 0,
                	width: 1,
                	height: 1
                }),
		(this.view.enabled = !0),
		(this.view.fullWidth = e),
		(this.view.fullHeight = t),
		(this.view.offsetX = i),
		(this.view.offsetY = n),
		(this.view.width = a),
		(this.view.height = s),
		this.updateProjectionMatrix();
	}
	clearViewOffset() {
		this.view !== null && (this.view.enabled = !1),
		this.updateProjectionMatrix();
	}
	updateProjectionMatrix() {
		const e = this.near;
		let t = (e * Math.tan(es * 0.5 * this.fov)) / this.zoom,
			i = 2 * t,
			n = this.aspect * i,
			a = -0.5 * n;
		const s = this.view;
		if (this.view !== null && this.view.enabled) {
			const l = s.fullWidth,
				c = s.fullHeight;
			(a += (s.offsetX * n) / l),
			(t -= (s.offsetY * i) / c),
			(n *= s.width / l),
			(i *= s.height / c);
		}
		const o = this.filmOffset;
		o !== 0 && (a += (e * o) / this.getFilmWidth()),
		this.projectionMatrix.makePerspective(
			a,
			a + n,
			t,
			t - i,
			e,
			this.far
		),
		this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return (
			(t.object.fov = this.fov),
			(t.object.zoom = this.zoom),
			(t.object.near = this.near),
			(t.object.far = this.far),
			(t.object.focus = this.focus),
			(t.object.aspect = this.aspect),
			this.view !== null &&
                (t.object.view = Object.assign({}, this.view)),
			(t.object.filmGauge = this.filmGauge),
			(t.object.filmOffset = this.filmOffset),
			t
		);
	}
}
zt.prototype.isPerspectiveCamera = !0;
const kn = 90,
	Cn = 1;
class Du extends Je {
	constructor(e, t, i) {
		if (
			(super(),
			(this.type = 'CubeCamera'),
			i.isWebGLCubeRenderTarget !== !0)
		) {
			console.error(
				'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.'
			);
			return;
		}
		this.renderTarget = i;
		const n = new zt(kn, Cn, e, t);
		(n.layers = this.layers),
		n.up.set(0, -1, 0),
		n.lookAt(new C(1, 0, 0)),
		this.add(n);
		const a = new zt(kn, Cn, e, t);
		(a.layers = this.layers),
		a.up.set(0, -1, 0),
		a.lookAt(new C(-1, 0, 0)),
		this.add(a);
		const s = new zt(kn, Cn, e, t);
		(s.layers = this.layers),
		s.up.set(0, 0, 1),
		s.lookAt(new C(0, 1, 0)),
		this.add(s);
		const o = new zt(kn, Cn, e, t);
		(o.layers = this.layers),
		o.up.set(0, 0, -1),
		o.lookAt(new C(0, -1, 0)),
		this.add(o);
		const l = new zt(kn, Cn, e, t);
		(l.layers = this.layers),
		l.up.set(0, -1, 0),
		l.lookAt(new C(0, 0, 1)),
		this.add(l);
		const c = new zt(kn, Cn, e, t);
		(c.layers = this.layers),
		c.up.set(0, -1, 0),
		c.lookAt(new C(0, 0, -1)),
		this.add(c);
	}
	update(e, t) {
		this.parent === null && this.updateMatrixWorld();
		const i = this.renderTarget,
			[n, a, s, o, l, c] = this.children,
			u = e.getRenderTarget(),
			h = e.outputEncoding,
			d = e.toneMapping,
			p = e.xr.enabled;
		(e.outputEncoding = Qr), (e.toneMapping = $r), (e.xr.enabled = !1);
		const g = i.texture.generateMipmaps;
		(i.texture.generateMipmaps = !1),
		e.setRenderTarget(i, 0),
		e.render(t, n),
		e.setRenderTarget(i, 1),
		e.render(t, a),
		e.setRenderTarget(i, 2),
		e.render(t, s),
		e.setRenderTarget(i, 3),
		e.render(t, o),
		e.setRenderTarget(i, 4),
		e.render(t, l),
		(i.texture.generateMipmaps = g),
		e.setRenderTarget(i, 5),
		e.render(t, c),
		e.setRenderTarget(u),
		(e.outputEncoding = h),
		(e.toneMapping = d),
		(e.xr.enabled = p),
		(i.texture.needsPMREMUpdate = !0);
	}
}
class nl extends wt {
	constructor(e, t, i, n, a, s, o, l, c, u) {
		(e = e !== void 0 ? e : []),
		(t = t !== void 0 ? t : aa),
		super(e, t, i, n, a, s, o, l, c, u),
		(this.flipY = !1);
	}
	get images() {
		return this.image;
	}
	set images(e) {
		this.image = e;
	}
}
nl.prototype.isCubeTexture = !0;
class Uf extends Xt {
	constructor(e, t = {}) {
		super(e, e, t);
		const i = { width: e, height: e, depth: 1 },
			n = [i, i, i, i, i, i];
		(this.texture = new nl(
			n,
			t.mapping,
			t.wrapS,
			t.wrapT,
			t.magFilter,
			t.minFilter,
			t.format,
			t.type,
			t.anisotropy,
			t.encoding
		)),
		(this.texture.isRenderTargetTexture = !0),
		(this.texture.generateMipmaps =
                t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
		(this.texture.minFilter =
                t.minFilter !== void 0 ? t.minFilter : Nt);
	}
	fromEquirectangularTexture(e, t) {
		(this.texture.type = t.type),
		(this.texture.encoding = t.encoding),
		(this.texture.generateMipmaps = t.generateMipmaps),
		(this.texture.minFilter = t.minFilter),
		(this.texture.magFilter = t.magFilter);
		const i = {
				uniforms: { tEquirect: { value: null } },
				vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
				fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
			},
			n = new _a(5, 5, 5),
			a = new br({
				name: 'CubemapFromEquirect',
				uniforms: ua(i.uniforms),
				vertexShader: i.vertexShader,
				fragmentShader: i.fragmentShader,
				side: rr,
				blending: Ei
			});
		a.uniforms.tEquirect.value = t;
		const s = new rt(n, a),
			o = t.minFilter;
		return (
			t.minFilter === ba && (t.minFilter = Nt),
			new Du(1, 10, this).update(e, s),
			(t.minFilter = o),
			s.geometry.dispose(),
			s.material.dispose(),
			this
		);
	}
	clear(e, t, i, n) {
		const a = e.getRenderTarget();
		for (let s = 0; s < 6; s++)
			e.setRenderTarget(this, s), e.clear(t, i, n);
		e.setRenderTarget(a);
	}
}
Uf.prototype.isWebGLCubeRenderTarget = !0;
const Jl = new C(),
	Pb = new C(),
	Ib = new kt();
class Xr {
	constructor(e = new C(1, 0, 0), t = 0) {
		(this.normal = e), (this.constant = t);
	}
	set(e, t) {
		return this.normal.copy(e), (this.constant = t), this;
	}
	setComponents(e, t, i, n) {
		return this.normal.set(e, t, i), (this.constant = n), this;
	}
	setFromNormalAndCoplanarPoint(e, t) {
		return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
	}
	setFromCoplanarPoints(e, t, i) {
		const n = Jl.subVectors(i, t).cross(Pb.subVectors(e, t)).normalize();
		return this.setFromNormalAndCoplanarPoint(n, e), this;
	}
	copy(e) {
		return this.normal.copy(e.normal), (this.constant = e.constant), this;
	}
	normalize() {
		const e = 1 / this.normal.length();
		return this.normal.multiplyScalar(e), (this.constant *= e), this;
	}
	negate() {
		return (this.constant *= -1), this.normal.negate(), this;
	}
	distanceToPoint(e) {
		return this.normal.dot(e) + this.constant;
	}
	distanceToSphere(e) {
		return this.distanceToPoint(e.center) - e.radius;
	}
	projectPoint(e, t) {
		return t
			.copy(this.normal)
			.multiplyScalar(-this.distanceToPoint(e))
			.add(e);
	}
	intersectLine(e, t) {
		const i = e.delta(Jl),
			n = this.normal.dot(i);
		if (n === 0)
			return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
		const a = -(e.start.dot(this.normal) + this.constant) / n;
		return a < 0 || a > 1 ? null : t.copy(i).multiplyScalar(a).add(e.start);
	}
	intersectsLine(e) {
		const t = this.distanceToPoint(e.start),
			i = this.distanceToPoint(e.end);
		return (t < 0 && i > 0) || (i < 0 && t > 0);
	}
	intersectsBox(e) {
		return e.intersectsPlane(this);
	}
	intersectsSphere(e) {
		return e.intersectsPlane(this);
	}
	coplanarPoint(e) {
		return e.copy(this.normal).multiplyScalar(-this.constant);
	}
	applyMatrix4(e, t) {
		const i = t || Ib.getNormalMatrix(e),
			n = this.coplanarPoint(Jl).applyMatrix4(e),
			a = this.normal.applyMatrix3(i).normalize();
		return (this.constant = -n.dot(a)), this;
	}
	translate(e) {
		return (this.constant -= e.dot(this.normal)), this;
	}
	equals(e) {
		return e.normal.equals(this.normal) && e.constant === this.constant;
	}
	clone() {
		return new this.constructor().copy(this);
	}
}
Xr.prototype.isPlane = !0;
const Pn = new dn(),
	io = new C();
class al {
	constructor(
		e = new Xr(),
		t = new Xr(),
		i = new Xr(),
		n = new Xr(),
		a = new Xr(),
		s = new Xr()
	) {
		this.planes = [e, t, i, n, a, s];
	}
	set(e, t, i, n, a, s) {
		const o = this.planes;
		return (
			o[0].copy(e),
			o[1].copy(t),
			o[2].copy(i),
			o[3].copy(n),
			o[4].copy(a),
			o[5].copy(s),
			this
		);
	}
	copy(e) {
		const t = this.planes;
		for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
		return this;
	}
	setFromProjectionMatrix(e) {
		const t = this.planes,
			i = e.elements,
			n = i[0],
			a = i[1],
			s = i[2],
			o = i[3],
			l = i[4],
			c = i[5],
			u = i[6],
			h = i[7],
			d = i[8],
			p = i[9],
			g = i[10],
			m = i[11],
			f = i[12],
			v = i[13],
			x = i[14],
			A = i[15];
		return (
			t[0].setComponents(o - n, h - l, m - d, A - f).normalize(),
			t[1].setComponents(o + n, h + l, m + d, A + f).normalize(),
			t[2].setComponents(o + a, h + c, m + p, A + v).normalize(),
			t[3].setComponents(o - a, h - c, m - p, A - v).normalize(),
			t[4].setComponents(o - s, h - u, m - g, A - x).normalize(),
			t[5].setComponents(o + s, h + u, m + g, A + x).normalize(),
			this
		);
	}
	intersectsObject(e) {
		const t = e.geometry;
		return (
			t.boundingSphere === null && t.computeBoundingSphere(),
			Pn.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
			this.intersectsSphere(Pn)
		);
	}
	intersectsSprite(e) {
		return (
			Pn.center.set(0, 0, 0),
			(Pn.radius = 0.7071067811865476),
			Pn.applyMatrix4(e.matrixWorld),
			this.intersectsSphere(Pn)
		);
	}
	intersectsSphere(e) {
		const t = this.planes,
			i = e.center,
			n = -e.radius;
		for (let a = 0; a < 6; a++) if (t[a].distanceToPoint(i) < n) return !1;
		return !0;
	}
	intersectsBox(e) {
		const t = this.planes;
		for (let i = 0; i < 6; i++) {
			const n = t[i];
			if (
				((io.x = n.normal.x > 0 ? e.max.x : e.min.x),
				(io.y = n.normal.y > 0 ? e.max.y : e.min.y),
				(io.z = n.normal.z > 0 ? e.max.z : e.min.z),
				n.distanceToPoint(io) < 0)
			)
				return !1;
		}
		return !0;
	}
	containsPoint(e) {
		const t = this.planes;
		for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return !1;
		return !0;
	}
	clone() {
		return new this.constructor().copy(this);
	}
}
function Bf() {
	let r = null,
		e = !1,
		t = null,
		i = null;
	function n(a, s) {
		t(a, s), (i = r.requestAnimationFrame(n));
	}
	return {
		start: function () {
			e !== !0 &&
                t !== null &&
                ((i = r.requestAnimationFrame(n)), (e = !0));
		},
		stop: function () {
			r.cancelAnimationFrame(i), (e = !1);
		},
		setAnimationLoop: function (a) {
			t = a;
		},
		setContext: function (a) {
			r = a;
		}
	};
}
function Db(r, e) {
	const t = e.isWebGL2,
		i = new WeakMap();
	function n(c, u) {
		const h = c.array,
			d = c.usage,
			p = r.createBuffer();
		r.bindBuffer(u, p), r.bufferData(u, h, d), c.onUploadCallback();
		let g;
		if (h instanceof Float32Array) g = 5126;
		else if (h instanceof Uint16Array)
			if (c.isFloat16BufferAttribute)
				if (t) g = 5131;
				else
					throw new Error(
						'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.'
					);
			else g = 5123;
		else if (h instanceof Int16Array) g = 5122;
		else if (h instanceof Uint32Array) g = 5125;
		else if (h instanceof Int32Array) g = 5124;
		else if (h instanceof Int8Array) g = 5120;
		else if (h instanceof Uint8Array) g = 5121;
		else if (h instanceof Uint8ClampedArray) g = 5121;
		else
			throw new Error(
				'THREE.WebGLAttributes: Unsupported buffer data format: ' + h
			);
		return {
			buffer: p,
			type: g,
			bytesPerElement: h.BYTES_PER_ELEMENT,
			version: c.version
		};
	}
	function a(c, u, h) {
		const d = u.array,
			p = u.updateRange;
		r.bindBuffer(h, c),
		p.count === -1
			? r.bufferSubData(h, 0, d)
			: (t
				? r.bufferSubData(
					h,
					p.offset * d.BYTES_PER_ELEMENT,
					d,
					p.offset,
					p.count
				)
				: r.bufferSubData(
					h,
					p.offset * d.BYTES_PER_ELEMENT,
					d.subarray(p.offset, p.offset + p.count)
				),
			(p.count = -1));
	}
	function s(c) {
		return c.isInterleavedBufferAttribute && (c = c.data), i.get(c);
	}
	function o(c) {
		c.isInterleavedBufferAttribute && (c = c.data);
		const u = i.get(c);
		u && (r.deleteBuffer(u.buffer), i.delete(c));
	}
	function l(c, u) {
		if (c.isGLBufferAttribute) {
			const d = i.get(c);
			(!d || d.version < c.version) &&
                i.set(c, {
                	buffer: c.buffer,
                	type: c.type,
                	bytesPerElement: c.elementSize,
                	version: c.version
                });
			return;
		}
		c.isInterleavedBufferAttribute && (c = c.data);
		const h = i.get(c);
		h === void 0
			? i.set(c, n(c, u))
			: h.version < c.version &&
              (a(h.buffer, c, u), (h.version = c.version));
	}
	return { get: s, remove: o, update: l };
}
class Ou extends ot {
	constructor(e = 1, t = 1, i = 1, n = 1) {
		super(),
		(this.type = 'PlaneGeometry'),
		(this.parameters = {
			width: e,
			height: t,
			widthSegments: i,
			heightSegments: n
		});
		const a = e / 2,
			s = t / 2,
			o = Math.floor(i),
			l = Math.floor(n),
			c = o + 1,
			u = l + 1,
			h = e / o,
			d = t / l,
			p = [],
			g = [],
			m = [],
			f = [];
		for (let v = 0; v < u; v++) {
			const x = v * d - s;
			for (let A = 0; A < c; A++) {
				const S = A * h - a;
				g.push(S, -x, 0),
				m.push(0, 0, 1),
				f.push(A / o),
				f.push(1 - v / l);
			}
		}
		for (let v = 0; v < l; v++)
			for (let x = 0; x < o; x++) {
				const A = x + c * v,
					S = x + c * (v + 1),
					M = x + 1 + c * (v + 1),
					I = x + 1 + c * v;
				p.push(A, S, I), p.push(S, M, I);
			}
		this.setIndex(p),
		this.setAttribute('position', new yt(g, 3)),
		this.setAttribute('normal', new yt(m, 3)),
		this.setAttribute('uv', new yt(f, 2));
	}
	static fromJSON(e) {
		return new Ou(e.width, e.height, e.widthSegments, e.heightSegments);
	}
}
var Ob = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,
	Nb = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
	zb = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
	Ub = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
	Bb = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
	Fb = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
	Hb = 'vec3 transformed = vec3( position );',
	Gb = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
	Vb = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,
	Wb = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
	jb = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
	Xb = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
	qb = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
	Yb = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
	Zb = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
	$b = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
	Kb = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
	Jb = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
	Qb = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,
	e1 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
	t1 = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
	r1 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
	i1 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,
	n1 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
	a1 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
	s1 = 'gl_FragColor = linearToOutputTexel( gl_FragColor );',
	o1 = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
	l1 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
	c1 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
	u1 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
	h1 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
	d1 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
	p1 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
	m1 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
	f1 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
	g1 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
	v1 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,
	y1 = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
	x1 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
	b1 = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,
	w1 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
	_1 = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,
	M1 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
	S1 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,
	T1 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
	E1 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,
	A1 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,
	L1 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
	R1 = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
	k1 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
	C1 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
	P1 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
	I1 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
	D1 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
	O1 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
	N1 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
	z1 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
	U1 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
	B1 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
	F1 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
	H1 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
	G1 = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
	V1 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
	W1 = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
	j1 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
	X1 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,
	q1 = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
	Y1 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
	Z1 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
	$1 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
	K1 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,
	J1 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
	Q1 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,
	ew = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,
	tw = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
	rw = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,
	iw = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
	nw = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
	aw = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
	sw = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
	ow = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
	lw = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
	cw = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
	uw = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
	hw = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,
	dw = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
	pw = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
	mw = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,
	fw = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
	gw = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
	vw = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
	yw = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
	xw = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
	bw = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
	ww = `#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,
	_w = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,
	Mw = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,
	Sw = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,
	Tw = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
	Ew = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
	Aw = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,
	Lw = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,
	Rw = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const kw = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
	Cw = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
	Pw = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
	Iw = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
	Dw = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
	Ow = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
	Nw = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
	zw = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
	Uw = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
	Bw = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
	Fw = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
	Hw = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
	Gw = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
	Vw = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
	Ww = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
	jw = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
	Xw = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
	qw = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
	Yw = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
	Zw = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
	$w = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
	Kw = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
	Jw = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
	Qw = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
	e_ = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
	t_ = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
	r_ = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
	i_ = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
	n_ = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
	a_ = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
	s_ = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
	o_ = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
	Ve = {
		alphamap_fragment: Ob,
		alphamap_pars_fragment: Nb,
		alphatest_fragment: zb,
		alphatest_pars_fragment: Ub,
		aomap_fragment: Bb,
		aomap_pars_fragment: Fb,
		begin_vertex: Hb,
		beginnormal_vertex: Gb,
		bsdfs: Vb,
		bumpmap_pars_fragment: Wb,
		clipping_planes_fragment: jb,
		clipping_planes_pars_fragment: Xb,
		clipping_planes_pars_vertex: qb,
		clipping_planes_vertex: Yb,
		color_fragment: Zb,
		color_pars_fragment: $b,
		color_pars_vertex: Kb,
		color_vertex: Jb,
		common: Qb,
		cube_uv_reflection_fragment: e1,
		defaultnormal_vertex: t1,
		displacementmap_pars_vertex: r1,
		displacementmap_vertex: i1,
		emissivemap_fragment: n1,
		emissivemap_pars_fragment: a1,
		encodings_fragment: s1,
		encodings_pars_fragment: o1,
		envmap_fragment: l1,
		envmap_common_pars_fragment: c1,
		envmap_pars_fragment: u1,
		envmap_pars_vertex: h1,
		envmap_physical_pars_fragment: _1,
		envmap_vertex: d1,
		fog_vertex: p1,
		fog_pars_vertex: m1,
		fog_fragment: f1,
		fog_pars_fragment: g1,
		gradientmap_pars_fragment: v1,
		lightmap_fragment: y1,
		lightmap_pars_fragment: x1,
		lights_lambert_vertex: b1,
		lights_pars_begin: w1,
		lights_toon_fragment: M1,
		lights_toon_pars_fragment: S1,
		lights_phong_fragment: T1,
		lights_phong_pars_fragment: E1,
		lights_physical_fragment: A1,
		lights_physical_pars_fragment: L1,
		lights_fragment_begin: R1,
		lights_fragment_maps: k1,
		lights_fragment_end: C1,
		logdepthbuf_fragment: P1,
		logdepthbuf_pars_fragment: I1,
		logdepthbuf_pars_vertex: D1,
		logdepthbuf_vertex: O1,
		map_fragment: N1,
		map_pars_fragment: z1,
		map_particle_fragment: U1,
		map_particle_pars_fragment: B1,
		metalnessmap_fragment: F1,
		metalnessmap_pars_fragment: H1,
		morphcolor_vertex: G1,
		morphnormal_vertex: V1,
		morphtarget_pars_vertex: W1,
		morphtarget_vertex: j1,
		normal_fragment_begin: X1,
		normal_fragment_maps: q1,
		normal_pars_fragment: Y1,
		normal_pars_vertex: Z1,
		normal_vertex: $1,
		normalmap_pars_fragment: K1,
		clearcoat_normal_fragment_begin: J1,
		clearcoat_normal_fragment_maps: Q1,
		clearcoat_pars_fragment: ew,
		output_fragment: tw,
		packing: rw,
		premultiplied_alpha_fragment: iw,
		project_vertex: nw,
		dithering_fragment: aw,
		dithering_pars_fragment: sw,
		roughnessmap_fragment: ow,
		roughnessmap_pars_fragment: lw,
		shadowmap_pars_fragment: cw,
		shadowmap_pars_vertex: uw,
		shadowmap_vertex: hw,
		shadowmask_pars_fragment: dw,
		skinbase_vertex: pw,
		skinning_pars_vertex: mw,
		skinning_vertex: fw,
		skinnormal_vertex: gw,
		specularmap_fragment: vw,
		specularmap_pars_fragment: yw,
		tonemapping_fragment: xw,
		tonemapping_pars_fragment: bw,
		transmission_fragment: ww,
		transmission_pars_fragment: _w,
		uv_pars_fragment: Mw,
		uv_pars_vertex: Sw,
		uv_vertex: Tw,
		uv2_pars_fragment: Ew,
		uv2_pars_vertex: Aw,
		uv2_vertex: Lw,
		worldpos_vertex: Rw,
		background_vert: kw,
		background_frag: Cw,
		cube_vert: Pw,
		cube_frag: Iw,
		depth_vert: Dw,
		depth_frag: Ow,
		distanceRGBA_vert: Nw,
		distanceRGBA_frag: zw,
		equirect_vert: Uw,
		equirect_frag: Bw,
		linedashed_vert: Fw,
		linedashed_frag: Hw,
		meshbasic_vert: Gw,
		meshbasic_frag: Vw,
		meshlambert_vert: Ww,
		meshlambert_frag: jw,
		meshmatcap_vert: Xw,
		meshmatcap_frag: qw,
		meshnormal_vert: Yw,
		meshnormal_frag: Zw,
		meshphong_vert: $w,
		meshphong_frag: Kw,
		meshphysical_vert: Jw,
		meshphysical_frag: Qw,
		meshtoon_vert: e_,
		meshtoon_frag: t_,
		points_vert: r_,
		points_frag: i_,
		shadow_vert: n_,
		shadow_frag: a_,
		sprite_vert: s_,
		sprite_frag: o_
	},
	Ee = {
		common: {
			diffuse: { value: new ke(16777215) },
			opacity: { value: 1 },
			map: { value: null },
			uvTransform: { value: new kt() },
			uv2Transform: { value: new kt() },
			alphaMap: { value: null },
			alphaTest: { value: 0 }
		},
		specularmap: { specularMap: { value: null } },
		envmap: {
			envMap: { value: null },
			flipEnvMap: { value: -1 },
			reflectivity: { value: 1 },
			ior: { value: 1.5 },
			refractionRatio: { value: 0.98 }
		},
		aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
		lightmap: {
			lightMap: { value: null },
			lightMapIntensity: { value: 1 }
		},
		emissivemap: { emissiveMap: { value: null } },
		bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
		normalmap: {
			normalMap: { value: null },
			normalScale: { value: new me(1, 1) }
		},
		displacementmap: {
			displacementMap: { value: null },
			displacementScale: { value: 1 },
			displacementBias: { value: 0 }
		},
		roughnessmap: { roughnessMap: { value: null } },
		metalnessmap: { metalnessMap: { value: null } },
		gradientmap: { gradientMap: { value: null } },
		fog: {
			fogDensity: { value: 25e-5 },
			fogNear: { value: 1 },
			fogFar: { value: 2e3 },
			fogColor: { value: new ke(16777215) }
		},
		lights: {
			ambientLightColor: { value: [] },
			lightProbe: { value: [] },
			directionalLights: {
				value: [],
				properties: { direction: {}, color: {} }
			},
			directionalLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},
			directionalShadowMap: { value: [] },
			directionalShadowMatrix: { value: [] },
			spotLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					direction: {},
					distance: {},
					coneCos: {},
					penumbraCos: {},
					decay: {}
				}
			},
			spotLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},
			spotShadowMap: { value: [] },
			spotShadowMatrix: { value: [] },
			pointLights: {
				value: [],
				properties: { color: {}, position: {}, decay: {}, distance: {} }
			},
			pointLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {},
					shadowCameraNear: {},
					shadowCameraFar: {}
				}
			},
			pointShadowMap: { value: [] },
			pointShadowMatrix: { value: [] },
			hemisphereLights: {
				value: [],
				properties: { direction: {}, skyColor: {}, groundColor: {} }
			},
			rectAreaLights: {
				value: [],
				properties: { color: {}, position: {}, width: {}, height: {} }
			},
			ltc_1: { value: null },
			ltc_2: { value: null }
		},
		points: {
			diffuse: { value: new ke(16777215) },
			opacity: { value: 1 },
			size: { value: 1 },
			scale: { value: 1 },
			map: { value: null },
			alphaMap: { value: null },
			alphaTest: { value: 0 },
			uvTransform: { value: new kt() }
		},
		sprite: {
			diffuse: { value: new ke(16777215) },
			opacity: { value: 1 },
			center: { value: new me(0.5, 0.5) },
			rotation: { value: 0 },
			map: { value: null },
			alphaMap: { value: null },
			alphaTest: { value: 0 },
			uvTransform: { value: new kt() }
		}
	},
	kr = {
		basic: {
			uniforms: Dt([
				Ee.common,
				Ee.specularmap,
				Ee.envmap,
				Ee.aomap,
				Ee.lightmap,
				Ee.fog
			]),
			vertexShader: Ve.meshbasic_vert,
			fragmentShader: Ve.meshbasic_frag
		},
		lambert: {
			uniforms: Dt([
				Ee.common,
				Ee.specularmap,
				Ee.envmap,
				Ee.aomap,
				Ee.lightmap,
				Ee.emissivemap,
				Ee.fog,
				Ee.lights,
				{ emissive: { value: new ke(0) } }
			]),
			vertexShader: Ve.meshlambert_vert,
			fragmentShader: Ve.meshlambert_frag
		},
		phong: {
			uniforms: Dt([
				Ee.common,
				Ee.specularmap,
				Ee.envmap,
				Ee.aomap,
				Ee.lightmap,
				Ee.emissivemap,
				Ee.bumpmap,
				Ee.normalmap,
				Ee.displacementmap,
				Ee.fog,
				Ee.lights,
				{
					emissive: { value: new ke(0) },
					specular: { value: new ke(1118481) },
					shininess: { value: 30 }
				}
			]),
			vertexShader: Ve.meshphong_vert,
			fragmentShader: Ve.meshphong_frag
		},
		standard: {
			uniforms: Dt([
				Ee.common,
				Ee.envmap,
				Ee.aomap,
				Ee.lightmap,
				Ee.emissivemap,
				Ee.bumpmap,
				Ee.normalmap,
				Ee.displacementmap,
				Ee.roughnessmap,
				Ee.metalnessmap,
				Ee.fog,
				Ee.lights,
				{
					emissive: { value: new ke(0) },
					roughness: { value: 1 },
					metalness: { value: 0 },
					envMapIntensity: { value: 1 }
				}
			]),
			vertexShader: Ve.meshphysical_vert,
			fragmentShader: Ve.meshphysical_frag
		},
		toon: {
			uniforms: Dt([
				Ee.common,
				Ee.aomap,
				Ee.lightmap,
				Ee.emissivemap,
				Ee.bumpmap,
				Ee.normalmap,
				Ee.displacementmap,
				Ee.gradientmap,
				Ee.fog,
				Ee.lights,
				{ emissive: { value: new ke(0) } }
			]),
			vertexShader: Ve.meshtoon_vert,
			fragmentShader: Ve.meshtoon_frag
		},
		matcap: {
			uniforms: Dt([
				Ee.common,
				Ee.bumpmap,
				Ee.normalmap,
				Ee.displacementmap,
				Ee.fog,
				{ matcap: { value: null } }
			]),
			vertexShader: Ve.meshmatcap_vert,
			fragmentShader: Ve.meshmatcap_frag
		},
		points: {
			uniforms: Dt([Ee.points, Ee.fog]),
			vertexShader: Ve.points_vert,
			fragmentShader: Ve.points_frag
		},
		dashed: {
			uniforms: Dt([
				Ee.common,
				Ee.fog,
				{
					scale: { value: 1 },
					dashSize: { value: 1 },
					totalSize: { value: 2 }
				}
			]),
			vertexShader: Ve.linedashed_vert,
			fragmentShader: Ve.linedashed_frag
		},
		depth: {
			uniforms: Dt([Ee.common, Ee.displacementmap]),
			vertexShader: Ve.depth_vert,
			fragmentShader: Ve.depth_frag
		},
		normal: {
			uniforms: Dt([
				Ee.common,
				Ee.bumpmap,
				Ee.normalmap,
				Ee.displacementmap,
				{ opacity: { value: 1 } }
			]),
			vertexShader: Ve.meshnormal_vert,
			fragmentShader: Ve.meshnormal_frag
		},
		sprite: {
			uniforms: Dt([Ee.sprite, Ee.fog]),
			vertexShader: Ve.sprite_vert,
			fragmentShader: Ve.sprite_frag
		},
		background: {
			uniforms: {
				uvTransform: { value: new kt() },
				t2D: { value: null }
			},
			vertexShader: Ve.background_vert,
			fragmentShader: Ve.background_frag
		},
		cube: {
			uniforms: Dt([Ee.envmap, { opacity: { value: 1 } }]),
			vertexShader: Ve.cube_vert,
			fragmentShader: Ve.cube_frag
		},
		equirect: {
			uniforms: { tEquirect: { value: null } },
			vertexShader: Ve.equirect_vert,
			fragmentShader: Ve.equirect_frag
		},
		distanceRGBA: {
			uniforms: Dt([
				Ee.common,
				Ee.displacementmap,
				{
					referencePosition: { value: new C() },
					nearDistance: { value: 1 },
					farDistance: { value: 1e3 }
				}
			]),
			vertexShader: Ve.distanceRGBA_vert,
			fragmentShader: Ve.distanceRGBA_frag
		},
		shadow: {
			uniforms: Dt([
				Ee.lights,
				Ee.fog,
				{ color: { value: new ke(0) }, opacity: { value: 1 } }
			]),
			vertexShader: Ve.shadow_vert,
			fragmentShader: Ve.shadow_frag
		}
	};
kr.physical = {
	uniforms: Dt([
		kr.standard.uniforms,
		{
			clearcoat: { value: 0 },
			clearcoatMap: { value: null },
			clearcoatRoughness: { value: 0 },
			clearcoatRoughnessMap: { value: null },
			clearcoatNormalScale: { value: new me(1, 1) },
			clearcoatNormalMap: { value: null },
			sheen: { value: 0 },
			sheenColor: { value: new ke(0) },
			sheenColorMap: { value: null },
			sheenRoughness: { value: 1 },
			sheenRoughnessMap: { value: null },
			transmission: { value: 0 },
			transmissionMap: { value: null },
			transmissionSamplerSize: { value: new me() },
			transmissionSamplerMap: { value: null },
			thickness: { value: 0 },
			thicknessMap: { value: null },
			attenuationDistance: { value: 0 },
			attenuationColor: { value: new ke(0) },
			specularIntensity: { value: 1 },
			specularIntensityMap: { value: null },
			specularColor: { value: new ke(1, 1, 1) },
			specularColorMap: { value: null }
		}
	]),
	vertexShader: Ve.meshphysical_vert,
	fragmentShader: Ve.meshphysical_frag
};
function l_(r, e, t, i, n, a) {
	const s = new ke(0);
	let o = n === !0 ? 0 : 1,
		l,
		c,
		u = null,
		h = 0,
		d = null;
	function p(m, f) {
		let v = !1,
			x = f.isScene === !0 ? f.background : null;
		x && x.isTexture && (x = e.get(x));
		const A = r.xr,
			S = A.getSession && A.getSession();
		S && S.environmentBlendMode === 'additive' && (x = null),
		x === null ? g(s, o) : x && x.isColor && (g(x, 1), (v = !0)),
		(r.autoClear || v) &&
                r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil),
		x && (x.isCubeTexture || x.mapping === rl)
			? (c === void 0 &&
                      ((c = new rt(
                      	new _a(1, 1, 1),
                      	new br({
                      		name: 'BackgroundCubeMaterial',
                      		uniforms: ua(kr.cube.uniforms),
                      		vertexShader: kr.cube.vertexShader,
                      		fragmentShader: kr.cube.fragmentShader,
                      		side: rr,
                      		depthTest: !1,
                      		depthWrite: !1,
                      		fog: !1
                      	})
                      )),
                      c.geometry.deleteAttribute('normal'),
                      c.geometry.deleteAttribute('uv'),
                      (c.onBeforeRender = function (M, I, D) {
                      	this.matrixWorld.copyPosition(D.matrixWorld);
                      }),
                      Object.defineProperty(c.material, 'envMap', {
                      	get: function () {
                      		return this.uniforms.envMap.value;
                      	}
                      }),
                      i.update(c)),
			(c.material.uniforms.envMap.value = x),
			(c.material.uniforms.flipEnvMap.value =
                      x.isCubeTexture && x.isRenderTargetTexture === !1
                      	? -1
                      	: 1),
			(u !== x || h !== x.version || d !== r.toneMapping) &&
                      ((c.material.needsUpdate = !0),
                      (u = x),
                      (h = x.version),
                      (d = r.toneMapping)),
			m.unshift(c, c.geometry, c.material, 0, 0, null))
			: x &&
                  x.isTexture &&
                  (l === void 0 &&
                      ((l = new rt(
                      	new Ou(2, 2),
                      	new br({
                      		name: 'BackgroundMaterial',
                      		uniforms: ua(kr.background.uniforms),
                      		vertexShader: kr.background.vertexShader,
                      		fragmentShader: kr.background.fragmentShader,
                      		side: na,
                      		depthTest: !1,
                      		depthWrite: !1,
                      		fog: !1
                      	})
                      )),
                      l.geometry.deleteAttribute('normal'),
                      Object.defineProperty(l.material, 'map', {
                      	get: function () {
                      		return this.uniforms.t2D.value;
                      	}
                      }),
                      i.update(l)),
                  (l.material.uniforms.t2D.value = x),
                  x.matrixAutoUpdate === !0 && x.updateMatrix(),
                  l.material.uniforms.uvTransform.value.copy(x.matrix),
                  (u !== x || h !== x.version || d !== r.toneMapping) &&
                      ((l.material.needsUpdate = !0),
                      (u = x),
                      (h = x.version),
                      (d = r.toneMapping)),
                  m.unshift(l, l.geometry, l.material, 0, 0, null));
	}
	function g(m, f) {
		t.buffers.color.setClear(m.r, m.g, m.b, f, a);
	}
	return {
		getClearColor: function () {
			return s;
		},
		setClearColor: function (m, f = 1) {
			s.set(m), (o = f), g(s, o);
		},
		getClearAlpha: function () {
			return o;
		},
		setClearAlpha: function (m) {
			(o = m), g(s, o);
		},
		render: p
	};
}
function c_(r, e, t, i) {
	const n = r.getParameter(34921),
		a = i.isWebGL2 ? null : e.get('OES_vertex_array_object'),
		s = i.isWebGL2 || a !== null,
		o = {},
		l = f(null);
	let c = l,
		u = !1;
	function h(z, V, H, k, P) {
		let Z = !1;
		if (s) {
			const J = m(k, H, V);
			c !== J && ((c = J), p(c.object)), (Z = v(k, P)), Z && x(k, P);
		} else {
			const J = V.wireframe === !0;
			(c.geometry !== k.id || c.program !== H.id || c.wireframe !== J) &&
                ((c.geometry = k.id),
                (c.program = H.id),
                (c.wireframe = J),
                (Z = !0));
		}
		z.isInstancedMesh === !0 && (Z = !0),
		P !== null && t.update(P, 34963),
		(Z || u) &&
                ((u = !1),
                G(z, V, H, k),
                P !== null && r.bindBuffer(34963, t.get(P).buffer));
	}
	function d() {
		return i.isWebGL2 ? r.createVertexArray() : a.createVertexArrayOES();
	}
	function p(z) {
		return i.isWebGL2 ? r.bindVertexArray(z) : a.bindVertexArrayOES(z);
	}
	function g(z) {
		return i.isWebGL2 ? r.deleteVertexArray(z) : a.deleteVertexArrayOES(z);
	}
	function m(z, V, H) {
		const k = H.wireframe === !0;
		let P = o[z.id];
		P === void 0 && ((P = {}), (o[z.id] = P));
		let Z = P[V.id];
		Z === void 0 && ((Z = {}), (P[V.id] = Z));
		let J = Z[k];
		return J === void 0 && ((J = f(d())), (Z[k] = J)), J;
	}
	function f(z) {
		const V = [],
			H = [],
			k = [];
		for (let P = 0; P < n; P++) (V[P] = 0), (H[P] = 0), (k[P] = 0);
		return {
			geometry: null,
			program: null,
			wireframe: !1,
			newAttributes: V,
			enabledAttributes: H,
			attributeDivisors: k,
			object: z,
			attributes: {},
			index: null
		};
	}
	function v(z, V) {
		const H = c.attributes,
			k = z.attributes;
		let P = 0;
		for (const Z in k) {
			const J = H[Z],
				fe = k[Z];
			if (J === void 0 || J.attribute !== fe || J.data !== fe.data)
				return !0;
			P++;
		}
		return c.attributesNum !== P || c.index !== V;
	}
	function x(z, V) {
		const H = {},
			k = z.attributes;
		let P = 0;
		for (const Z in k) {
			const J = k[Z],
				fe = {};
			(fe.attribute = J), J.data && (fe.data = J.data), (H[Z] = fe), P++;
		}
		(c.attributes = H), (c.attributesNum = P), (c.index = V);
	}
	function A() {
		const z = c.newAttributes;
		for (let V = 0, H = z.length; V < H; V++) z[V] = 0;
	}
	function S(z) {
		M(z, 0);
	}
	function M(z, V) {
		const H = c.newAttributes,
			k = c.enabledAttributes,
			P = c.attributeDivisors;
		(H[z] = 1),
		k[z] === 0 && (r.enableVertexAttribArray(z), (k[z] = 1)),
		P[z] !== V &&
                ((i.isWebGL2 ? r : e.get('ANGLE_instanced_arrays'))[
                	i.isWebGL2
                		? 'vertexAttribDivisor'
                		: 'vertexAttribDivisorANGLE'
                ](z, V),
                (P[z] = V));
	}
	function I() {
		const z = c.newAttributes,
			V = c.enabledAttributes;
		for (let H = 0, k = V.length; H < k; H++)
			V[H] !== z[H] && (r.disableVertexAttribArray(H), (V[H] = 0));
	}
	function D(z, V, H, k, P, Z) {
		i.isWebGL2 === !0 && (H === 5124 || H === 5125)
			? r.vertexAttribIPointer(z, V, H, P, Z)
			: r.vertexAttribPointer(z, V, H, k, P, Z);
	}
	function G(z, V, H, k) {
		if (
			i.isWebGL2 === !1 &&
            (z.isInstancedMesh || k.isInstancedBufferGeometry) &&
            e.get('ANGLE_instanced_arrays') === null
		)
			return;
		A();
		const P = k.attributes,
			Z = H.getAttributes(),
			J = V.defaultAttributeValues;
		for (const fe in Z) {
			const ce = Z[fe];
			if (ce.location >= 0) {
				let xe = P[fe];
				if (
					(xe === void 0 &&
                        (fe === 'instanceMatrix' &&
                            z.instanceMatrix &&
                            (xe = z.instanceMatrix),
                        fe === 'instanceColor' &&
                            z.instanceColor &&
                            (xe = z.instanceColor)),
					xe !== void 0)
				) {
					const W = xe.normalized,
						ue = xe.itemSize,
						U = t.get(xe);
					if (U === void 0) continue;
					const ve = U.buffer,
						Ae = U.type,
						Te = U.bytesPerElement;
					if (xe.isInterleavedBufferAttribute) {
						const ae = xe.data,
							K = ae.stride,
							te = xe.offset;
						if (ae.isInstancedInterleavedBuffer) {
							for (let w = 0; w < ce.locationSize; w++)
								M(ce.location + w, ae.meshPerAttribute);
							z.isInstancedMesh !== !0 &&
                                k._maxInstanceCount === void 0 &&
                                (k._maxInstanceCount =
                                    ae.meshPerAttribute * ae.count);
						} else
							for (let w = 0; w < ce.locationSize; w++)
								S(ce.location + w);
						r.bindBuffer(34962, ve);
						for (let w = 0; w < ce.locationSize; w++)
							D(
								ce.location + w,
								ue / ce.locationSize,
								Ae,
								W,
								K * Te,
								(te + (ue / ce.locationSize) * w) * Te
							);
					} else {
						if (xe.isInstancedBufferAttribute) {
							for (let ae = 0; ae < ce.locationSize; ae++)
								M(ce.location + ae, xe.meshPerAttribute);
							z.isInstancedMesh !== !0 &&
                                k._maxInstanceCount === void 0 &&
                                (k._maxInstanceCount =
                                    xe.meshPerAttribute * xe.count);
						} else
							for (let ae = 0; ae < ce.locationSize; ae++)
								S(ce.location + ae);
						r.bindBuffer(34962, ve);
						for (let ae = 0; ae < ce.locationSize; ae++)
							D(
								ce.location + ae,
								ue / ce.locationSize,
								Ae,
								W,
								ue * Te,
								(ue / ce.locationSize) * ae * Te
							);
					}
				} else if (J !== void 0) {
					const W = J[fe];
					if (W !== void 0)
						switch (W.length) {
						case 2:
							r.vertexAttrib2fv(ce.location, W);
							break;
						case 3:
							r.vertexAttrib3fv(ce.location, W);
							break;
						case 4:
							r.vertexAttrib4fv(ce.location, W);
							break;
						default:
							r.vertexAttrib1fv(ce.location, W);
						}
				}
			}
		}
		I();
	}
	function re() {
		E();
		for (const z in o) {
			const V = o[z];
			for (const H in V) {
				const k = V[H];
				for (const P in k) g(k[P].object), delete k[P];
				delete V[H];
			}
			delete o[z];
		}
	}
	function B(z) {
		if (o[z.id] === void 0) return;
		const V = o[z.id];
		for (const H in V) {
			const k = V[H];
			for (const P in k) g(k[P].object), delete k[P];
			delete V[H];
		}
		delete o[z.id];
	}
	function b(z) {
		for (const V in o) {
			const H = o[V];
			if (H[z.id] === void 0) continue;
			const k = H[z.id];
			for (const P in k) g(k[P].object), delete k[P];
			delete H[z.id];
		}
	}
	function E() {
		j(), (u = !0), c !== l && ((c = l), p(c.object));
	}
	function j() {
		(l.geometry = null), (l.program = null), (l.wireframe = !1);
	}
	return {
		setup: h,
		reset: E,
		resetDefaultState: j,
		dispose: re,
		releaseStatesOfGeometry: B,
		releaseStatesOfProgram: b,
		initAttributes: A,
		enableAttribute: S,
		disableUnusedAttributes: I
	};
}
function u_(r, e, t, i) {
	const n = i.isWebGL2;
	let a;
	function s(c) {
		a = c;
	}
	function o(c, u) {
		r.drawArrays(a, c, u), t.update(u, a, 1);
	}
	function l(c, u, h) {
		if (h === 0) return;
		let d, p;
		if (n) (d = r), (p = 'drawArraysInstanced');
		else if (
			((d = e.get('ANGLE_instanced_arrays')),
			(p = 'drawArraysInstancedANGLE'),
			d === null)
		) {
			console.error(
				'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.'
			);
			return;
		}
		d[p](a, c, u, h), t.update(u, a, h);
	}
	(this.setMode = s), (this.render = o), (this.renderInstances = l);
}
function h_(r, e, t) {
	let i;
	function n() {
		if (i !== void 0) return i;
		if (e.has('EXT_texture_filter_anisotropic') === !0) {
			const D = e.get('EXT_texture_filter_anisotropic');
			i = r.getParameter(D.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
		} else i = 0;
		return i;
	}
	function a(D) {
		if (D === 'highp') {
			if (
				r.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
                r.getShaderPrecisionFormat(35632, 36338).precision > 0
			)
				return 'highp';
			D = 'mediump';
		}
		return D === 'mediump' &&
            r.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
            r.getShaderPrecisionFormat(35632, 36337).precision > 0
			? 'mediump'
			: 'lowp';
	}
	const s =
        (typeof WebGL2RenderingContext != 'undefined' &&
            r instanceof WebGL2RenderingContext) ||
        (typeof WebGL2ComputeRenderingContext != 'undefined' &&
            r instanceof WebGL2ComputeRenderingContext);
	let o = t.precision !== void 0 ? t.precision : 'highp';
	const l = a(o);
	l !== o &&
        (console.warn(
        	'THREE.WebGLRenderer:',
        	o,
        	'not supported, using',
        	l,
        	'instead.'
        ),
        (o = l));
	const c = s || e.has('WEBGL_draw_buffers'),
		u = t.logarithmicDepthBuffer === !0,
		h = r.getParameter(34930),
		d = r.getParameter(35660),
		p = r.getParameter(3379),
		g = r.getParameter(34076),
		m = r.getParameter(34921),
		f = r.getParameter(36347),
		v = r.getParameter(36348),
		x = r.getParameter(36349),
		A = d > 0,
		S = s || e.has('OES_texture_float'),
		M = A && S,
		I = s ? r.getParameter(36183) : 0;
	return {
		isWebGL2: s,
		drawBuffers: c,
		getMaxAnisotropy: n,
		getMaxPrecision: a,
		precision: o,
		logarithmicDepthBuffer: u,
		maxTextures: h,
		maxVertexTextures: d,
		maxTextureSize: p,
		maxCubemapSize: g,
		maxAttributes: m,
		maxVertexUniforms: f,
		maxVaryings: v,
		maxFragmentUniforms: x,
		vertexTextures: A,
		floatFragmentTextures: S,
		floatVertexTextures: M,
		maxSamples: I
	};
}
function d_(r) {
	const e = this;
	let t = null,
		i = 0,
		n = !1,
		a = !1;
	const s = new Xr(),
		o = new kt(),
		l = { value: null, needsUpdate: !1 };
	(this.uniform = l),
	(this.numPlanes = 0),
	(this.numIntersection = 0),
	(this.init = function (h, d, p) {
		const g = h.length !== 0 || d || i !== 0 || n;
		return (n = d), (t = u(h, p, 0)), (i = h.length), g;
	}),
	(this.beginShadows = function () {
		(a = !0), u(null);
	}),
	(this.endShadows = function () {
		(a = !1), c();
	}),
	(this.setState = function (h, d, p) {
		const g = h.clippingPlanes,
			m = h.clipIntersection,
			f = h.clipShadows,
			v = r.get(h);
		if (!n || g === null || g.length === 0 || (a && !f))
			a ? u(null) : c();
		else {
			const x = a ? 0 : i,
				A = x * 4;
			let S = v.clippingState || null;
			(l.value = S), (S = u(g, d, A, p));
			for (let M = 0; M !== A; ++M) S[M] = t[M];
			(v.clippingState = S),
			(this.numIntersection = m ? this.numPlanes : 0),
			(this.numPlanes += x);
		}
	});
	function c() {
		l.value !== t && ((l.value = t), (l.needsUpdate = i > 0)),
		(e.numPlanes = i),
		(e.numIntersection = 0);
	}
	function u(h, d, p, g) {
		const m = h !== null ? h.length : 0;
		let f = null;
		if (m !== 0) {
			if (((f = l.value), g !== !0 || f === null)) {
				const v = p + m * 4,
					x = d.matrixWorldInverse;
				o.getNormalMatrix(x),
				(f === null || f.length < v) && (f = new Float32Array(v));
				for (let A = 0, S = p; A !== m; ++A, S += 4)
					s.copy(h[A]).applyMatrix4(x, o),
					s.normal.toArray(f, S),
					(f[S + 3] = s.constant);
			}
			(l.value = f), (l.needsUpdate = !0);
		}
		return (e.numPlanes = m), (e.numIntersection = 0), f;
	}
}
function p_(r) {
	let e = new WeakMap();
	function t(s, o) {
		return o === Bc ? (s.mapping = aa) : o === Fc && (s.mapping = sa), s;
	}
	function i(s) {
		if (s && s.isTexture && s.isRenderTargetTexture === !1) {
			const o = s.mapping;
			if (o === Bc || o === Fc)
				if (e.has(s)) {
					const l = e.get(s).texture;
					return t(l, s.mapping);
				} else {
					const l = s.image;
					if (l && l.height > 0) {
						const c = new Uf(l.height / 2);
						return (
							c.fromEquirectangularTexture(r, s),
							e.set(s, c),
							s.addEventListener('dispose', n),
							t(c.texture, s.mapping)
						);
					} else return null;
				}
		}
		return s;
	}
	function n(s) {
		const o = s.target;
		o.removeEventListener('dispose', n);
		const l = e.get(o);
		l !== void 0 && (e.delete(o), l.dispose());
	}
	function a() {
		e = new WeakMap();
	}
	return { get: i, dispose: a };
}
class sl extends Iu {
	constructor(e = -1, t = 1, i = 1, n = -1, a = 0.1, s = 2e3) {
		super(),
		(this.type = 'OrthographicCamera'),
		(this.zoom = 1),
		(this.view = null),
		(this.left = e),
		(this.right = t),
		(this.top = i),
		(this.bottom = n),
		(this.near = a),
		(this.far = s),
		this.updateProjectionMatrix();
	}
	copy(e, t) {
		return (
			super.copy(e, t),
			(this.left = e.left),
			(this.right = e.right),
			(this.top = e.top),
			(this.bottom = e.bottom),
			(this.near = e.near),
			(this.far = e.far),
			(this.zoom = e.zoom),
			(this.view = e.view === null ? null : Object.assign({}, e.view)),
			this
		);
	}
	setViewOffset(e, t, i, n, a, s) {
		this.view === null &&
            (this.view = {
            	enabled: !0,
            	fullWidth: 1,
            	fullHeight: 1,
            	offsetX: 0,
            	offsetY: 0,
            	width: 1,
            	height: 1
            }),
		(this.view.enabled = !0),
		(this.view.fullWidth = e),
		(this.view.fullHeight = t),
		(this.view.offsetX = i),
		(this.view.offsetY = n),
		(this.view.width = a),
		(this.view.height = s),
		this.updateProjectionMatrix();
	}
	clearViewOffset() {
		this.view !== null && (this.view.enabled = !1),
		this.updateProjectionMatrix();
	}
	updateProjectionMatrix() {
		const e = (this.right - this.left) / (2 * this.zoom),
			t = (this.top - this.bottom) / (2 * this.zoom),
			i = (this.right + this.left) / 2,
			n = (this.top + this.bottom) / 2;
		let a = i - e,
			s = i + e,
			o = n + t,
			l = n - t;
		if (this.view !== null && this.view.enabled) {
			const c =
                    (this.right - this.left) / this.view.fullWidth / this.zoom,
				u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
			(a += c * this.view.offsetX),
			(s = a + c * this.view.width),
			(o -= u * this.view.offsetY),
			(l = o - u * this.view.height);
		}
		this.projectionMatrix.makeOrthographic(a, s, o, l, this.near, this.far),
		this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return (
			(t.object.zoom = this.zoom),
			(t.object.left = this.left),
			(t.object.right = this.right),
			(t.object.top = this.top),
			(t.object.bottom = this.bottom),
			(t.object.near = this.near),
			(t.object.far = this.far),
			this.view !== null &&
                (t.object.view = Object.assign({}, this.view)),
			t
		);
	}
}
sl.prototype.isOrthographicCamera = !0;
const Yn = 4,
	Wd = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
	$i = 20,
	Ql = new sl(),
	jd = new ke();
let ec = null;
const Xi = (1 + Math.sqrt(5)) / 2,
	In = 1 / Xi,
	Xd = [
		new C(1, 1, 1),
		new C(-1, 1, 1),
		new C(1, 1, -1),
		new C(-1, 1, -1),
		new C(0, Xi, In),
		new C(0, Xi, -In),
		new C(In, 0, Xi),
		new C(-In, 0, Xi),
		new C(Xi, In, 0),
		new C(-Xi, In, 0)
	];
class jc {
	constructor(e) {
		(this._renderer = e),
		(this._pingPongRenderTarget = null),
		(this._lodMax = 0),
		(this._cubeSize = 0),
		(this._lodPlanes = []),
		(this._sizeLods = []),
		(this._sigmas = []),
		(this._blurMaterial = null),
		(this._cubemapMaterial = null),
		(this._equirectMaterial = null),
		this._compileMaterial(this._blurMaterial);
	}
	fromScene(e, t = 0, i = 0.1, n = 100) {
		(ec = this._renderer.getRenderTarget()), this._setSize(256);
		const a = this._allocateTargets();
		return (
			(a.depthBuffer = !0),
			this._sceneToCubeUV(e, i, n, a),
			t > 0 && this._blur(a, 0, 0, t),
			this._applyPMREM(a),
			this._cleanup(a),
			a
		);
	}
	fromEquirectangular(e, t = null) {
		return this._fromTexture(e, t);
	}
	fromCubemap(e, t = null) {
		return this._fromTexture(e, t);
	}
	compileCubemapShader() {
		this._cubemapMaterial === null &&
            ((this._cubemapMaterial = Zd()),
            this._compileMaterial(this._cubemapMaterial));
	}
	compileEquirectangularShader() {
		this._equirectMaterial === null &&
            ((this._equirectMaterial = Yd()),
            this._compileMaterial(this._equirectMaterial));
	}
	dispose() {
		this._dispose(),
		this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
		this._equirectMaterial !== null && this._equirectMaterial.dispose();
	}
	_setSize(e) {
		(this._lodMax = Math.floor(Math.log2(e))),
		(this._cubeSize = Math.pow(2, this._lodMax));
	}
	_dispose() {
		this._blurMaterial !== null && this._blurMaterial.dispose(),
		this._pingPongRenderTarget !== null &&
                this._pingPongRenderTarget.dispose();
		for (let e = 0; e < this._lodPlanes.length; e++)
			this._lodPlanes[e].dispose();
	}
	_cleanup(e) {
		this._renderer.setRenderTarget(ec),
		(e.scissorTest = !1),
		no(e, 0, 0, e.width, e.height);
	}
	_fromTexture(e, t) {
		e.mapping === aa || e.mapping === sa
			? this._setSize(
				e.image.length === 0
					? 16
					: e.image[0].width || e.image[0].image.width
			)
			: this._setSize(e.image.width / 4),
		(ec = this._renderer.getRenderTarget());
		const i = t || this._allocateTargets();
		return (
			this._textureToCubeUV(e, i),
			this._applyPMREM(i),
			this._cleanup(i),
			i
		);
	}
	_allocateTargets() {
		const e = 3 * Math.max(this._cubeSize, 112),
			t = 4 * this._cubeSize - 32,
			i = {
				magFilter: Nt,
				minFilter: Nt,
				generateMipmaps: !1,
				type: ta,
				format: Qt,
				encoding: Qr,
				depthBuffer: !1
			},
			n = qd(e, t, i);
		if (
			this._pingPongRenderTarget === null ||
            this._pingPongRenderTarget.width !== e
		) {
			this._pingPongRenderTarget !== null && this._dispose(),
			(this._pingPongRenderTarget = qd(e, t, i));
			const { _lodMax: a } = this;
			({
				sizeLods: this._sizeLods,
				lodPlanes: this._lodPlanes,
				sigmas: this._sigmas
			} = m_(a)),
			(this._blurMaterial = f_(a, e, t));
		}
		return n;
	}
	_compileMaterial(e) {
		const t = new rt(this._lodPlanes[0], e);
		this._renderer.compile(t, Ql);
	}
	_sceneToCubeUV(e, t, i, n) {
		const a = new zt(90, 1, t, i),
			s = [1, -1, 1, 1, 1, 1],
			o = [1, 1, 1, -1, -1, -1],
			l = this._renderer,
			c = l.autoClear,
			u = l.toneMapping;
		l.getClearColor(jd), (l.toneMapping = $r), (l.autoClear = !1);
		const h = new Cr({
				name: 'PMREM.Background',
				side: rr,
				depthWrite: !1,
				depthTest: !1
			}),
			d = new rt(new _a(), h);
		let p = !1;
		const g = e.background;
		g
			? g.isColor && (h.color.copy(g), (e.background = null), (p = !0))
			: (h.color.copy(jd), (p = !0));
		for (let m = 0; m < 6; m++) {
			const f = m % 3;
			f === 0
				? (a.up.set(0, s[m], 0), a.lookAt(o[m], 0, 0))
				: f === 1
					? (a.up.set(0, 0, s[m]), a.lookAt(0, o[m], 0))
					: (a.up.set(0, s[m], 0), a.lookAt(0, 0, o[m]));
			const v = this._cubeSize;
			no(n, f * v, m > 2 ? v : 0, v, v),
			l.setRenderTarget(n),
			p && l.render(d, a),
			l.render(e, a);
		}
		d.geometry.dispose(),
		d.material.dispose(),
		(l.toneMapping = u),
		(l.autoClear = c),
		(e.background = g);
	}
	_textureToCubeUV(e, t) {
		const i = this._renderer,
			n = e.mapping === aa || e.mapping === sa;
		n
			? (this._cubemapMaterial === null && (this._cubemapMaterial = Zd()),
			(this._cubemapMaterial.uniforms.flipEnvMap.value =
                  e.isRenderTargetTexture === !1 ? -1 : 1))
			: this._equirectMaterial === null &&
              (this._equirectMaterial = Yd());
		const a = n ? this._cubemapMaterial : this._equirectMaterial,
			s = new rt(this._lodPlanes[0], a),
			o = a.uniforms;
		o.envMap.value = e;
		const l = this._cubeSize;
		no(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(s, Ql);
	}
	_applyPMREM(e) {
		const t = this._renderer,
			i = t.autoClear;
		t.autoClear = !1;
		for (let n = 1; n < this._lodPlanes.length; n++) {
			const a = Math.sqrt(
					this._sigmas[n] * this._sigmas[n] -
                        this._sigmas[n - 1] * this._sigmas[n - 1]
				),
				s = Xd[(n - 1) % Xd.length];
			this._blur(e, n - 1, n, a, s);
		}
		t.autoClear = i;
	}
	_blur(e, t, i, n, a) {
		const s = this._pingPongRenderTarget;
		this._halfBlur(e, s, t, i, n, 'latitudinal', a),
		this._halfBlur(s, e, i, i, n, 'longitudinal', a);
	}
	_halfBlur(e, t, i, n, a, s, o) {
		const l = this._renderer,
			c = this._blurMaterial;
		s !== 'latitudinal' &&
            s !== 'longitudinal' &&
            console.error(
            	'blur direction must be either latitudinal or longitudinal!'
            );
		const u = 3,
			h = new rt(this._lodPlanes[n], c),
			d = c.uniforms,
			p = this._sizeLods[i] - 1,
			g = isFinite(a) ? Math.PI / (2 * p) : (2 * Math.PI) / (2 * $i - 1),
			m = a / g,
			f = isFinite(a) ? 1 + Math.floor(u * m) : $i;
		f > $i &&
            console.warn(
            	`sigmaRadians, ${a}, is too large and will clip, as it requested ${f} samples when the maximum is set to ${$i}`
            );
		const v = [];
		let x = 0;
		for (let D = 0; D < $i; ++D) {
			const G = D / m,
				re = Math.exp((-G * G) / 2);
			v.push(re), D === 0 ? (x += re) : D < f && (x += 2 * re);
		}
		for (let D = 0; D < v.length; D++) v[D] = v[D] / x;
		(d.envMap.value = e.texture),
		(d.samples.value = f),
		(d.weights.value = v),
		(d.latitudinal.value = s === 'latitudinal'),
		o && (d.poleAxis.value = o);
		const { _lodMax: A } = this;
		(d.dTheta.value = g), (d.mipInt.value = A - i);
		const S = this._sizeLods[n],
			M = 3 * S * (n > A - Yn ? n - A + Yn : 0),
			I = 4 * (this._cubeSize - S);
		no(t, M, I, 3 * S, 2 * S), l.setRenderTarget(t), l.render(h, Ql);
	}
}
function m_(r) {
	const e = [],
		t = [],
		i = [];
	let n = r;
	const a = r - Yn + 1 + Wd.length;
	for (let s = 0; s < a; s++) {
		const o = Math.pow(2, n);
		t.push(o);
		let l = 1 / o;
		s > r - Yn ? (l = Wd[s - r + Yn - 1]) : s === 0 && (l = 0), i.push(l);
		const c = 1 / (o - 1),
			u = -c / 2,
			h = 1 + c / 2,
			d = [u, u, h, u, h, h, u, u, h, h, u, h],
			p = 6,
			g = 6,
			m = 3,
			f = 2,
			v = 1,
			x = new Float32Array(m * g * p),
			A = new Float32Array(f * g * p),
			S = new Float32Array(v * g * p);
		for (let I = 0; I < p; I++) {
			const D = ((I % 3) * 2) / 3 - 1,
				G = I > 2 ? 0 : -1,
				re = [
					D,
					G,
					0,
					D + 2 / 3,
					G,
					0,
					D + 2 / 3,
					G + 1,
					0,
					D,
					G,
					0,
					D + 2 / 3,
					G + 1,
					0,
					D,
					G + 1,
					0
				];
			x.set(re, m * g * I), A.set(d, f * g * I);
			const B = [I, I, I, I, I, I];
			S.set(B, v * g * I);
		}
		const M = new ot();
		M.setAttribute('position', new mt(x, m)),
		M.setAttribute('uv', new mt(A, f)),
		M.setAttribute('faceIndex', new mt(S, v)),
		e.push(M),
		n > Yn && n--;
	}
	return { lodPlanes: e, sizeLods: t, sigmas: i };
}
function qd(r, e, t) {
	const i = new Xt(r, e, t);
	return (
		(i.texture.mapping = rl),
		(i.texture.name = 'PMREM.cubeUv'),
		(i.scissorTest = !0),
		i
	);
}
function no(r, e, t, i, n) {
	r.viewport.set(e, t, i, n), r.scissor.set(e, t, i, n);
}
function f_(r, e, t) {
	const i = new Float32Array($i),
		n = new C(0, 1, 0);
	return new br({
		name: 'SphericalGaussianBlur',
		defines: {
			n: $i,
			CUBEUV_TEXEL_WIDTH: 1 / e,
			CUBEUV_TEXEL_HEIGHT: 1 / t,
			CUBEUV_MAX_MIP: `${r}.0`
		},
		uniforms: {
			envMap: { value: null },
			samples: { value: 1 },
			weights: { value: i },
			latitudinal: { value: !1 },
			dTheta: { value: 0 },
			mipInt: { value: 0 },
			poleAxis: { value: n }
		},
		vertexShader: Nu(),
		fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
		blending: Ei,
		depthTest: !1,
		depthWrite: !1
	});
}
function Yd() {
	return new br({
		name: 'EquirectangularToCubeUV',
		uniforms: { envMap: { value: null } },
		vertexShader: Nu(),
		fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
		blending: Ei,
		depthTest: !1,
		depthWrite: !1
	});
}
function Zd() {
	return new br({
		name: 'CubemapToCubeUV',
		uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
		vertexShader: Nu(),
		fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
		blending: Ei,
		depthTest: !1,
		depthWrite: !1
	});
}
function Nu() {
	return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function g_(r) {
	let e = new WeakMap(),
		t = null;
	function i(o) {
		if (o && o.isTexture) {
			const l = o.mapping,
				c = l === Bc || l === Fc,
				u = l === aa || l === sa;
			if (c || u)
				if (o.isRenderTargetTexture && o.needsPMREMUpdate === !0) {
					o.needsPMREMUpdate = !1;
					let h = e.get(o);
					return (
						t === null && (t = new jc(r)),
						(h = c
							? t.fromEquirectangular(o, h)
							: t.fromCubemap(o, h)),
						e.set(o, h),
						h.texture
					);
				} else {
					if (e.has(o)) return e.get(o).texture;
					{
						const h = o.image;
						if ((c && h && h.height > 0) || (u && h && n(h))) {
							t === null && (t = new jc(r));
							const d = c
								? t.fromEquirectangular(o)
								: t.fromCubemap(o);
							return (
								e.set(o, d),
								o.addEventListener('dispose', a),
								d.texture
							);
						} else return null;
					}
				}
		}
		return o;
	}
	function n(o) {
		let l = 0;
		const c = 6;
		for (let u = 0; u < c; u++) o[u] !== void 0 && l++;
		return l === c;
	}
	function a(o) {
		const l = o.target;
		l.removeEventListener('dispose', a);
		const c = e.get(l);
		c !== void 0 && (e.delete(l), c.dispose());
	}
	function s() {
		(e = new WeakMap()), t !== null && (t.dispose(), (t = null));
	}
	return { get: i, dispose: s };
}
function v_(r) {
	const e = {};
	function t(i) {
		if (e[i] !== void 0) return e[i];
		let n;
		switch (i) {
		case 'WEBGL_depth_texture':
			n =
                    r.getExtension('WEBGL_depth_texture') ||
                    r.getExtension('MOZ_WEBGL_depth_texture') ||
                    r.getExtension('WEBKIT_WEBGL_depth_texture');
			break;
		case 'EXT_texture_filter_anisotropic':
			n =
                    r.getExtension('EXT_texture_filter_anisotropic') ||
                    r.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
                    r.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
			break;
		case 'WEBGL_compressed_texture_s3tc':
			n =
                    r.getExtension('WEBGL_compressed_texture_s3tc') ||
                    r.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
                    r.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
			break;
		case 'WEBGL_compressed_texture_pvrtc':
			n =
                    r.getExtension('WEBGL_compressed_texture_pvrtc') ||
                    r.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
			break;
		default:
			n = r.getExtension(i);
		}
		return (e[i] = n), n;
	}
	return {
		has: function (i) {
			return t(i) !== null;
		},
		init: function (i) {
			i.isWebGL2
				? t('EXT_color_buffer_float')
				: (t('WEBGL_depth_texture'),
				t('OES_texture_float'),
				t('OES_texture_half_float'),
				t('OES_texture_half_float_linear'),
				t('OES_standard_derivatives'),
				t('OES_element_index_uint'),
				t('OES_vertex_array_object'),
				t('ANGLE_instanced_arrays')),
			t('OES_texture_float_linear'),
			t('EXT_color_buffer_half_float'),
			t('WEBGL_multisampled_render_to_texture');
		},
		get: function (i) {
			const n = t(i);
			return (
				n === null &&
                    console.warn(
                    	'THREE.WebGLRenderer: ' +
                            i +
                            ' extension not supported.'
                    ),
				n
			);
		}
	};
}
function y_(r, e, t, i) {
	const n = {},
		a = new WeakMap();
	function s(h) {
		const d = h.target;
		d.index !== null && e.remove(d.index);
		for (const g in d.attributes) e.remove(d.attributes[g]);
		d.removeEventListener('dispose', s), delete n[d.id];
		const p = a.get(d);
		p && (e.remove(p), a.delete(d)),
		i.releaseStatesOfGeometry(d),
		d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount,
		t.memory.geometries--;
	}
	function o(h, d) {
		return (
			n[d.id] === !0 ||
                (d.addEventListener('dispose', s),
                (n[d.id] = !0),
                t.memory.geometries++),
			d
		);
	}
	function l(h) {
		const d = h.attributes;
		for (const g in d) e.update(d[g], 34962);
		const p = h.morphAttributes;
		for (const g in p) {
			const m = p[g];
			for (let f = 0, v = m.length; f < v; f++) e.update(m[f], 34962);
		}
	}
	function c(h) {
		const d = [],
			p = h.index,
			g = h.attributes.position;
		let m = 0;
		if (p !== null) {
			const x = p.array;
			m = p.version;
			for (let A = 0, S = x.length; A < S; A += 3) {
				const M = x[A + 0],
					I = x[A + 1],
					D = x[A + 2];
				d.push(M, I, I, D, D, M);
			}
		} else {
			const x = g.array;
			m = g.version;
			for (let A = 0, S = x.length / 3 - 1; A < S; A += 3) {
				const M = A + 0,
					I = A + 1,
					D = A + 2;
				d.push(M, I, I, D, D, M);
			}
		}
		const f = new (Pf(d) ? zf : Nf)(d, 1);
		f.version = m;
		const v = a.get(h);
		v && e.remove(v), a.set(h, f);
	}
	function u(h) {
		const d = a.get(h);
		if (d) {
			const p = h.index;
			p !== null && d.version < p.version && c(h);
		} else c(h);
		return a.get(h);
	}
	return { get: o, update: l, getWireframeAttribute: u };
}
function x_(r, e, t, i) {
	const n = i.isWebGL2;
	let a;
	function s(d) {
		a = d;
	}
	let o, l;
	function c(d) {
		(o = d.type), (l = d.bytesPerElement);
	}
	function u(d, p) {
		r.drawElements(a, p, o, d * l), t.update(p, a, 1);
	}
	function h(d, p, g) {
		if (g === 0) return;
		let m, f;
		if (n) (m = r), (f = 'drawElementsInstanced');
		else if (
			((m = e.get('ANGLE_instanced_arrays')),
			(f = 'drawElementsInstancedANGLE'),
			m === null)
		) {
			console.error(
				'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.'
			);
			return;
		}
		m[f](a, p, o, d * l, g), t.update(p, a, g);
	}
	(this.setMode = s),
	(this.setIndex = c),
	(this.render = u),
	(this.renderInstances = h);
}
function b_(r) {
	const e = { geometries: 0, textures: 0 },
		t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
	function i(a, s, o) {
		switch ((t.calls++, s)) {
		case 4:
			t.triangles += o * (a / 3);
			break;
		case 1:
			t.lines += o * (a / 2);
			break;
		case 3:
			t.lines += o * (a - 1);
			break;
		case 2:
			t.lines += o * a;
			break;
		case 0:
			t.points += o * a;
			break;
		default:
			console.error('THREE.WebGLInfo: Unknown draw mode:', s);
			break;
		}
	}
	function n() {
		t.frame++,
		(t.calls = 0),
		(t.triangles = 0),
		(t.points = 0),
		(t.lines = 0);
	}
	return {
		memory: e,
		render: t,
		programs: null,
		autoReset: !0,
		reset: n,
		update: i
	};
}
function w_(r, e) {
	return r[0] - e[0];
}
function __(r, e) {
	return Math.abs(e[1]) - Math.abs(r[1]);
}
function tc(r, e) {
	let t = 1;
	const i = e.isInterleavedBufferAttribute ? e.data.array : e.array;
	i instanceof Int8Array
		? (t = 127)
		: i instanceof Int16Array
			? (t = 32767)
			: i instanceof Int32Array
				? (t = 2147483647)
				: console.error(
					'THREE.WebGLMorphtargets: Unsupported morph attribute data type: ',
					i
				),
	r.divideScalar(t);
}
function M_(r, e, t) {
	const i = {},
		n = new Float32Array(8),
		a = new WeakMap(),
		s = new it(),
		o = [];
	for (let c = 0; c < 8; c++) o[c] = [c, 0];
	function l(c, u, h, d) {
		const p = c.morphTargetInfluences;
		if (e.isWebGL2 === !0) {
			const g =
                    u.morphAttributes.position ||
                    u.morphAttributes.normal ||
                    u.morphAttributes.color,
				m = g !== void 0 ? g.length : 0;
			let f = a.get(u);
			if (f === void 0 || f.count !== m) {
				let A = function () {
					z.dispose(),
					a.delete(u),
					u.removeEventListener('dispose', A);
				};
				f !== void 0 && f.texture.dispose();
				const S = u.morphAttributes.position !== void 0,
					M = u.morphAttributes.normal !== void 0,
					I = u.morphAttributes.color !== void 0,
					D = u.morphAttributes.position || [],
					G = u.morphAttributes.normal || [],
					re = u.morphAttributes.color || [];
				let B = 0;
				S === !0 && (B = 1), M === !0 && (B = 2), I === !0 && (B = 3);
				let b = u.attributes.position.count * B,
					E = 1;
				b > e.maxTextureSize &&
                    ((E = Math.ceil(b / e.maxTextureSize)),
                    (b = e.maxTextureSize));
				const j = new Float32Array(b * E * 4 * m),
					z = new il(j, b, E, m);
				(z.type = wi), (z.needsUpdate = !0);
				const V = B * 4;
				for (let H = 0; H < m; H++) {
					const k = D[H],
						P = G[H],
						Z = re[H],
						J = b * E * 4 * H;
					for (let fe = 0; fe < k.count; fe++) {
						const ce = fe * V;
						S === !0 &&
                            (s.fromBufferAttribute(k, fe),
                            k.normalized === !0 && tc(s, k),
                            (j[J + ce + 0] = s.x),
                            (j[J + ce + 1] = s.y),
                            (j[J + ce + 2] = s.z),
                            (j[J + ce + 3] = 0)),
						M === !0 &&
                                (s.fromBufferAttribute(P, fe),
                                P.normalized === !0 && tc(s, P),
                                (j[J + ce + 4] = s.x),
                                (j[J + ce + 5] = s.y),
                                (j[J + ce + 6] = s.z),
                                (j[J + ce + 7] = 0)),
						I === !0 &&
                                (s.fromBufferAttribute(Z, fe),
                                Z.normalized === !0 && tc(s, Z),
                                (j[J + ce + 8] = s.x),
                                (j[J + ce + 9] = s.y),
                                (j[J + ce + 10] = s.z),
                                (j[J + ce + 11] = Z.itemSize === 4 ? s.w : 1));
					}
				}
				(f = { count: m, texture: z, size: new me(b, E) }),
				a.set(u, f),
				u.addEventListener('dispose', A);
			}
			let v = 0;
			for (let A = 0; A < p.length; A++) v += p[A];
			const x = u.morphTargetsRelative ? 1 : 1 - v;
			d.getUniforms().setValue(r, 'morphTargetBaseInfluence', x),
			d.getUniforms().setValue(r, 'morphTargetInfluences', p),
			d
				.getUniforms()
				.setValue(r, 'morphTargetsTexture', f.texture, t),
			d.getUniforms().setValue(r, 'morphTargetsTextureSize', f.size);
		} else {
			const g = p === void 0 ? 0 : p.length;
			let m = i[u.id];
			if (m === void 0 || m.length !== g) {
				m = [];
				for (let S = 0; S < g; S++) m[S] = [S, 0];
				i[u.id] = m;
			}
			for (let S = 0; S < g; S++) {
				const M = m[S];
				(M[0] = S), (M[1] = p[S]);
			}
			m.sort(__);
			for (let S = 0; S < 8; S++)
				S < g && m[S][1]
					? ((o[S][0] = m[S][0]), (o[S][1] = m[S][1]))
					: ((o[S][0] = Number.MAX_SAFE_INTEGER), (o[S][1] = 0));
			o.sort(w_);
			const f = u.morphAttributes.position,
				v = u.morphAttributes.normal;
			let x = 0;
			for (let S = 0; S < 8; S++) {
				const M = o[S],
					I = M[0],
					D = M[1];
				I !== Number.MAX_SAFE_INTEGER && D
					? (f &&
                          u.getAttribute('morphTarget' + S) !== f[I] &&
                          u.setAttribute('morphTarget' + S, f[I]),
					v &&
                          u.getAttribute('morphNormal' + S) !== v[I] &&
                          u.setAttribute('morphNormal' + S, v[I]),
					(n[S] = D),
					(x += D))
					: (f &&
                          u.hasAttribute('morphTarget' + S) === !0 &&
                          u.deleteAttribute('morphTarget' + S),
					v &&
                          u.hasAttribute('morphNormal' + S) === !0 &&
                          u.deleteAttribute('morphNormal' + S),
					(n[S] = 0));
			}
			const A = u.morphTargetsRelative ? 1 : 1 - x;
			d.getUniforms().setValue(r, 'morphTargetBaseInfluence', A),
			d.getUniforms().setValue(r, 'morphTargetInfluences', n);
		}
	}
	return { update: l };
}
function S_(r, e, t, i) {
	let n = new WeakMap();
	function a(l) {
		const c = i.render.frame,
			u = l.geometry,
			h = e.get(l, u);
		return (
			n.get(h) !== c && (e.update(h), n.set(h, c)),
			l.isInstancedMesh &&
                (l.hasEventListener('dispose', o) === !1 &&
                    l.addEventListener('dispose', o),
                t.update(l.instanceMatrix, 34962),
                l.instanceColor !== null && t.update(l.instanceColor, 34962)),
			h
		);
	}
	function s() {
		n = new WeakMap();
	}
	function o(l) {
		const c = l.target;
		c.removeEventListener('dispose', o),
		t.remove(c.instanceMatrix),
		c.instanceColor !== null && t.remove(c.instanceColor);
	}
	return { update: a, dispose: s };
}
const Ff = new wt(),
	Hf = new il(),
	Gf = new Pu(),
	Vf = new nl(),
	$d = [],
	Kd = [],
	Jd = new Float32Array(16),
	Qd = new Float32Array(9),
	ep = new Float32Array(4);
function Ma(r, e, t) {
	const i = r[0];
	if (i <= 0 || i > 0) return r;
	const n = e * t;
	let a = $d[n];
	if ((a === void 0 && ((a = new Float32Array(n)), ($d[n] = a)), e !== 0)) {
		i.toArray(a, 0);
		for (let s = 1, o = 0; s !== e; ++s) (o += t), r[s].toArray(a, o);
	}
	return a;
}
function Ht(r, e) {
	if (r.length !== e.length) return !1;
	for (let t = 0, i = r.length; t < i; t++) if (r[t] !== e[t]) return !1;
	return !0;
}
function Ut(r, e) {
	for (let t = 0, i = e.length; t < i; t++) r[t] = e[t];
}
function ol(r, e) {
	let t = Kd[e];
	t === void 0 && ((t = new Int32Array(e)), (Kd[e] = t));
	for (let i = 0; i !== e; ++i) t[i] = r.allocateTextureUnit();
	return t;
}
function T_(r, e) {
	const t = this.cache;
	t[0] !== e && (r.uniform1f(this.addr, e), (t[0] = e));
}
function E_(r, e) {
	const t = this.cache;
	if (e.x !== void 0)
		(t[0] !== e.x || t[1] !== e.y) &&
            (r.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
	else {
		if (Ht(t, e)) return;
		r.uniform2fv(this.addr, e), Ut(t, e);
	}
}
function A_(r, e) {
	const t = this.cache;
	if (e.x !== void 0)
		(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
            (r.uniform3f(this.addr, e.x, e.y, e.z),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z));
	else if (e.r !== void 0)
		(t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
            (r.uniform3f(this.addr, e.r, e.g, e.b),
            (t[0] = e.r),
            (t[1] = e.g),
            (t[2] = e.b));
	else {
		if (Ht(t, e)) return;
		r.uniform3fv(this.addr, e), Ut(t, e);
	}
}
function L_(r, e) {
	const t = this.cache;
	if (e.x !== void 0)
		(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
            (r.uniform4f(this.addr, e.x, e.y, e.z, e.w),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z),
            (t[3] = e.w));
	else {
		if (Ht(t, e)) return;
		r.uniform4fv(this.addr, e), Ut(t, e);
	}
}
function R_(r, e) {
	const t = this.cache,
		i = e.elements;
	if (i === void 0) {
		if (Ht(t, e)) return;
		r.uniformMatrix2fv(this.addr, !1, e), Ut(t, e);
	} else {
		if (Ht(t, i)) return;
		ep.set(i), r.uniformMatrix2fv(this.addr, !1, ep), Ut(t, i);
	}
}
function k_(r, e) {
	const t = this.cache,
		i = e.elements;
	if (i === void 0) {
		if (Ht(t, e)) return;
		r.uniformMatrix3fv(this.addr, !1, e), Ut(t, e);
	} else {
		if (Ht(t, i)) return;
		Qd.set(i), r.uniformMatrix3fv(this.addr, !1, Qd), Ut(t, i);
	}
}
function C_(r, e) {
	const t = this.cache,
		i = e.elements;
	if (i === void 0) {
		if (Ht(t, e)) return;
		r.uniformMatrix4fv(this.addr, !1, e), Ut(t, e);
	} else {
		if (Ht(t, i)) return;
		Jd.set(i), r.uniformMatrix4fv(this.addr, !1, Jd), Ut(t, i);
	}
}
function P_(r, e) {
	const t = this.cache;
	t[0] !== e && (r.uniform1i(this.addr, e), (t[0] = e));
}
function I_(r, e) {
	const t = this.cache;
	Ht(t, e) || (r.uniform2iv(this.addr, e), Ut(t, e));
}
function D_(r, e) {
	const t = this.cache;
	Ht(t, e) || (r.uniform3iv(this.addr, e), Ut(t, e));
}
function O_(r, e) {
	const t = this.cache;
	Ht(t, e) || (r.uniform4iv(this.addr, e), Ut(t, e));
}
function N_(r, e) {
	const t = this.cache;
	t[0] !== e && (r.uniform1ui(this.addr, e), (t[0] = e));
}
function z_(r, e) {
	const t = this.cache;
	Ht(t, e) || (r.uniform2uiv(this.addr, e), Ut(t, e));
}
function U_(r, e) {
	const t = this.cache;
	Ht(t, e) || (r.uniform3uiv(this.addr, e), Ut(t, e));
}
function B_(r, e) {
	const t = this.cache;
	Ht(t, e) || (r.uniform4uiv(this.addr, e), Ut(t, e));
}
function F_(r, e, t) {
	const i = this.cache,
		n = t.allocateTextureUnit();
	i[0] !== n && (r.uniform1i(this.addr, n), (i[0] = n)),
	t.setTexture2D(e || Ff, n);
}
function H_(r, e, t) {
	const i = this.cache,
		n = t.allocateTextureUnit();
	i[0] !== n && (r.uniform1i(this.addr, n), (i[0] = n)),
	t.setTexture3D(e || Gf, n);
}
function G_(r, e, t) {
	const i = this.cache,
		n = t.allocateTextureUnit();
	i[0] !== n && (r.uniform1i(this.addr, n), (i[0] = n)),
	t.setTextureCube(e || Vf, n);
}
function V_(r, e, t) {
	const i = this.cache,
		n = t.allocateTextureUnit();
	i[0] !== n && (r.uniform1i(this.addr, n), (i[0] = n)),
	t.setTexture2DArray(e || Hf, n);
}
function W_(r) {
	switch (r) {
	case 5126:
		return T_;
	case 35664:
		return E_;
	case 35665:
		return A_;
	case 35666:
		return L_;
	case 35674:
		return R_;
	case 35675:
		return k_;
	case 35676:
		return C_;
	case 5124:
	case 35670:
		return P_;
	case 35667:
	case 35671:
		return I_;
	case 35668:
	case 35672:
		return D_;
	case 35669:
	case 35673:
		return O_;
	case 5125:
		return N_;
	case 36294:
		return z_;
	case 36295:
		return U_;
	case 36296:
		return B_;
	case 35678:
	case 36198:
	case 36298:
	case 36306:
	case 35682:
		return F_;
	case 35679:
	case 36299:
	case 36307:
		return H_;
	case 35680:
	case 36300:
	case 36308:
	case 36293:
		return G_;
	case 36289:
	case 36303:
	case 36311:
	case 36292:
		return V_;
	}
}
function j_(r, e) {
	r.uniform1fv(this.addr, e);
}
function X_(r, e) {
	const t = Ma(e, this.size, 2);
	r.uniform2fv(this.addr, t);
}
function q_(r, e) {
	const t = Ma(e, this.size, 3);
	r.uniform3fv(this.addr, t);
}
function Y_(r, e) {
	const t = Ma(e, this.size, 4);
	r.uniform4fv(this.addr, t);
}
function Z_(r, e) {
	const t = Ma(e, this.size, 4);
	r.uniformMatrix2fv(this.addr, !1, t);
}
function $_(r, e) {
	const t = Ma(e, this.size, 9);
	r.uniformMatrix3fv(this.addr, !1, t);
}
function K_(r, e) {
	const t = Ma(e, this.size, 16);
	r.uniformMatrix4fv(this.addr, !1, t);
}
function J_(r, e) {
	r.uniform1iv(this.addr, e);
}
function Q_(r, e) {
	r.uniform2iv(this.addr, e);
}
function eM(r, e) {
	r.uniform3iv(this.addr, e);
}
function tM(r, e) {
	r.uniform4iv(this.addr, e);
}
function rM(r, e) {
	r.uniform1uiv(this.addr, e);
}
function iM(r, e) {
	r.uniform2uiv(this.addr, e);
}
function nM(r, e) {
	r.uniform3uiv(this.addr, e);
}
function aM(r, e) {
	r.uniform4uiv(this.addr, e);
}
function sM(r, e, t) {
	const i = e.length,
		n = ol(t, i);
	r.uniform1iv(this.addr, n);
	for (let a = 0; a !== i; ++a) t.setTexture2D(e[a] || Ff, n[a]);
}
function oM(r, e, t) {
	const i = e.length,
		n = ol(t, i);
	r.uniform1iv(this.addr, n);
	for (let a = 0; a !== i; ++a) t.setTexture3D(e[a] || Gf, n[a]);
}
function lM(r, e, t) {
	const i = e.length,
		n = ol(t, i);
	r.uniform1iv(this.addr, n);
	for (let a = 0; a !== i; ++a) t.setTextureCube(e[a] || Vf, n[a]);
}
function cM(r, e, t) {
	const i = e.length,
		n = ol(t, i);
	r.uniform1iv(this.addr, n);
	for (let a = 0; a !== i; ++a) t.setTexture2DArray(e[a] || Hf, n[a]);
}
function uM(r) {
	switch (r) {
	case 5126:
		return j_;
	case 35664:
		return X_;
	case 35665:
		return q_;
	case 35666:
		return Y_;
	case 35674:
		return Z_;
	case 35675:
		return $_;
	case 35676:
		return K_;
	case 5124:
	case 35670:
		return J_;
	case 35667:
	case 35671:
		return Q_;
	case 35668:
	case 35672:
		return eM;
	case 35669:
	case 35673:
		return tM;
	case 5125:
		return rM;
	case 36294:
		return iM;
	case 36295:
		return nM;
	case 36296:
		return aM;
	case 35678:
	case 36198:
	case 36298:
	case 36306:
	case 35682:
		return sM;
	case 35679:
	case 36299:
	case 36307:
		return oM;
	case 35680:
	case 36300:
	case 36308:
	case 36293:
		return lM;
	case 36289:
	case 36303:
	case 36311:
	case 36292:
		return cM;
	}
}
function hM(r, e, t) {
	(this.id = r),
	(this.addr = t),
	(this.cache = []),
	(this.setValue = W_(e.type));
}
function Wf(r, e, t) {
	(this.id = r),
	(this.addr = t),
	(this.cache = []),
	(this.size = e.size),
	(this.setValue = uM(e.type));
}
Wf.prototype.updateCache = function (r) {
	const e = this.cache;
	r instanceof Float32Array &&
        e.length !== r.length &&
        (this.cache = new Float32Array(r.length)),
	Ut(e, r);
};
function jf(r) {
	(this.id = r), (this.seq = []), (this.map = {});
}
jf.prototype.setValue = function (r, e, t) {
	const i = this.seq;
	for (let n = 0, a = i.length; n !== a; ++n) {
		const s = i[n];
		s.setValue(r, e[s.id], t);
	}
};
const rc = /(\w+)(\])?(\[|\.)?/g;
function tp(r, e) {
	r.seq.push(e), (r.map[e.id] = e);
}
function dM(r, e, t) {
	const i = r.name,
		n = i.length;
	for (rc.lastIndex = 0; ; ) {
		const a = rc.exec(i),
			s = rc.lastIndex;
		let o = a[1];
		const l = a[2] === ']',
			c = a[3];
		if ((l && (o = o | 0), c === void 0 || (c === '[' && s + 2 === n))) {
			tp(t, c === void 0 ? new hM(o, r, e) : new Wf(o, r, e));
			break;
		} else {
			let u = t.map[o];
			u === void 0 && ((u = new jf(o)), tp(t, u)), (t = u);
		}
	}
}
function Ai(r, e) {
	(this.seq = []), (this.map = {});
	const t = r.getProgramParameter(e, 35718);
	for (let i = 0; i < t; ++i) {
		const n = r.getActiveUniform(e, i),
			a = r.getUniformLocation(e, n.name);
		dM(n, a, this);
	}
}
Ai.prototype.setValue = function (r, e, t, i) {
	const n = this.map[e];
	n !== void 0 && n.setValue(r, t, i);
};
Ai.prototype.setOptional = function (r, e, t) {
	const i = e[t];
	i !== void 0 && this.setValue(r, t, i);
};
Ai.upload = function (r, e, t, i) {
	for (let n = 0, a = e.length; n !== a; ++n) {
		const s = e[n],
			o = t[s.id];
		o.needsUpdate !== !1 && s.setValue(r, o.value, i);
	}
};
Ai.seqWithValue = function (r, e) {
	const t = [];
	for (let i = 0, n = r.length; i !== n; ++i) {
		const a = r[i];
		a.id in e && t.push(a);
	}
	return t;
};
function rp(r, e, t) {
	const i = r.createShader(e);
	return r.shaderSource(i, t), r.compileShader(i), i;
}
let pM = 0;
function mM(r, e) {
	const t = r.split(`
`),
		i = [],
		n = Math.max(e - 6, 0),
		a = Math.min(e + 6, t.length);
	for (let s = n; s < a; s++) i.push(s + 1 + ': ' + t[s]);
	return i.join(`
`);
}
function fM(r) {
	switch (r) {
	case Qr:
		return ['Linear', '( value )'];
	case Ze:
		return ['sRGB', '( value )'];
	default:
		return (
			console.warn('THREE.WebGLProgram: Unsupported encoding:', r),
			['Linear', '( value )']
		);
	}
}
function ip(r, e, t) {
	const i = r.getShaderParameter(e, 35713),
		n = r.getShaderInfoLog(e).trim();
	if (i && n === '') return '';
	const a = parseInt(/ERROR: 0:(\d+)/.exec(n)[1]);
	return (
		t.toUpperCase() +
        `

` +
        n +
        `

` +
        mM(r.getShaderSource(e), a)
	);
}
function gM(r, e) {
	const t = fM(e);
	return (
		'vec4 ' + r + '( vec4 value ) { return LinearTo' + t[0] + t[1] + '; }'
	);
}
function vM(r, e) {
	let t;
	switch (e) {
	case Mx:
		t = 'Linear';
		break;
	case Sx:
		t = 'Reinhard';
		break;
	case Tx:
		t = 'OptimizedCineon';
		break;
	case Ex:
		t = 'ACESFilmic';
		break;
	case Ax:
		t = 'Custom';
		break;
	default:
		console.warn('THREE.WebGLProgram: Unsupported toneMapping:', e),
		(t = 'Linear');
	}
	return (
		'vec3 ' + r + '( vec3 color ) { return ' + t + 'ToneMapping( color ); }'
	);
}
function yM(r) {
	return [
		r.extensionDerivatives ||
        !!r.envMapCubeUVHeight ||
        r.bumpMap ||
        r.tangentSpaceNormalMap ||
        r.clearcoatNormalMap ||
        r.flatShading ||
        r.shaderID === 'physical'
			? '#extension GL_OES_standard_derivatives : enable'
			: '',
		(r.extensionFragDepth || r.logarithmicDepthBuffer) &&
        r.rendererExtensionFragDepth
			? '#extension GL_EXT_frag_depth : enable'
			: '',
		r.extensionDrawBuffers && r.rendererExtensionDrawBuffers
			? '#extension GL_EXT_draw_buffers : require'
			: '',
		(r.extensionShaderTextureLOD || r.envMap || r.transmission) &&
        r.rendererExtensionShaderTextureLod
			? '#extension GL_EXT_shader_texture_lod : enable'
			: ''
	].filter(Ya).join(`
`);
}
function xM(r) {
	const e = [];
	for (const t in r) {
		const i = r[t];
		i !== !1 && e.push('#define ' + t + ' ' + i);
	}
	return e.join(`
`);
}
function bM(r, e) {
	const t = {},
		i = r.getProgramParameter(e, 35721);
	for (let n = 0; n < i; n++) {
		const a = r.getActiveAttrib(e, n),
			s = a.name;
		let o = 1;
		a.type === 35674 && (o = 2),
		a.type === 35675 && (o = 3),
		a.type === 35676 && (o = 4),
		(t[s] = {
			type: a.type,
			location: r.getAttribLocation(e, s),
			locationSize: o
		});
	}
	return t;
}
function Ya(r) {
	return r !== '';
}
function np(r, e) {
	return r
		.replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
		.replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
		.replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
		.replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
		.replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
		.replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
		.replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
		.replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function ap(r, e) {
	return r
		.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
		.replace(
			/UNION_CLIPPING_PLANES/g,
			e.numClippingPlanes - e.numClipIntersection
		);
}
const wM = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Xc(r) {
	return r.replace(wM, _M);
}
function _M(r, e) {
	const t = Ve[e];
	if (t === void 0) throw new Error('Can not resolve #include <' + e + '>');
	return Xc(t);
}
const MM =
        /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
	SM =
        /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function sp(r) {
	return r.replace(SM, Xf).replace(MM, TM);
}
function TM(r, e, t, i) {
	return (
		console.warn(
			'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.'
		),
		Xf(r, e, t, i)
	);
}
function Xf(r, e, t, i) {
	let n = '';
	for (let a = parseInt(e); a < parseInt(t); a++)
		n += i
			.replace(/\[\s*i\s*\]/g, '[ ' + a + ' ]')
			.replace(/UNROLLED_LOOP_INDEX/g, a);
	return n;
}
function op(r) {
	let e =
        'precision ' +
        r.precision +
        ` float;
precision ` +
        r.precision +
        ' int;';
	return (
		r.precision === 'highp'
			? (e += `
#define HIGH_PRECISION`)
			: r.precision === 'mediump'
				? (e += `
#define MEDIUM_PRECISION`)
				: r.precision === 'lowp' &&
              (e += `
#define LOW_PRECISION`),
		e
	);
}
function EM(r) {
	let e = 'SHADOWMAP_TYPE_BASIC';
	return (
		r.shadowMapType === _f
			? (e = 'SHADOWMAP_TYPE_PCF')
			: r.shadowMapType === Mf
				? (e = 'SHADOWMAP_TYPE_PCF_SOFT')
				: r.shadowMapType === qa && (e = 'SHADOWMAP_TYPE_VSM'),
		e
	);
}
function AM(r) {
	let e = 'ENVMAP_TYPE_CUBE';
	if (r.envMap)
		switch (r.envMapMode) {
		case aa:
		case sa:
			e = 'ENVMAP_TYPE_CUBE';
			break;
		case rl:
			e = 'ENVMAP_TYPE_CUBE_UV';
			break;
		}
	return e;
}
function LM(r) {
	let e = 'ENVMAP_MODE_REFLECTION';
	if (r.envMap)
		switch (r.envMapMode) {
		case sa:
			e = 'ENVMAP_MODE_REFRACTION';
			break;
		}
	return e;
}
function RM(r) {
	let e = 'ENVMAP_BLENDING_NONE';
	if (r.envMap)
		switch (r.combine) {
		case tl:
			e = 'ENVMAP_BLENDING_MULTIPLY';
			break;
		case wx:
			e = 'ENVMAP_BLENDING_MIX';
			break;
		case _x:
			e = 'ENVMAP_BLENDING_ADD';
			break;
		}
	return e;
}
function kM(r) {
	const e = r.envMapCubeUVHeight;
	if (e === null) return null;
	const t = Math.log2(e / 32 + 1) + 3,
		i = 1 / e;
	return {
		texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
		texelHeight: i,
		maxMip: t
	};
}
function CM(r, e, t, i) {
	const n = r.getContext(),
		a = t.defines;
	let s = t.vertexShader,
		o = t.fragmentShader;
	const l = EM(t),
		c = AM(t),
		u = LM(t),
		h = RM(t),
		d = kM(t),
		p = t.isWebGL2 ? '' : yM(t),
		g = xM(a),
		m = n.createProgram();
	let f,
		v,
		x = t.glslVersion
			? '#version ' +
              t.glslVersion +
              `
`
			: '';
	t.isRawShaderMaterial
		? ((f = [g].filter(Ya).join(`
`)),
		f.length > 0 &&
              (f += `
`),
		(v = [p, g].filter(Ya).join(`
`)),
		v.length > 0 &&
              (v += `
`))
		: ((f = [
			op(t),
			'#define SHADER_NAME ' + t.shaderName,
			g,
			t.instancing ? '#define USE_INSTANCING' : '',
			t.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
			t.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
			'#define MAX_BONES ' + t.maxBones,
			t.useFog && t.fog ? '#define USE_FOG' : '',
			t.useFog && t.fogExp2 ? '#define FOG_EXP2' : '',
			t.map ? '#define USE_MAP' : '',
			t.envMap ? '#define USE_ENVMAP' : '',
			t.envMap ? '#define ' + u : '',
			t.lightMap ? '#define USE_LIGHTMAP' : '',
			t.aoMap ? '#define USE_AOMAP' : '',
			t.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			t.bumpMap ? '#define USE_BUMPMAP' : '',
			t.normalMap ? '#define USE_NORMALMAP' : '',
			t.normalMap && t.objectSpaceNormalMap
				? '#define OBJECTSPACE_NORMALMAP'
				: '',
			t.normalMap && t.tangentSpaceNormalMap
				? '#define TANGENTSPACE_NORMALMAP'
				: '',
			t.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			t.clearcoatRoughnessMap
				? '#define USE_CLEARCOAT_ROUGHNESSMAP'
				: '',
			t.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
			t.displacementMap && t.supportsVertexTextures
				? '#define USE_DISPLACEMENTMAP'
				: '',
			t.specularMap ? '#define USE_SPECULARMAP' : '',
			t.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
			t.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',
			t.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			t.metalnessMap ? '#define USE_METALNESSMAP' : '',
			t.alphaMap ? '#define USE_ALPHAMAP' : '',
			t.transmission ? '#define USE_TRANSMISSION' : '',
			t.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
			t.thicknessMap ? '#define USE_THICKNESSMAP' : '',
			t.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
			t.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',
			t.vertexTangents ? '#define USE_TANGENT' : '',
			t.vertexColors ? '#define USE_COLOR' : '',
			t.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
			t.vertexUvs ? '#define USE_UV' : '',
			t.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
			t.flatShading ? '#define FLAT_SHADED' : '',
			t.skinning ? '#define USE_SKINNING' : '',
			t.useVertexTexture ? '#define BONE_TEXTURE' : '',
			t.morphTargets ? '#define USE_MORPHTARGETS' : '',
			t.morphNormals && t.flatShading === !1
				? '#define USE_MORPHNORMALS'
				: '',
			t.morphColors && t.isWebGL2 ? '#define USE_MORPHCOLORS' : '',
			t.morphTargetsCount > 0 && t.isWebGL2
				? '#define MORPHTARGETS_TEXTURE'
				: '',
			t.morphTargetsCount > 0 && t.isWebGL2
				? '#define MORPHTARGETS_TEXTURE_STRIDE ' +
                    t.morphTextureStride
				: '',
			t.morphTargetsCount > 0 && t.isWebGL2
				? '#define MORPHTARGETS_COUNT ' + t.morphTargetsCount
				: '',
			t.doubleSided ? '#define DOUBLE_SIDED' : '',
			t.flipSided ? '#define FLIP_SIDED' : '',
			t.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			t.shadowMapEnabled ? '#define ' + l : '',
			t.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
			t.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
				? '#define USE_LOGDEPTHBUF_EXT'
				: '',
			'uniform mat4 modelMatrix;',
			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform mat4 viewMatrix;',
			'uniform mat3 normalMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',
			'#ifdef USE_INSTANCING',
			'	attribute mat4 instanceMatrix;',
			'#endif',
			'#ifdef USE_INSTANCING_COLOR',
			'	attribute vec3 instanceColor;',
			'#endif',
			'attribute vec3 position;',
			'attribute vec3 normal;',
			'attribute vec2 uv;',
			'#ifdef USE_TANGENT',
			'	attribute vec4 tangent;',
			'#endif',
			'#if defined( USE_COLOR_ALPHA )',
			'	attribute vec4 color;',
			'#elif defined( USE_COLOR )',
			'	attribute vec3 color;',
			'#endif',
			'#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',
			'	attribute vec3 morphTarget0;',
			'	attribute vec3 morphTarget1;',
			'	attribute vec3 morphTarget2;',
			'	attribute vec3 morphTarget3;',
			'	#ifdef USE_MORPHNORMALS',
			'		attribute vec3 morphNormal0;',
			'		attribute vec3 morphNormal1;',
			'		attribute vec3 morphNormal2;',
			'		attribute vec3 morphNormal3;',
			'	#else',
			'		attribute vec3 morphTarget4;',
			'		attribute vec3 morphTarget5;',
			'		attribute vec3 morphTarget6;',
			'		attribute vec3 morphTarget7;',
			'	#endif',
			'#endif',
			'#ifdef USE_SKINNING',
			'	attribute vec4 skinIndex;',
			'	attribute vec4 skinWeight;',
			'#endif',
			`
`
		].filter(Ya).join(`
`)),
		(v = [
			p,
			op(t),
			'#define SHADER_NAME ' + t.shaderName,
			g,
			t.useFog && t.fog ? '#define USE_FOG' : '',
			t.useFog && t.fogExp2 ? '#define FOG_EXP2' : '',
			t.map ? '#define USE_MAP' : '',
			t.matcap ? '#define USE_MATCAP' : '',
			t.envMap ? '#define USE_ENVMAP' : '',
			t.envMap ? '#define ' + c : '',
			t.envMap ? '#define ' + u : '',
			t.envMap ? '#define ' + h : '',
			d ? '#define CUBEUV_TEXEL_WIDTH ' + d.texelWidth : '',
			d ? '#define CUBEUV_TEXEL_HEIGHT ' + d.texelHeight : '',
			d ? '#define CUBEUV_MAX_MIP ' + d.maxMip + '.0' : '',
			t.lightMap ? '#define USE_LIGHTMAP' : '',
			t.aoMap ? '#define USE_AOMAP' : '',
			t.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			t.bumpMap ? '#define USE_BUMPMAP' : '',
			t.normalMap ? '#define USE_NORMALMAP' : '',
			t.normalMap && t.objectSpaceNormalMap
				? '#define OBJECTSPACE_NORMALMAP'
				: '',
			t.normalMap && t.tangentSpaceNormalMap
				? '#define TANGENTSPACE_NORMALMAP'
				: '',
			t.clearcoat ? '#define USE_CLEARCOAT' : '',
			t.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			t.clearcoatRoughnessMap
				? '#define USE_CLEARCOAT_ROUGHNESSMAP'
				: '',
			t.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
			t.specularMap ? '#define USE_SPECULARMAP' : '',
			t.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
			t.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',
			t.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			t.metalnessMap ? '#define USE_METALNESSMAP' : '',
			t.alphaMap ? '#define USE_ALPHAMAP' : '',
			t.alphaTest ? '#define USE_ALPHATEST' : '',
			t.sheen ? '#define USE_SHEEN' : '',
			t.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
			t.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',
			t.transmission ? '#define USE_TRANSMISSION' : '',
			t.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
			t.thicknessMap ? '#define USE_THICKNESSMAP' : '',
			t.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',
			t.vertexTangents ? '#define USE_TANGENT' : '',
			t.vertexColors || t.instancingColor ? '#define USE_COLOR' : '',
			t.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
			t.vertexUvs ? '#define USE_UV' : '',
			t.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
			t.gradientMap ? '#define USE_GRADIENTMAP' : '',
			t.flatShading ? '#define FLAT_SHADED' : '',
			t.doubleSided ? '#define DOUBLE_SIDED' : '',
			t.flipSided ? '#define FLIP_SIDED' : '',
			t.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			t.shadowMapEnabled ? '#define ' + l : '',
			t.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
			t.physicallyCorrectLights
				? '#define PHYSICALLY_CORRECT_LIGHTS'
				: '',
			t.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
				? '#define USE_LOGDEPTHBUF_EXT'
				: '',
			'uniform mat4 viewMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',
			t.toneMapping !== $r ? '#define TONE_MAPPING' : '',
			t.toneMapping !== $r ? Ve.tonemapping_pars_fragment : '',
			t.toneMapping !== $r ? vM('toneMapping', t.toneMapping) : '',
			t.dithering ? '#define DITHERING' : '',
			t.opaque ? '#define OPAQUE' : '',
			Ve.encodings_pars_fragment,
			gM('linearToOutputTexel', t.outputEncoding),
			t.depthPacking ? '#define DEPTH_PACKING ' + t.depthPacking : '',
			`
`
		].filter(Ya).join(`
`))),
	(s = Xc(s)),
	(s = np(s, t)),
	(s = ap(s, t)),
	(o = Xc(o)),
	(o = np(o, t)),
	(o = ap(o, t)),
	(s = sp(s)),
	(o = sp(o)),
	t.isWebGL2 &&
            t.isRawShaderMaterial !== !0 &&
            ((x = `#version 300 es
`),
            (f =
                [
                	'precision mediump sampler2DArray;',
                	'#define attribute in',
                	'#define varying out',
                	'#define texture2D texture'
                ].join(`
`) +
                `
` +
                f),
            (v =
                [
                	'#define varying in',
                	t.glslVersion === Cd
                		? ''
                		: 'layout(location = 0) out highp vec4 pc_fragColor;',
                	t.glslVersion === Cd
                		? ''
                		: '#define gl_FragColor pc_fragColor',
                	'#define gl_FragDepthEXT gl_FragDepth',
                	'#define texture2D texture',
                	'#define textureCube texture',
                	'#define texture2DProj textureProj',
                	'#define texture2DLodEXT textureLod',
                	'#define texture2DProjLodEXT textureProjLod',
                	'#define textureCubeLodEXT textureLod',
                	'#define texture2DGradEXT textureGrad',
                	'#define texture2DProjGradEXT textureProjGrad',
                	'#define textureCubeGradEXT textureGrad'
                ].join(`
`) +
                `
` +
                v));
	const A = x + f + s,
		S = x + v + o,
		M = rp(n, 35633, A),
		I = rp(n, 35632, S);
	if (
		(n.attachShader(m, M),
		n.attachShader(m, I),
		t.index0AttributeName !== void 0
			? n.bindAttribLocation(m, 0, t.index0AttributeName)
			: t.morphTargets === !0 && n.bindAttribLocation(m, 0, 'position'),
		n.linkProgram(m),
		r.debug.checkShaderErrors)
	) {
		const re = n.getProgramInfoLog(m).trim(),
			B = n.getShaderInfoLog(M).trim(),
			b = n.getShaderInfoLog(I).trim();
		let E = !0,
			j = !0;
		if (n.getProgramParameter(m, 35714) === !1) {
			E = !1;
			const z = ip(n, M, 'vertex'),
				V = ip(n, I, 'fragment');
			console.error(
				'THREE.WebGLProgram: Shader Error ' +
                    n.getError() +
                    ' - VALIDATE_STATUS ' +
                    n.getProgramParameter(m, 35715) +
                    `

Program Info Log: ` +
                    re +
                    `
` +
                    z +
                    `
` +
                    V
			);
		} else
			re !== ''
				? console.warn('THREE.WebGLProgram: Program Info Log:', re)
				: (B === '' || b === '') && (j = !1);
		j &&
            (this.diagnostics = {
            	runnable: E,
            	programLog: re,
            	vertexShader: { log: B, prefix: f },
            	fragmentShader: { log: b, prefix: v }
            });
	}
	n.deleteShader(M), n.deleteShader(I);
	let D;
	this.getUniforms = function () {
		return D === void 0 && (D = new Ai(n, m)), D;
	};
	let G;
	return (
		(this.getAttributes = function () {
			return G === void 0 && (G = bM(n, m)), G;
		}),
		(this.destroy = function () {
			i.releaseStatesOfProgram(this),
			n.deleteProgram(m),
			(this.program = void 0);
		}),
		(this.name = t.shaderName),
		(this.id = pM++),
		(this.cacheKey = e),
		(this.usedTimes = 1),
		(this.program = m),
		(this.vertexShader = M),
		(this.fragmentShader = I),
		this
	);
}
let PM = 0;
class IM {
	constructor() {
		(this.shaderCache = new Map()), (this.materialCache = new Map());
	}
	update(e) {
		const t = e.vertexShader,
			i = e.fragmentShader,
			n = this._getShaderStage(t),
			a = this._getShaderStage(i),
			s = this._getShaderCacheForMaterial(e);
		return (
			s.has(n) === !1 && (s.add(n), n.usedTimes++),
			s.has(a) === !1 && (s.add(a), a.usedTimes++),
			this
		);
	}
	remove(e) {
		const t = this.materialCache.get(e);
		for (const i of t)
			i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
		return this.materialCache.delete(e), this;
	}
	getVertexShaderID(e) {
		return this._getShaderStage(e.vertexShader).id;
	}
	getFragmentShaderID(e) {
		return this._getShaderStage(e.fragmentShader).id;
	}
	dispose() {
		this.shaderCache.clear(), this.materialCache.clear();
	}
	_getShaderCacheForMaterial(e) {
		const t = this.materialCache;
		return t.has(e) === !1 && t.set(e, new Set()), t.get(e);
	}
	_getShaderStage(e) {
		const t = this.shaderCache;
		if (t.has(e) === !1) {
			const i = new DM(e);
			t.set(e, i);
		}
		return t.get(e);
	}
}
class DM {
	constructor(e) {
		(this.id = PM++), (this.code = e), (this.usedTimes = 0);
	}
}
function OM(r, e, t, i, n, a, s) {
	const o = new Of(),
		l = new IM(),
		c = [],
		u = n.isWebGL2,
		h = n.logarithmicDepthBuffer,
		d = n.floatVertexTextures,
		p = n.maxVertexUniforms,
		g = n.vertexTextures;
	let m = n.precision;
	const f = {
		MeshDepthMaterial: 'depth',
		MeshDistanceMaterial: 'distanceRGBA',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		MeshToonMaterial: 'toon',
		MeshStandardMaterial: 'physical',
		MeshPhysicalMaterial: 'physical',
		MeshMatcapMaterial: 'matcap',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points',
		ShadowMaterial: 'shadow',
		SpriteMaterial: 'sprite'
	};
	function v(b) {
		const E = b.skeleton.bones;
		if (d) return 1024;
		{
			const j = Math.floor((p - 20) / 4),
				z = Math.min(j, E.length);
			return z < E.length
				? (console.warn(
					'THREE.WebGLRenderer: Skeleton has ' +
                          E.length +
                          ' bones. This GPU supports ' +
                          z +
                          '.'
				),
				0)
				: z;
		}
	}
	function x(b, E, j, z, V) {
		const H = z.fog,
			k = V.geometry,
			P = b.isMeshStandardMaterial ? z.environment : null,
			Z = (b.isMeshStandardMaterial ? t : e).get(b.envMap || P),
			J = !!Z && Z.mapping === rl ? Z.image.height : null,
			fe = f[b.type],
			ce = V.isSkinnedMesh ? v(V) : 0;
		b.precision !== null &&
            ((m = n.getMaxPrecision(b.precision)),
            m !== b.precision &&
                console.warn(
                	'THREE.WebGLProgram.getParameters:',
                	b.precision,
                	'not supported, using',
                	m,
                	'instead.'
                ));
		const xe =
                k.morphAttributes.position ||
                k.morphAttributes.normal ||
                k.morphAttributes.color,
			W = xe !== void 0 ? xe.length : 0;
		let ue = 0;
		k.morphAttributes.position !== void 0 && (ue = 1),
		k.morphAttributes.normal !== void 0 && (ue = 2),
		k.morphAttributes.color !== void 0 && (ue = 3);
		let U, ve, Ae, Te;
		if (fe) {
			const w = kr[fe];
			(U = w.vertexShader), (ve = w.fragmentShader);
		} else
			(U = b.vertexShader),
			(ve = b.fragmentShader),
			l.update(b),
			(Ae = l.getVertexShaderID(b)),
			(Te = l.getFragmentShaderID(b));
		const ae = r.getRenderTarget(),
			K = b.alphaTest > 0,
			te = b.clearcoat > 0;
		return {
			isWebGL2: u,
			shaderID: fe,
			shaderName: b.type,
			vertexShader: U,
			fragmentShader: ve,
			defines: b.defines,
			customVertexShaderID: Ae,
			customFragmentShaderID: Te,
			isRawShaderMaterial: b.isRawShaderMaterial === !0,
			glslVersion: b.glslVersion,
			precision: m,
			instancing: V.isInstancedMesh === !0,
			instancingColor:
                V.isInstancedMesh === !0 && V.instanceColor !== null,
			supportsVertexTextures: g,
			outputEncoding:
                ae === null
                	? r.outputEncoding
                	: ae.isXRRenderTarget === !0
                		? ae.texture.encoding
                		: Qr,
			map: !!b.map,
			matcap: !!b.matcap,
			envMap: !!Z,
			envMapMode: Z && Z.mapping,
			envMapCubeUVHeight: J,
			lightMap: !!b.lightMap,
			aoMap: !!b.aoMap,
			emissiveMap: !!b.emissiveMap,
			bumpMap: !!b.bumpMap,
			normalMap: !!b.normalMap,
			objectSpaceNormalMap: b.normalMapType === $x,
			tangentSpaceNormalMap: b.normalMapType === un,
			decodeVideoTexture:
                !!b.map && b.map.isVideoTexture === !0 && b.map.encoding === Ze,
			clearcoat: te,
			clearcoatMap: te && !!b.clearcoatMap,
			clearcoatRoughnessMap: te && !!b.clearcoatRoughnessMap,
			clearcoatNormalMap: te && !!b.clearcoatNormalMap,
			displacementMap: !!b.displacementMap,
			roughnessMap: !!b.roughnessMap,
			metalnessMap: !!b.metalnessMap,
			specularMap: !!b.specularMap,
			specularIntensityMap: !!b.specularIntensityMap,
			specularColorMap: !!b.specularColorMap,
			opaque: b.transparent === !1 && b.blending === ea,
			alphaMap: !!b.alphaMap,
			alphaTest: K,
			gradientMap: !!b.gradientMap,
			sheen: b.sheen > 0,
			sheenColorMap: !!b.sheenColorMap,
			sheenRoughnessMap: !!b.sheenRoughnessMap,
			transmission: b.transmission > 0,
			transmissionMap: !!b.transmissionMap,
			thicknessMap: !!b.thicknessMap,
			combine: b.combine,
			vertexTangents: !!b.normalMap && !!k.attributes.tangent,
			vertexColors: b.vertexColors,
			vertexAlphas:
                b.vertexColors === !0 &&
                !!k.attributes.color &&
                k.attributes.color.itemSize === 4,
			vertexUvs:
                !!b.map ||
                !!b.bumpMap ||
                !!b.normalMap ||
                !!b.specularMap ||
                !!b.alphaMap ||
                !!b.emissiveMap ||
                !!b.roughnessMap ||
                !!b.metalnessMap ||
                !!b.clearcoatMap ||
                !!b.clearcoatRoughnessMap ||
                !!b.clearcoatNormalMap ||
                !!b.displacementMap ||
                !!b.transmissionMap ||
                !!b.thicknessMap ||
                !!b.specularIntensityMap ||
                !!b.specularColorMap ||
                !!b.sheenColorMap ||
                !!b.sheenRoughnessMap,
			uvsVertexOnly:
                !(
                	!!b.map ||
                    !!b.bumpMap ||
                    !!b.normalMap ||
                    !!b.specularMap ||
                    !!b.alphaMap ||
                    !!b.emissiveMap ||
                    !!b.roughnessMap ||
                    !!b.metalnessMap ||
                    !!b.clearcoatNormalMap ||
                    b.transmission > 0 ||
                    !!b.transmissionMap ||
                    !!b.thicknessMap ||
                    !!b.specularIntensityMap ||
                    !!b.specularColorMap ||
                    b.sheen > 0 ||
                    !!b.sheenColorMap ||
                    !!b.sheenRoughnessMap
                ) && !!b.displacementMap,
			fog: !!H,
			useFog: b.fog,
			fogExp2: H && H.isFogExp2,
			flatShading: !!b.flatShading,
			sizeAttenuation: b.sizeAttenuation,
			logarithmicDepthBuffer: h,
			skinning: V.isSkinnedMesh === !0 && ce > 0,
			maxBones: ce,
			useVertexTexture: d,
			morphTargets: k.morphAttributes.position !== void 0,
			morphNormals: k.morphAttributes.normal !== void 0,
			morphColors: k.morphAttributes.color !== void 0,
			morphTargetsCount: W,
			morphTextureStride: ue,
			numDirLights: E.directional.length,
			numPointLights: E.point.length,
			numSpotLights: E.spot.length,
			numRectAreaLights: E.rectArea.length,
			numHemiLights: E.hemi.length,
			numDirLightShadows: E.directionalShadowMap.length,
			numPointLightShadows: E.pointShadowMap.length,
			numSpotLightShadows: E.spotShadowMap.length,
			numClippingPlanes: s.numPlanes,
			numClipIntersection: s.numIntersection,
			dithering: b.dithering,
			shadowMapEnabled: r.shadowMap.enabled && j.length > 0,
			shadowMapType: r.shadowMap.type,
			toneMapping: b.toneMapped ? r.toneMapping : $r,
			physicallyCorrectLights: r.physicallyCorrectLights,
			premultipliedAlpha: b.premultipliedAlpha,
			doubleSided: b.side === an,
			flipSided: b.side === rr,
			depthPacking: b.depthPacking !== void 0 ? b.depthPacking : !1,
			index0AttributeName: b.index0AttributeName,
			extensionDerivatives: b.extensions && b.extensions.derivatives,
			extensionFragDepth: b.extensions && b.extensions.fragDepth,
			extensionDrawBuffers: b.extensions && b.extensions.drawBuffers,
			extensionShaderTextureLOD:
                b.extensions && b.extensions.shaderTextureLOD,
			rendererExtensionFragDepth: u || i.has('EXT_frag_depth'),
			rendererExtensionDrawBuffers: u || i.has('WEBGL_draw_buffers'),
			rendererExtensionShaderTextureLod:
                u || i.has('EXT_shader_texture_lod'),
			customProgramCacheKey: b.customProgramCacheKey()
		};
	}
	function A(b) {
		const E = [];
		if (
			(b.shaderID
				? E.push(b.shaderID)
				: (E.push(b.customVertexShaderID),
				E.push(b.customFragmentShaderID)),
			b.defines !== void 0)
		)
			for (const j in b.defines) E.push(j), E.push(b.defines[j]);
		return (
			b.isRawShaderMaterial === !1 &&
                (S(E, b), M(E, b), E.push(r.outputEncoding)),
			E.push(b.customProgramCacheKey),
			E.join()
		);
	}
	function S(b, E) {
		b.push(E.precision),
		b.push(E.outputEncoding),
		b.push(E.envMapMode),
		b.push(E.envMapCubeUVHeight),
		b.push(E.combine),
		b.push(E.vertexUvs),
		b.push(E.fogExp2),
		b.push(E.sizeAttenuation),
		b.push(E.maxBones),
		b.push(E.morphTargetsCount),
		b.push(E.morphAttributeCount),
		b.push(E.numDirLights),
		b.push(E.numPointLights),
		b.push(E.numSpotLights),
		b.push(E.numHemiLights),
		b.push(E.numRectAreaLights),
		b.push(E.numDirLightShadows),
		b.push(E.numPointLightShadows),
		b.push(E.numSpotLightShadows),
		b.push(E.shadowMapType),
		b.push(E.toneMapping),
		b.push(E.numClippingPlanes),
		b.push(E.numClipIntersection);
	}
	function M(b, E) {
		o.disableAll(),
		E.isWebGL2 && o.enable(0),
		E.supportsVertexTextures && o.enable(1),
		E.instancing && o.enable(2),
		E.instancingColor && o.enable(3),
		E.map && o.enable(4),
		E.matcap && o.enable(5),
		E.envMap && o.enable(6),
		E.lightMap && o.enable(7),
		E.aoMap && o.enable(8),
		E.emissiveMap && o.enable(9),
		E.bumpMap && o.enable(10),
		E.normalMap && o.enable(11),
		E.objectSpaceNormalMap && o.enable(12),
		E.tangentSpaceNormalMap && o.enable(13),
		E.clearcoat && o.enable(14),
		E.clearcoatMap && o.enable(15),
		E.clearcoatRoughnessMap && o.enable(16),
		E.clearcoatNormalMap && o.enable(17),
		E.displacementMap && o.enable(18),
		E.specularMap && o.enable(19),
		E.roughnessMap && o.enable(20),
		E.metalnessMap && o.enable(21),
		E.gradientMap && o.enable(22),
		E.alphaMap && o.enable(23),
		E.alphaTest && o.enable(24),
		E.vertexColors && o.enable(25),
		E.vertexAlphas && o.enable(26),
		E.vertexUvs && o.enable(27),
		E.vertexTangents && o.enable(28),
		E.uvsVertexOnly && o.enable(29),
		E.fog && o.enable(30),
		b.push(o.mask),
		o.disableAll(),
		E.useFog && o.enable(0),
		E.flatShading && o.enable(1),
		E.logarithmicDepthBuffer && o.enable(2),
		E.skinning && o.enable(3),
		E.useVertexTexture && o.enable(4),
		E.morphTargets && o.enable(5),
		E.morphNormals && o.enable(6),
		E.morphColors && o.enable(7),
		E.premultipliedAlpha && o.enable(8),
		E.shadowMapEnabled && o.enable(9),
		E.physicallyCorrectLights && o.enable(10),
		E.doubleSided && o.enable(11),
		E.flipSided && o.enable(12),
		E.depthPacking && o.enable(13),
		E.dithering && o.enable(14),
		E.specularIntensityMap && o.enable(15),
		E.specularColorMap && o.enable(16),
		E.transmission && o.enable(17),
		E.transmissionMap && o.enable(18),
		E.thicknessMap && o.enable(19),
		E.sheen && o.enable(20),
		E.sheenColorMap && o.enable(21),
		E.sheenRoughnessMap && o.enable(22),
		E.decodeVideoTexture && o.enable(23),
		E.opaque && o.enable(24),
		b.push(o.mask);
	}
	function I(b) {
		const E = f[b.type];
		let j;
		if (E) {
			const z = kr[E];
			j = Rb.clone(z.uniforms);
		} else j = b.uniforms;
		return j;
	}
	function D(b, E) {
		let j;
		for (let z = 0, V = c.length; z < V; z++) {
			const H = c[z];
			if (H.cacheKey === E) {
				(j = H), ++j.usedTimes;
				break;
			}
		}
		return j === void 0 && ((j = new CM(r, E, b, a)), c.push(j)), j;
	}
	function G(b) {
		if (--b.usedTimes === 0) {
			const E = c.indexOf(b);
			(c[E] = c[c.length - 1]), c.pop(), b.destroy();
		}
	}
	function re(b) {
		l.remove(b);
	}
	function B() {
		l.dispose();
	}
	return {
		getParameters: x,
		getProgramCacheKey: A,
		getUniforms: I,
		acquireProgram: D,
		releaseProgram: G,
		releaseShaderCache: re,
		programs: c,
		dispose: B
	};
}
function NM() {
	let r = new WeakMap();
	function e(a) {
		let s = r.get(a);
		return s === void 0 && ((s = {}), r.set(a, s)), s;
	}
	function t(a) {
		r.delete(a);
	}
	function i(a, s, o) {
		r.get(a)[s] = o;
	}
	function n() {
		r = new WeakMap();
	}
	return { get: e, remove: t, update: i, dispose: n };
}
function zM(r, e) {
	return r.groupOrder !== e.groupOrder
		? r.groupOrder - e.groupOrder
		: r.renderOrder !== e.renderOrder
			? r.renderOrder - e.renderOrder
			: r.material.id !== e.material.id
				? r.material.id - e.material.id
				: r.z !== e.z
					? r.z - e.z
					: r.id - e.id;
}
function lp(r, e) {
	return r.groupOrder !== e.groupOrder
		? r.groupOrder - e.groupOrder
		: r.renderOrder !== e.renderOrder
			? r.renderOrder - e.renderOrder
			: r.z !== e.z
				? e.z - r.z
				: r.id - e.id;
}
function cp() {
	const r = [];
	let e = 0;
	const t = [],
		i = [],
		n = [];
	function a() {
		(e = 0), (t.length = 0), (i.length = 0), (n.length = 0);
	}
	function s(h, d, p, g, m, f) {
		let v = r[e];
		return (
			v === void 0
				? ((v = {
					id: h.id,
					object: h,
					geometry: d,
					material: p,
					groupOrder: g,
					renderOrder: h.renderOrder,
					z: m,
					group: f
				}),
				(r[e] = v))
				: ((v.id = h.id),
				(v.object = h),
				(v.geometry = d),
				(v.material = p),
				(v.groupOrder = g),
				(v.renderOrder = h.renderOrder),
				(v.z = m),
				(v.group = f)),
			e++,
			v
		);
	}
	function o(h, d, p, g, m, f) {
		const v = s(h, d, p, g, m, f);
		p.transmission > 0
			? i.push(v)
			: p.transparent === !0
				? n.push(v)
				: t.push(v);
	}
	function l(h, d, p, g, m, f) {
		const v = s(h, d, p, g, m, f);
		p.transmission > 0
			? i.unshift(v)
			: p.transparent === !0
				? n.unshift(v)
				: t.unshift(v);
	}
	function c(h, d) {
		t.length > 1 && t.sort(h || zM),
		i.length > 1 && i.sort(d || lp),
		n.length > 1 && n.sort(d || lp);
	}
	function u() {
		for (let h = e, d = r.length; h < d; h++) {
			const p = r[h];
			if (p.id === null) break;
			(p.id = null),
			(p.object = null),
			(p.geometry = null),
			(p.material = null),
			(p.group = null);
		}
	}
	return {
		opaque: t,
		transmissive: i,
		transparent: n,
		init: a,
		push: o,
		unshift: l,
		finish: u,
		sort: c
	};
}
function UM() {
	let r = new WeakMap();
	function e(i, n) {
		let a;
		return (
			r.has(i) === !1
				? ((a = new cp()), r.set(i, [a]))
				: n >= r.get(i).length
					? ((a = new cp()), r.get(i).push(a))
					: (a = r.get(i)[n]),
			a
		);
	}
	function t() {
		r = new WeakMap();
	}
	return { get: e, dispose: t };
}
function BM() {
	const r = {};
	return {
		get: function (e) {
			if (r[e.id] !== void 0) return r[e.id];
			let t;
			switch (e.type) {
			case 'DirectionalLight':
				t = { direction: new C(), color: new ke() };
				break;
			case 'SpotLight':
				t = {
					position: new C(),
					direction: new C(),
					color: new ke(),
					distance: 0,
					coneCos: 0,
					penumbraCos: 0,
					decay: 0
				};
				break;
			case 'PointLight':
				t = {
					position: new C(),
					color: new ke(),
					distance: 0,
					decay: 0
				};
				break;
			case 'HemisphereLight':
				t = {
					direction: new C(),
					skyColor: new ke(),
					groundColor: new ke()
				};
				break;
			case 'RectAreaLight':
				t = {
					color: new ke(),
					position: new C(),
					halfWidth: new C(),
					halfHeight: new C()
				};
				break;
			}
			return (r[e.id] = t), t;
		}
	};
}
function FM() {
	const r = {};
	return {
		get: function (e) {
			if (r[e.id] !== void 0) return r[e.id];
			let t;
			switch (e.type) {
			case 'DirectionalLight':
				t = {
					shadowBias: 0,
					shadowNormalBias: 0,
					shadowRadius: 1,
					shadowMapSize: new me()
				};
				break;
			case 'SpotLight':
				t = {
					shadowBias: 0,
					shadowNormalBias: 0,
					shadowRadius: 1,
					shadowMapSize: new me()
				};
				break;
			case 'PointLight':
				t = {
					shadowBias: 0,
					shadowNormalBias: 0,
					shadowRadius: 1,
					shadowMapSize: new me(),
					shadowCameraNear: 1,
					shadowCameraFar: 1e3
				};
				break;
			}
			return (r[e.id] = t), t;
		}
	};
}
let HM = 0;
function GM(r, e) {
	return (e.castShadow ? 1 : 0) - (r.castShadow ? 1 : 0);
}
function VM(r, e) {
	const t = new BM(),
		i = FM(),
		n = {
			version: 0,
			hash: {
				directionalLength: -1,
				pointLength: -1,
				spotLength: -1,
				rectAreaLength: -1,
				hemiLength: -1,
				numDirectionalShadows: -1,
				numPointShadows: -1,
				numSpotShadows: -1
			},
			ambient: [0, 0, 0],
			probe: [],
			directional: [],
			directionalShadow: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadow: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			rectAreaLTC1: null,
			rectAreaLTC2: null,
			point: [],
			pointShadow: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: []
		};
	for (let u = 0; u < 9; u++) n.probe.push(new C());
	const a = new C(),
		s = new Pe(),
		o = new Pe();
	function l(u, h) {
		let d = 0,
			p = 0,
			g = 0;
		for (let re = 0; re < 9; re++) n.probe[re].set(0, 0, 0);
		let m = 0,
			f = 0,
			v = 0,
			x = 0,
			A = 0,
			S = 0,
			M = 0,
			I = 0;
		u.sort(GM);
		const D = h !== !0 ? Math.PI : 1;
		for (let re = 0, B = u.length; re < B; re++) {
			const b = u[re],
				E = b.color,
				j = b.intensity,
				z = b.distance,
				V = b.shadow && b.shadow.map ? b.shadow.map.texture : null;
			if (b.isAmbientLight)
				(d += E.r * j * D), (p += E.g * j * D), (g += E.b * j * D);
			else if (b.isLightProbe)
				for (let H = 0; H < 9; H++)
					n.probe[H].addScaledVector(b.sh.coefficients[H], j);
			else if (b.isDirectionalLight) {
				const H = t.get(b);
				if (
					(H.color.copy(b.color).multiplyScalar(b.intensity * D),
					b.castShadow)
				) {
					const k = b.shadow,
						P = i.get(b);
					(P.shadowBias = k.bias),
					(P.shadowNormalBias = k.normalBias),
					(P.shadowRadius = k.radius),
					(P.shadowMapSize = k.mapSize),
					(n.directionalShadow[m] = P),
					(n.directionalShadowMap[m] = V),
					(n.directionalShadowMatrix[m] = b.shadow.matrix),
					S++;
				}
				(n.directional[m] = H), m++;
			} else if (b.isSpotLight) {
				const H = t.get(b);
				if (
					(H.position.setFromMatrixPosition(b.matrixWorld),
					H.color.copy(E).multiplyScalar(j * D),
					(H.distance = z),
					(H.coneCos = Math.cos(b.angle)),
					(H.penumbraCos = Math.cos(b.angle * (1 - b.penumbra))),
					(H.decay = b.decay),
					b.castShadow)
				) {
					const k = b.shadow,
						P = i.get(b);
					(P.shadowBias = k.bias),
					(P.shadowNormalBias = k.normalBias),
					(P.shadowRadius = k.radius),
					(P.shadowMapSize = k.mapSize),
					(n.spotShadow[v] = P),
					(n.spotShadowMap[v] = V),
					(n.spotShadowMatrix[v] = b.shadow.matrix),
					I++;
				}
				(n.spot[v] = H), v++;
			} else if (b.isRectAreaLight) {
				const H = t.get(b);
				H.color.copy(E).multiplyScalar(j),
				H.halfWidth.set(b.width * 0.5, 0, 0),
				H.halfHeight.set(0, b.height * 0.5, 0),
				(n.rectArea[x] = H),
				x++;
			} else if (b.isPointLight) {
				const H = t.get(b);
				if (
					(H.color.copy(b.color).multiplyScalar(b.intensity * D),
					(H.distance = b.distance),
					(H.decay = b.decay),
					b.castShadow)
				) {
					const k = b.shadow,
						P = i.get(b);
					(P.shadowBias = k.bias),
					(P.shadowNormalBias = k.normalBias),
					(P.shadowRadius = k.radius),
					(P.shadowMapSize = k.mapSize),
					(P.shadowCameraNear = k.camera.near),
					(P.shadowCameraFar = k.camera.far),
					(n.pointShadow[f] = P),
					(n.pointShadowMap[f] = V),
					(n.pointShadowMatrix[f] = b.shadow.matrix),
					M++;
				}
				(n.point[f] = H), f++;
			} else if (b.isHemisphereLight) {
				const H = t.get(b);
				H.skyColor.copy(b.color).multiplyScalar(j * D),
				H.groundColor.copy(b.groundColor).multiplyScalar(j * D),
				(n.hemi[A] = H),
				A++;
			}
		}
		x > 0 &&
            (e.isWebGL2 || r.has('OES_texture_float_linear') === !0
            	? ((n.rectAreaLTC1 = Ee.LTC_FLOAT_1),
            	(n.rectAreaLTC2 = Ee.LTC_FLOAT_2))
            	: r.has('OES_texture_half_float_linear') === !0
            		? ((n.rectAreaLTC1 = Ee.LTC_HALF_1),
            		(n.rectAreaLTC2 = Ee.LTC_HALF_2))
            		: console.error(
            			'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.'
            		)),
		(n.ambient[0] = d),
		(n.ambient[1] = p),
		(n.ambient[2] = g);
		const G = n.hash;
		(G.directionalLength !== m ||
            G.pointLength !== f ||
            G.spotLength !== v ||
            G.rectAreaLength !== x ||
            G.hemiLength !== A ||
            G.numDirectionalShadows !== S ||
            G.numPointShadows !== M ||
            G.numSpotShadows !== I) &&
            ((n.directional.length = m),
            (n.spot.length = v),
            (n.rectArea.length = x),
            (n.point.length = f),
            (n.hemi.length = A),
            (n.directionalShadow.length = S),
            (n.directionalShadowMap.length = S),
            (n.pointShadow.length = M),
            (n.pointShadowMap.length = M),
            (n.spotShadow.length = I),
            (n.spotShadowMap.length = I),
            (n.directionalShadowMatrix.length = S),
            (n.pointShadowMatrix.length = M),
            (n.spotShadowMatrix.length = I),
            (G.directionalLength = m),
            (G.pointLength = f),
            (G.spotLength = v),
            (G.rectAreaLength = x),
            (G.hemiLength = A),
            (G.numDirectionalShadows = S),
            (G.numPointShadows = M),
            (G.numSpotShadows = I),
            (n.version = HM++));
	}
	function c(u, h) {
		let d = 0,
			p = 0,
			g = 0,
			m = 0,
			f = 0;
		const v = h.matrixWorldInverse;
		for (let x = 0, A = u.length; x < A; x++) {
			const S = u[x];
			if (S.isDirectionalLight) {
				const M = n.directional[d];
				M.direction.setFromMatrixPosition(S.matrixWorld),
				a.setFromMatrixPosition(S.target.matrixWorld),
				M.direction.sub(a),
				M.direction.transformDirection(v),
				d++;
			} else if (S.isSpotLight) {
				const M = n.spot[g];
				M.position.setFromMatrixPosition(S.matrixWorld),
				M.position.applyMatrix4(v),
				M.direction.setFromMatrixPosition(S.matrixWorld),
				a.setFromMatrixPosition(S.target.matrixWorld),
				M.direction.sub(a),
				M.direction.transformDirection(v),
				g++;
			} else if (S.isRectAreaLight) {
				const M = n.rectArea[m];
				M.position.setFromMatrixPosition(S.matrixWorld),
				M.position.applyMatrix4(v),
				o.identity(),
				s.copy(S.matrixWorld),
				s.premultiply(v),
				o.extractRotation(s),
				M.halfWidth.set(S.width * 0.5, 0, 0),
				M.halfHeight.set(0, S.height * 0.5, 0),
				M.halfWidth.applyMatrix4(o),
				M.halfHeight.applyMatrix4(o),
				m++;
			} else if (S.isPointLight) {
				const M = n.point[p];
				M.position.setFromMatrixPosition(S.matrixWorld),
				M.position.applyMatrix4(v),
				p++;
			} else if (S.isHemisphereLight) {
				const M = n.hemi[f];
				M.direction.setFromMatrixPosition(S.matrixWorld),
				M.direction.transformDirection(v),
				M.direction.normalize(),
				f++;
			}
		}
	}
	return { setup: l, setupView: c, state: n };
}
function up(r, e) {
	const t = new VM(r, e),
		i = [],
		n = [];
	function a() {
		(i.length = 0), (n.length = 0);
	}
	function s(u) {
		i.push(u);
	}
	function o(u) {
		n.push(u);
	}
	function l(u) {
		t.setup(i, u);
	}
	function c(u) {
		t.setupView(i, u);
	}
	return {
		init: a,
		state: { lightsArray: i, shadowsArray: n, lights: t },
		setupLights: l,
		setupLightsView: c,
		pushLight: s,
		pushShadow: o
	};
}
function WM(r, e) {
	let t = new WeakMap();
	function i(a, s = 0) {
		let o;
		return (
			t.has(a) === !1
				? ((o = new up(r, e)), t.set(a, [o]))
				: s >= t.get(a).length
					? ((o = new up(r, e)), t.get(a).push(o))
					: (o = t.get(a)[s]),
			o
		);
	}
	function n() {
		t = new WeakMap();
	}
	return { get: i, dispose: n };
}
class zu extends dt {
	constructor(e) {
		super(),
		(this.type = 'MeshDepthMaterial'),
		(this.depthPacking = Yx),
		(this.map = null),
		(this.alphaMap = null),
		(this.displacementMap = null),
		(this.displacementScale = 1),
		(this.displacementBias = 0),
		(this.wireframe = !1),
		(this.wireframeLinewidth = 1),
		(this.fog = !1),
		this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			(this.depthPacking = e.depthPacking),
			(this.map = e.map),
			(this.alphaMap = e.alphaMap),
			(this.displacementMap = e.displacementMap),
			(this.displacementScale = e.displacementScale),
			(this.displacementBias = e.displacementBias),
			(this.wireframe = e.wireframe),
			(this.wireframeLinewidth = e.wireframeLinewidth),
			this
		);
	}
}
zu.prototype.isMeshDepthMaterial = !0;
class Uu extends dt {
	constructor(e) {
		super(),
		(this.type = 'MeshDistanceMaterial'),
		(this.referencePosition = new C()),
		(this.nearDistance = 1),
		(this.farDistance = 1e3),
		(this.map = null),
		(this.alphaMap = null),
		(this.displacementMap = null),
		(this.displacementScale = 1),
		(this.displacementBias = 0),
		(this.fog = !1),
		this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			this.referencePosition.copy(e.referencePosition),
			(this.nearDistance = e.nearDistance),
			(this.farDistance = e.farDistance),
			(this.map = e.map),
			(this.alphaMap = e.alphaMap),
			(this.displacementMap = e.displacementMap),
			(this.displacementScale = e.displacementScale),
			(this.displacementBias = e.displacementBias),
			this
		);
	}
}
Uu.prototype.isMeshDistanceMaterial = !0;
const jM = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
	XM = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function qf(r, e, t) {
	let i = new al();
	const n = new me(),
		a = new me(),
		s = new it(),
		o = new zu({ depthPacking: Zx }),
		l = new Uu(),
		c = {},
		u = t.maxTextureSize,
		h = { 0: rr, 1: na, 2: an },
		d = new br({
			defines: { VSM_SAMPLES: 8 },
			uniforms: {
				shadow_pass: { value: null },
				resolution: { value: new me() },
				radius: { value: 4 }
			},
			vertexShader: jM,
			fragmentShader: XM
		}),
		p = d.clone();
	p.defines.HORIZONTAL_PASS = 1;
	const g = new ot();
	g.setAttribute(
		'position',
		new mt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
	);
	const m = new rt(g, d),
		f = this;
	(this.enabled = !1),
	(this.autoUpdate = !0),
	(this.needsUpdate = !1),
	(this.type = _f),
	(this.render = function (S, M, I) {
		if (
			f.enabled === !1 ||
                (f.autoUpdate === !1 && f.needsUpdate === !1) ||
                S.length === 0
		)
			return;
		const D = r.getRenderTarget(),
			G = r.getActiveCubeFace(),
			re = r.getActiveMipmapLevel(),
			B = r.state;
		B.setBlending(Ei),
		B.buffers.color.setClear(1, 1, 1, 1),
		B.buffers.depth.setTest(!0),
		B.setScissorTest(!1);
		for (let b = 0, E = S.length; b < E; b++) {
			const j = S[b],
				z = j.shadow;
			if (z === void 0) {
				console.warn('THREE.WebGLShadowMap:', j, 'has no shadow.');
				continue;
			}
			if (z.autoUpdate === !1 && z.needsUpdate === !1) continue;
			n.copy(z.mapSize);
			const V = z.getFrameExtents();
			if (
				(n.multiply(V),
				a.copy(z.mapSize),
				(n.x > u || n.y > u) &&
                        (n.x > u &&
                            ((a.x = Math.floor(u / V.x)),
                            (n.x = a.x * V.x),
                            (z.mapSize.x = a.x)),
                        n.y > u &&
                            ((a.y = Math.floor(u / V.y)),
                            (n.y = a.y * V.y),
                            (z.mapSize.y = a.y))),
				z.map === null &&
                        !z.isPointLightShadow &&
                        this.type === qa &&
                        ((z.map = new Xt(n.x, n.y)),
                        (z.map.texture.name = j.name + '.shadowMap'),
                        (z.mapPass = new Xt(n.x, n.y)),
                        z.camera.updateProjectionMatrix()),
				z.map === null)
			) {
				const k = { minFilter: Mt, magFilter: Mt, format: Qt };
				(z.map = new Xt(n.x, n.y, k)),
				(z.map.texture.name = j.name + '.shadowMap'),
				z.camera.updateProjectionMatrix();
			}
			r.setRenderTarget(z.map), r.clear();
			const H = z.getViewportCount();
			for (let k = 0; k < H; k++) {
				const P = z.getViewport(k);
				s.set(a.x * P.x, a.y * P.y, a.x * P.z, a.y * P.w),
				B.viewport(s),
				z.updateMatrices(j, k),
				(i = z.getFrustum()),
				A(M, I, z.camera, j, this.type);
			}
			!z.isPointLightShadow && this.type === qa && v(z, I),
			(z.needsUpdate = !1);
		}
		(f.needsUpdate = !1), r.setRenderTarget(D, G, re);
	});
	function v(S, M) {
		const I = e.update(m);
		d.defines.VSM_SAMPLES !== S.blurSamples &&
            ((d.defines.VSM_SAMPLES = S.blurSamples),
            (p.defines.VSM_SAMPLES = S.blurSamples),
            (d.needsUpdate = !0),
            (p.needsUpdate = !0)),
		(d.uniforms.shadow_pass.value = S.map.texture),
		(d.uniforms.resolution.value = S.mapSize),
		(d.uniforms.radius.value = S.radius),
		r.setRenderTarget(S.mapPass),
		r.clear(),
		r.renderBufferDirect(M, null, I, d, m, null),
		(p.uniforms.shadow_pass.value = S.mapPass.texture),
		(p.uniforms.resolution.value = S.mapSize),
		(p.uniforms.radius.value = S.radius),
		r.setRenderTarget(S.map),
		r.clear(),
		r.renderBufferDirect(M, null, I, p, m, null);
	}
	function x(S, M, I, D, G, re) {
		let B = null;
		const b =
            I.isPointLight === !0
            	? S.customDistanceMaterial
            	: S.customDepthMaterial;
		if (
			(b !== void 0 ? (B = b) : (B = I.isPointLight === !0 ? l : o),
			(r.localClippingEnabled &&
                M.clipShadows === !0 &&
                M.clippingPlanes.length !== 0) ||
                (M.displacementMap && M.displacementScale !== 0) ||
                (M.alphaMap && M.alphaTest > 0))
		) {
			const E = B.uuid,
				j = M.uuid;
			let z = c[E];
			z === void 0 && ((z = {}), (c[E] = z));
			let V = z[j];
			V === void 0 && ((V = B.clone()), (z[j] = V)), (B = V);
		}
		return (
			(B.visible = M.visible),
			(B.wireframe = M.wireframe),
			re === qa
				? (B.side = M.shadowSide !== null ? M.shadowSide : M.side)
				: (B.side = M.shadowSide !== null ? M.shadowSide : h[M.side]),
			(B.alphaMap = M.alphaMap),
			(B.alphaTest = M.alphaTest),
			(B.clipShadows = M.clipShadows),
			(B.clippingPlanes = M.clippingPlanes),
			(B.clipIntersection = M.clipIntersection),
			(B.displacementMap = M.displacementMap),
			(B.displacementScale = M.displacementScale),
			(B.displacementBias = M.displacementBias),
			(B.wireframeLinewidth = M.wireframeLinewidth),
			(B.linewidth = M.linewidth),
			I.isPointLight === !0 &&
                B.isMeshDistanceMaterial === !0 &&
                (B.referencePosition.setFromMatrixPosition(I.matrixWorld),
                (B.nearDistance = D),
                (B.farDistance = G)),
			B
		);
	}
	function A(S, M, I, D, G) {
		if (S.visible === !1) return;
		if (
			S.layers.test(M.layers) &&
            (S.isMesh || S.isLine || S.isPoints) &&
            (S.castShadow || (S.receiveShadow && G === qa)) &&
            (!S.frustumCulled || i.intersectsObject(S))
		) {
			S.modelViewMatrix.multiplyMatrices(
				I.matrixWorldInverse,
				S.matrixWorld
			);
			const B = e.update(S),
				b = S.material;
			if (Array.isArray(b)) {
				const E = B.groups;
				for (let j = 0, z = E.length; j < z; j++) {
					const V = E[j],
						H = b[V.materialIndex];
					if (H && H.visible) {
						const k = x(S, H, D, I.near, I.far, G);
						r.renderBufferDirect(I, null, B, k, S, V);
					}
				}
			} else if (b.visible) {
				const E = x(S, b, D, I.near, I.far, G);
				r.renderBufferDirect(I, null, B, E, S, null);
			}
		}
		const re = S.children;
		for (let B = 0, b = re.length; B < b; B++) A(re[B], M, I, D, G);
	}
}
function qM(r, e, t) {
	const i = t.isWebGL2;
	function n() {
		let O = !1;
		const ye = new it();
		let we = null;
		const Le = new it(0, 0, 0, 0);
		return {
			setMask: function (be) {
				we !== be && !O && (r.colorMask(be, be, be, be), (we = be));
			},
			setLocked: function (be) {
				O = be;
			},
			setClear: function (be, Ne, Se, Ue, $e) {
				$e === !0 && ((be *= Ue), (Ne *= Ue), (Se *= Ue)),
				ye.set(be, Ne, Se, Ue),
				Le.equals(ye) === !1 &&
                        (r.clearColor(be, Ne, Se, Ue), Le.copy(ye));
			},
			reset: function () {
				(O = !1), (we = null), Le.set(-1, 0, 0, 0);
			}
		};
	}
	function a() {
		let O = !1,
			ye = null,
			we = null,
			Le = null;
		return {
			setTest: function (be) {
				be ? ue(2929) : U(2929);
			},
			setMask: function (be) {
				ye !== be && !O && (r.depthMask(be), (ye = be));
			},
			setFunc: function (be) {
				if (we !== be) {
					if (be)
						switch (be) {
						case mx:
							r.depthFunc(512);
							break;
						case fx:
							r.depthFunc(519);
							break;
						case gx:
							r.depthFunc(513);
							break;
						case Uc:
							r.depthFunc(515);
							break;
						case vx:
							r.depthFunc(514);
							break;
						case yx:
							r.depthFunc(518);
							break;
						case xx:
							r.depthFunc(516);
							break;
						case bx:
							r.depthFunc(517);
							break;
						default:
							r.depthFunc(515);
						}
					else r.depthFunc(515);
					we = be;
				}
			},
			setLocked: function (be) {
				O = be;
			},
			setClear: function (be) {
				Le !== be && (r.clearDepth(be), (Le = be));
			},
			reset: function () {
				(O = !1), (ye = null), (we = null), (Le = null);
			}
		};
	}
	function s() {
		let O = !1,
			ye = null,
			we = null,
			Le = null,
			be = null,
			Ne = null,
			Se = null,
			Ue = null,
			$e = null;
		return {
			setTest: function (nt) {
				O || (nt ? ue(2960) : U(2960));
			},
			setMask: function (nt) {
				ye !== nt && !O && (r.stencilMask(nt), (ye = nt));
			},
			setFunc: function (nt, wr, _r) {
				(we !== nt || Le !== wr || be !== _r) &&
                    (r.stencilFunc(nt, wr, _r),
                    (we = nt),
                    (Le = wr),
                    (be = _r));
			},
			setOp: function (nt, wr, _r) {
				(Ne !== nt || Se !== wr || Ue !== _r) &&
                    (r.stencilOp(nt, wr, _r), (Ne = nt), (Se = wr), (Ue = _r));
			},
			setLocked: function (nt) {
				O = nt;
			},
			setClear: function (nt) {
				$e !== nt && (r.clearStencil(nt), ($e = nt));
			},
			reset: function () {
				(O = !1),
				(ye = null),
				(we = null),
				(Le = null),
				(be = null),
				(Ne = null),
				(Se = null),
				(Ue = null),
				($e = null);
			}
		};
	}
	const o = new n(),
		l = new a(),
		c = new s();
	let u = {},
		h = {},
		d = new WeakMap(),
		p = [],
		g = null,
		m = !1,
		f = null,
		v = null,
		x = null,
		A = null,
		S = null,
		M = null,
		I = null,
		D = !1,
		G = null,
		re = null,
		B = null,
		b = null,
		E = null;
	const j = r.getParameter(35661);
	let z = !1,
		V = 0;
	const H = r.getParameter(7938);
	H.indexOf('WebGL') !== -1
		? ((V = parseFloat(/^WebGL (\d)/.exec(H)[1])), (z = V >= 1))
		: H.indexOf('OpenGL ES') !== -1 &&
          ((V = parseFloat(/^OpenGL ES (\d)/.exec(H)[1])), (z = V >= 2));
	let k = null,
		P = {};
	const Z = r.getParameter(3088),
		J = r.getParameter(2978),
		fe = new it().fromArray(Z),
		ce = new it().fromArray(J);
	function xe(O, ye, we) {
		const Le = new Uint8Array(4),
			be = r.createTexture();
		r.bindTexture(O, be),
		r.texParameteri(O, 10241, 9728),
		r.texParameteri(O, 10240, 9728);
		for (let Ne = 0; Ne < we; Ne++)
			r.texImage2D(ye + Ne, 0, 6408, 1, 1, 0, 6408, 5121, Le);
		return be;
	}
	const W = {};
	(W[3553] = xe(3553, 3553, 1)),
	(W[34067] = xe(34067, 34069, 6)),
	o.setClear(0, 0, 0, 1),
	l.setClear(1),
	c.setClear(0),
	ue(2929),
	l.setFunc(Uc),
	R(!1),
	N(nd),
	ue(2884),
	te(Ei);
	function ue(O) {
		u[O] !== !0 && (r.enable(O), (u[O] = !0));
	}
	function U(O) {
		u[O] !== !1 && (r.disable(O), (u[O] = !1));
	}
	function ve(O, ye) {
		return h[O] !== ye
			? (r.bindFramebuffer(O, ye),
			(h[O] = ye),
			i &&
                  (O === 36009 && (h[36160] = ye),
                  O === 36160 && (h[36009] = ye)),
			!0)
			: !1;
	}
	function Ae(O, ye) {
		let we = p,
			Le = !1;
		if (O)
			if (
				((we = d.get(ye)),
				we === void 0 && ((we = []), d.set(ye, we)),
				O.isWebGLMultipleRenderTargets)
			) {
				const be = O.texture;
				if (we.length !== be.length || we[0] !== 36064) {
					for (let Ne = 0, Se = be.length; Ne < Se; Ne++)
						we[Ne] = 36064 + Ne;
					(we.length = be.length), (Le = !0);
				}
			} else we[0] !== 36064 && ((we[0] = 36064), (Le = !0));
		else we[0] !== 1029 && ((we[0] = 1029), (Le = !0));
		Le &&
            (t.isWebGL2
            	? r.drawBuffers(we)
            	: e.get('WEBGL_draw_buffers').drawBuffersWEBGL(we));
	}
	function Te(O) {
		return g !== O ? (r.useProgram(O), (g = O), !0) : !1;
	}
	const ae = { [Wn]: 32774, [ix]: 32778, [nx]: 32779 };
	if (i) (ae[ld] = 32775), (ae[cd] = 32776);
	else {
		const O = e.get('EXT_blend_minmax');
		O !== null && ((ae[ld] = O.MIN_EXT), (ae[cd] = O.MAX_EXT));
	}
	const K = {
		[ax]: 0,
		[sx]: 1,
		[ox]: 768,
		[Tf]: 770,
		[px]: 776,
		[hx]: 774,
		[cx]: 772,
		[lx]: 769,
		[Ef]: 771,
		[dx]: 775,
		[ux]: 773
	};
	function te(O, ye, we, Le, be, Ne, Se, Ue) {
		if (O === Ei) {
			m === !0 && (U(3042), (m = !1));
			return;
		}
		if ((m === !1 && (ue(3042), (m = !0)), O !== rx)) {
			if (O !== f || Ue !== D) {
				if (
					((v !== Wn || S !== Wn) &&
                        (r.blendEquation(32774), (v = Wn), (S = Wn)),
					Ue)
				)
					switch (O) {
					case ea:
						r.blendFuncSeparate(1, 771, 1, 771);
						break;
					case ad:
						r.blendFunc(1, 1);
						break;
					case sd:
						r.blendFuncSeparate(0, 769, 0, 1);
						break;
					case od:
						r.blendFuncSeparate(0, 768, 0, 770);
						break;
					default:
						console.error(
							'THREE.WebGLState: Invalid blending: ',
							O
						);
						break;
					}
				else
					switch (O) {
					case ea:
						r.blendFuncSeparate(770, 771, 1, 771);
						break;
					case ad:
						r.blendFunc(770, 1);
						break;
					case sd:
						r.blendFuncSeparate(0, 769, 0, 1);
						break;
					case od:
						r.blendFunc(0, 768);
						break;
					default:
						console.error(
							'THREE.WebGLState: Invalid blending: ',
							O
						);
						break;
					}
				(x = null),
				(A = null),
				(M = null),
				(I = null),
				(f = O),
				(D = Ue);
			}
			return;
		}
		(be = be || ye),
		(Ne = Ne || we),
		(Se = Se || Le),
		(ye !== v || be !== S) &&
                (r.blendEquationSeparate(ae[ye], ae[be]), (v = ye), (S = be)),
		(we !== x || Le !== A || Ne !== M || Se !== I) &&
                (r.blendFuncSeparate(K[we], K[Le], K[Ne], K[Se]),
                (x = we),
                (A = Le),
                (M = Ne),
                (I = Se)),
		(f = O),
		(D = null);
	}
	function w(O, ye) {
		O.side === an ? U(2884) : ue(2884);
		let we = O.side === rr;
		ye && (we = !we),
		R(we),
		O.blending === ea && O.transparent === !1
			? te(Ei)
			: te(
				O.blending,
				O.blendEquation,
				O.blendSrc,
				O.blendDst,
				O.blendEquationAlpha,
				O.blendSrcAlpha,
				O.blendDstAlpha,
				O.premultipliedAlpha
			),
		l.setFunc(O.depthFunc),
		l.setTest(O.depthTest),
		l.setMask(O.depthWrite),
		o.setMask(O.colorWrite);
		const Le = O.stencilWrite;
		c.setTest(Le),
		Le &&
                (c.setMask(O.stencilWriteMask),
                c.setFunc(O.stencilFunc, O.stencilRef, O.stencilFuncMask),
                c.setOp(O.stencilFail, O.stencilZFail, O.stencilZPass)),
		$(O.polygonOffset, O.polygonOffsetFactor, O.polygonOffsetUnits),
		O.alphaToCoverage === !0 ? ue(32926) : U(32926);
	}
	function R(O) {
		G !== O && (O ? r.frontFace(2304) : r.frontFace(2305), (G = O));
	}
	function N(O) {
		O !== ex
			? (ue(2884),
			O !== re &&
                  (O === nd
                  	? r.cullFace(1029)
                  	: O === tx
                  		? r.cullFace(1028)
                  		: r.cullFace(1032)))
			: U(2884),
		(re = O);
	}
	function q(O) {
		O !== B && (z && r.lineWidth(O), (B = O));
	}
	function $(O, ye, we) {
		O
			? (ue(32823),
			(b !== ye || E !== we) &&
                  (r.polygonOffset(ye, we), (b = ye), (E = we)))
			: U(32823);
	}
	function ne(O) {
		O ? ue(3089) : U(3089);
	}
	function le(O) {
		O === void 0 && (O = 33984 + j - 1),
		k !== O && (r.activeTexture(O), (k = O));
	}
	function he(O, ye) {
		k === null && le();
		let we = P[k];
		we === void 0 &&
            ((we = { type: void 0, texture: void 0 }), (P[k] = we)),
		(we.type !== O || we.texture !== ye) &&
                (r.bindTexture(O, ye || W[O]),
                (we.type = O),
                (we.texture = ye));
	}
	function ge() {
		const O = P[k];
		O !== void 0 &&
            O.type !== void 0 &&
            (r.bindTexture(O.type, null),
            (O.type = void 0),
            (O.texture = void 0));
	}
	function _() {
		try {
			r.compressedTexImage2D.apply(r, arguments);
		} catch (O) {
			console.error('THREE.WebGLState:', O);
		}
	}
	function y() {
		try {
			r.texSubImage2D.apply(r, arguments);
		} catch (O) {
			console.error('THREE.WebGLState:', O);
		}
	}
	function F() {
		try {
			r.texSubImage3D.apply(r, arguments);
		} catch (O) {
			console.error('THREE.WebGLState:', O);
		}
	}
	function Y() {
		try {
			r.compressedTexSubImage2D.apply(r, arguments);
		} catch (O) {
			console.error('THREE.WebGLState:', O);
		}
	}
	function oe() {
		try {
			r.texStorage2D.apply(r, arguments);
		} catch (O) {
			console.error('THREE.WebGLState:', O);
		}
	}
	function pe() {
		try {
			r.texStorage3D.apply(r, arguments);
		} catch (O) {
			console.error('THREE.WebGLState:', O);
		}
	}
	function Me() {
		try {
			r.texImage2D.apply(r, arguments);
		} catch (O) {
			console.error('THREE.WebGLState:', O);
		}
	}
	function T() {
		try {
			r.texImage3D.apply(r, arguments);
		} catch (O) {
			console.error('THREE.WebGLState:', O);
		}
	}
	function se(O) {
		fe.equals(O) === !1 && (r.scissor(O.x, O.y, O.z, O.w), fe.copy(O));
	}
	function Re(O) {
		ce.equals(O) === !1 && (r.viewport(O.x, O.y, O.z, O.w), ce.copy(O));
	}
	function _e() {
		r.disable(3042),
		r.disable(2884),
		r.disable(2929),
		r.disable(32823),
		r.disable(3089),
		r.disable(2960),
		r.disable(32926),
		r.blendEquation(32774),
		r.blendFunc(1, 0),
		r.blendFuncSeparate(1, 0, 1, 0),
		r.colorMask(!0, !0, !0, !0),
		r.clearColor(0, 0, 0, 0),
		r.depthMask(!0),
		r.depthFunc(513),
		r.clearDepth(1),
		r.stencilMask(4294967295),
		r.stencilFunc(519, 0, 4294967295),
		r.stencilOp(7680, 7680, 7680),
		r.clearStencil(0),
		r.cullFace(1029),
		r.frontFace(2305),
		r.polygonOffset(0, 0),
		r.activeTexture(33984),
		r.bindFramebuffer(36160, null),
		i === !0 &&
                (r.bindFramebuffer(36009, null),
                r.bindFramebuffer(36008, null)),
		r.useProgram(null),
		r.lineWidth(1),
		r.scissor(0, 0, r.canvas.width, r.canvas.height),
		r.viewport(0, 0, r.canvas.width, r.canvas.height),
		(u = {}),
		(k = null),
		(P = {}),
		(h = {}),
		(d = new WeakMap()),
		(p = []),
		(g = null),
		(m = !1),
		(f = null),
		(v = null),
		(x = null),
		(A = null),
		(S = null),
		(M = null),
		(I = null),
		(D = !1),
		(G = null),
		(re = null),
		(B = null),
		(b = null),
		(E = null),
		fe.set(0, 0, r.canvas.width, r.canvas.height),
		ce.set(0, 0, r.canvas.width, r.canvas.height),
		o.reset(),
		l.reset(),
		c.reset();
	}
	return {
		buffers: { color: o, depth: l, stencil: c },
		enable: ue,
		disable: U,
		bindFramebuffer: ve,
		drawBuffers: Ae,
		useProgram: Te,
		setBlending: te,
		setMaterial: w,
		setFlipSided: R,
		setCullFace: N,
		setLineWidth: q,
		setPolygonOffset: $,
		setScissorTest: ne,
		activeTexture: le,
		bindTexture: he,
		unbindTexture: ge,
		compressedTexImage2D: _,
		texImage2D: Me,
		texImage3D: T,
		texStorage2D: oe,
		texStorage3D: pe,
		texSubImage2D: y,
		texSubImage3D: F,
		compressedTexSubImage2D: Y,
		scissor: se,
		viewport: Re,
		reset: _e
	};
}
function YM(r, e, t, i, n, a, s) {
	const o = n.isWebGL2,
		l = n.maxTextures,
		c = n.maxCubemapSize,
		u = n.maxTextureSize,
		h = n.maxSamples,
		d = e.has('WEBGL_multisampled_render_to_texture')
			? e.get('WEBGL_multisampled_render_to_texture')
			: null,
		p = /OculusBrowser/g.test(navigator.userAgent),
		g = new WeakMap();
	let m;
	const f = new WeakMap();
	let v = !1;
	try {
		v =
            typeof OffscreenCanvas != 'undefined' &&
            new OffscreenCanvas(1, 1).getContext('2d') !== null;
	} catch {}
	function x(_, y) {
		return v ? new OffscreenCanvas(_, y) : ys('canvas');
	}
	function A(_, y, F, Y) {
		let oe = 1;
		if (
			((_.width > Y || _.height > Y) &&
                (oe = Y / Math.max(_.width, _.height)),
			oe < 1 || y === !0)
		)
			if (
				(typeof HTMLImageElement != 'undefined' &&
                    _ instanceof HTMLImageElement) ||
                (typeof HTMLCanvasElement != 'undefined' &&
                    _ instanceof HTMLCanvasElement) ||
                (typeof ImageBitmap != 'undefined' && _ instanceof ImageBitmap)
			) {
				const pe = y ? Uo : Math.floor,
					Me = pe(oe * _.width),
					T = pe(oe * _.height);
				m === void 0 && (m = x(Me, T));
				const se = F ? x(Me, T) : m;
				return (
					(se.width = Me),
					(se.height = T),
					se.getContext('2d').drawImage(_, 0, 0, Me, T),
					console.warn(
						'THREE.WebGLRenderer: Texture has been resized from (' +
                            _.width +
                            'x' +
                            _.height +
                            ') to (' +
                            Me +
                            'x' +
                            T +
                            ').'
					),
					se
				);
			} else
				return (
					'data' in _ &&
                        console.warn(
                        	'THREE.WebGLRenderer: Image in DataTexture is too big (' +
                                _.width +
                                'x' +
                                _.height +
                                ').'
                        ),
					_
				);
		return _;
	}
	function S(_) {
		return Wc(_.width) && Wc(_.height);
	}
	function M(_) {
		return o
			? !1
			: _.wrapS !== Kt ||
                  _.wrapT !== Kt ||
                  (_.minFilter !== Mt && _.minFilter !== Nt);
	}
	function I(_, y) {
		return (
			_.generateMipmaps && y && _.minFilter !== Mt && _.minFilter !== Nt
		);
	}
	function D(_) {
		r.generateMipmap(_);
	}
	function G(_, y, F, Y, oe = !1) {
		if (o === !1) return y;
		if (_ !== null) {
			if (r[_] !== void 0) return r[_];
			console.warn(
				'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' +
                    _ +
                    '\''
			);
		}
		let pe = y;
		return (
			y === 6403 &&
                (F === 5126 && (pe = 33326),
                F === 5131 && (pe = 33325),
                F === 5121 && (pe = 33321)),
			y === 33319 &&
                (F === 5126 && (pe = 33328),
                F === 5131 && (pe = 33327),
                F === 5121 && (pe = 33323)),
			y === 6408 &&
                (F === 5126 && (pe = 34836),
                F === 5131 && (pe = 34842),
                F === 5121 && (pe = Y === Ze && oe === !1 ? 35907 : 32856),
                F === 32819 && (pe = 32854),
                F === 32820 && (pe = 32855)),
			(pe === 33325 ||
                pe === 33326 ||
                pe === 33327 ||
                pe === 33328 ||
                pe === 34842 ||
                pe === 34836) &&
                e.get('EXT_color_buffer_float'),
			pe
		);
	}
	function re(_, y, F) {
		return I(_, F) === !0 ||
            (_.isFramebufferTexture && _.minFilter !== Mt && _.minFilter !== Nt)
			? Math.log2(Math.max(y.width, y.height)) + 1
			: _.mipmaps !== void 0 && _.mipmaps.length > 0
				? _.mipmaps.length
				: _.isCompressedTexture && Array.isArray(_.image)
					? y.mipmaps.length
					: 1;
	}
	function B(_) {
		return _ === Mt || _ === Hc || _ === Gc ? 9728 : 9729;
	}
	function b(_) {
		const y = _.target;
		y.removeEventListener('dispose', b),
		j(y),
		y.isVideoTexture && g.delete(y);
	}
	function E(_) {
		const y = _.target;
		y.removeEventListener('dispose', E), V(y);
	}
	function j(_) {
		const y = i.get(_);
		if (y.__webglInit === void 0) return;
		const F = _.source,
			Y = f.get(F);
		if (Y) {
			const oe = Y[y.__cacheKey];
			oe.usedTimes--,
			oe.usedTimes === 0 && z(_),
			Object.keys(Y).length === 0 && f.delete(F);
		}
		i.remove(_);
	}
	function z(_) {
		const y = i.get(_);
		r.deleteTexture(y.__webglTexture);
		const F = _.source,
			Y = f.get(F);
		delete Y[y.__cacheKey], s.memory.textures--;
	}
	function V(_) {
		const y = _.texture,
			F = i.get(_),
			Y = i.get(y);
		if (
			(Y.__webglTexture !== void 0 &&
                (r.deleteTexture(Y.__webglTexture), s.memory.textures--),
			_.depthTexture && _.depthTexture.dispose(),
			_.isWebGLCubeRenderTarget)
		)
			for (let oe = 0; oe < 6; oe++)
				r.deleteFramebuffer(F.__webglFramebuffer[oe]),
				F.__webglDepthbuffer &&
                        r.deleteRenderbuffer(F.__webglDepthbuffer[oe]);
		else
			r.deleteFramebuffer(F.__webglFramebuffer),
			F.__webglDepthbuffer &&
                    r.deleteRenderbuffer(F.__webglDepthbuffer),
			F.__webglMultisampledFramebuffer &&
                    r.deleteFramebuffer(F.__webglMultisampledFramebuffer),
			F.__webglColorRenderbuffer &&
                    r.deleteRenderbuffer(F.__webglColorRenderbuffer),
			F.__webglDepthRenderbuffer &&
                    r.deleteRenderbuffer(F.__webglDepthRenderbuffer);
		if (_.isWebGLMultipleRenderTargets)
			for (let oe = 0, pe = y.length; oe < pe; oe++) {
				const Me = i.get(y[oe]);
				Me.__webglTexture &&
                    (r.deleteTexture(Me.__webglTexture), s.memory.textures--),
				i.remove(y[oe]);
			}
		i.remove(y), i.remove(_);
	}
	let H = 0;
	function k() {
		H = 0;
	}
	function P() {
		const _ = H;
		return (
			_ >= l &&
                console.warn(
                	'THREE.WebGLTextures: Trying to use ' +
                        _ +
                        ' texture units while this GPU supports only ' +
                        l
                ),
			(H += 1),
			_
		);
	}
	function Z(_) {
		const y = [];
		return (
			y.push(_.wrapS),
			y.push(_.wrapT),
			y.push(_.magFilter),
			y.push(_.minFilter),
			y.push(_.anisotropy),
			y.push(_.internalFormat),
			y.push(_.format),
			y.push(_.type),
			y.push(_.generateMipmaps),
			y.push(_.premultiplyAlpha),
			y.push(_.flipY),
			y.push(_.unpackAlignment),
			y.push(_.encoding),
			y.join()
		);
	}
	function J(_, y) {
		const F = i.get(_);
		if (
			(_.isVideoTexture && he(_),
			_.isRenderTargetTexture === !1 &&
                _.version > 0 &&
                F.__version !== _.version)
		) {
			const Y = _.image;
			if (Y === null)
				console.warn(
					'THREE.WebGLRenderer: Texture marked for update but no image data found.'
				);
			else if (Y.complete === !1)
				console.warn(
					'THREE.WebGLRenderer: Texture marked for update but image is incomplete'
				);
			else {
				Ae(F, _, y);
				return;
			}
		}
		t.activeTexture(33984 + y), t.bindTexture(3553, F.__webglTexture);
	}
	function fe(_, y) {
		const F = i.get(_);
		if (_.version > 0 && F.__version !== _.version) {
			Ae(F, _, y);
			return;
		}
		t.activeTexture(33984 + y), t.bindTexture(35866, F.__webglTexture);
	}
	function ce(_, y) {
		const F = i.get(_);
		if (_.version > 0 && F.__version !== _.version) {
			Ae(F, _, y);
			return;
		}
		t.activeTexture(33984 + y), t.bindTexture(32879, F.__webglTexture);
	}
	function xe(_, y) {
		const F = i.get(_);
		if (_.version > 0 && F.__version !== _.version) {
			Te(F, _, y);
			return;
		}
		t.activeTexture(33984 + y), t.bindTexture(34067, F.__webglTexture);
	}
	const W = { [oa]: 10497, [Kt]: 33071, [Oo]: 33648 },
		ue = {
			[Mt]: 9728,
			[Hc]: 9984,
			[Gc]: 9986,
			[Nt]: 9729,
			[Lf]: 9985,
			[ba]: 9987
		};
	function U(_, y, F) {
		if (
			(F
				? (r.texParameteri(_, 10242, W[y.wrapS]),
				r.texParameteri(_, 10243, W[y.wrapT]),
				(_ === 32879 || _ === 35866) &&
                      r.texParameteri(_, 32882, W[y.wrapR]),
				r.texParameteri(_, 10240, ue[y.magFilter]),
				r.texParameteri(_, 10241, ue[y.minFilter]))
				: (r.texParameteri(_, 10242, 33071),
				r.texParameteri(_, 10243, 33071),
				(_ === 32879 || _ === 35866) &&
                      r.texParameteri(_, 32882, 33071),
				(y.wrapS !== Kt || y.wrapT !== Kt) &&
                      console.warn(
                      	'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.'
                      ),
				r.texParameteri(_, 10240, B(y.magFilter)),
				r.texParameteri(_, 10241, B(y.minFilter)),
				y.minFilter !== Mt &&
                      y.minFilter !== Nt &&
                      console.warn(
                      	'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.'
                      )),
			e.has('EXT_texture_filter_anisotropic') === !0)
		) {
			const Y = e.get('EXT_texture_filter_anisotropic');
			if (
				(y.type === wi && e.has('OES_texture_float_linear') === !1) ||
                (o === !1 &&
                    y.type === ta &&
                    e.has('OES_texture_half_float_linear') === !1)
			)
				return;
			(y.anisotropy > 1 || i.get(y).__currentAnisotropy) &&
                (r.texParameterf(
                	_,
                	Y.TEXTURE_MAX_ANISOTROPY_EXT,
                	Math.min(y.anisotropy, n.getMaxAnisotropy())
                ),
                (i.get(y).__currentAnisotropy = y.anisotropy));
		}
	}
	function ve(_, y) {
		let F = !1;
		_.__webglInit === void 0 &&
            ((_.__webglInit = !0), y.addEventListener('dispose', b));
		const Y = y.source;
		let oe = f.get(Y);
		oe === void 0 && ((oe = {}), f.set(Y, oe));
		const pe = Z(y);
		if (pe !== _.__cacheKey) {
			oe[pe] === void 0 &&
                ((oe[pe] = { texture: r.createTexture(), usedTimes: 0 }),
                s.memory.textures++,
                (F = !0)),
			oe[pe].usedTimes++;
			const Me = oe[_.__cacheKey];
			Me !== void 0 &&
                (oe[_.__cacheKey].usedTimes--, Me.usedTimes === 0 && z(y)),
			(_.__cacheKey = pe),
			(_.__webglTexture = oe[pe].texture);
		}
		return F;
	}
	function Ae(_, y, F) {
		let Y = 3553;
		y.isDataArrayTexture && (Y = 35866), y.isData3DTexture && (Y = 32879);
		const oe = ve(_, y),
			pe = y.source;
		if (
			(t.activeTexture(33984 + F),
			t.bindTexture(Y, _.__webglTexture),
			pe.version !== pe.__currentVersion || oe === !0)
		) {
			r.pixelStorei(37440, y.flipY),
			r.pixelStorei(37441, y.premultiplyAlpha),
			r.pixelStorei(3317, y.unpackAlignment),
			r.pixelStorei(37443, 0);
			const Me = M(y) && S(y.image) === !1;
			let T = A(y.image, Me, !1, u);
			T = ge(y, T);
			const se = S(T) || o,
				Re = a.convert(y.format, y.encoding);
			let _e = a.convert(y.type),
				O = G(y.internalFormat, Re, _e, y.encoding, y.isVideoTexture);
			U(Y, y, se);
			let ye;
			const we = y.mipmaps,
				Le = o && y.isVideoTexture !== !0,
				be = _.__version === void 0,
				Ne = re(y, T, se);
			if (y.isDepthTexture)
				(O = 6402),
				o
					? y.type === wi
						? (O = 36012)
						: y.type === Eo
							? (O = 33190)
							: y.type === ra
								? (O = 35056)
								: (O = 33189)
					: y.type === wi &&
                          console.error(
                          	'WebGLRenderer: Floating point depth texture requires WebGL2.'
                          ),
				y.format === rn &&
                        O === 6402 &&
                        y.type !== ms &&
                        y.type !== Eo &&
                        (console.warn(
                        	'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.'
                        ),
                        (y.type = ms),
                        (_e = a.convert(y.type))),
				y.format === la &&
                        O === 6402 &&
                        ((O = 34041),
                        y.type !== ra &&
                            (console.warn(
                            	'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.'
                            ),
                            (y.type = ra),
                            (_e = a.convert(y.type)))),
				Le && be
					? t.texStorage2D(3553, 1, O, T.width, T.height)
					: t.texImage2D(
						3553,
						0,
						O,
						T.width,
						T.height,
						0,
						Re,
						_e,
						null
					);
			else if (y.isDataTexture)
				if (we.length > 0 && se) {
					Le &&
                        be &&
                        t.texStorage2D(3553, Ne, O, we[0].width, we[0].height);
					for (let Se = 0, Ue = we.length; Se < Ue; Se++)
						(ye = we[Se]),
						Le
							? t.texSubImage2D(
								3553,
								Se,
								0,
								0,
								ye.width,
								ye.height,
								Re,
								_e,
								ye.data
							)
							: t.texImage2D(
								3553,
								Se,
								O,
								ye.width,
								ye.height,
								0,
								Re,
								_e,
								ye.data
							);
					y.generateMipmaps = !1;
				} else
					Le
						? (be && t.texStorage2D(3553, Ne, O, T.width, T.height),
						t.texSubImage2D(
							3553,
							0,
							0,
							0,
							T.width,
							T.height,
							Re,
							_e,
							T.data
						))
						: t.texImage2D(
							3553,
							0,
							O,
							T.width,
							T.height,
							0,
							Re,
							_e,
							T.data
						);
			else if (y.isCompressedTexture) {
				Le &&
                    be &&
                    t.texStorage2D(3553, Ne, O, we[0].width, we[0].height);
				for (let Se = 0, Ue = we.length; Se < Ue; Se++)
					(ye = we[Se]),
					y.format !== Qt
						? Re !== null
							? Le
								? t.compressedTexSubImage2D(
									3553,
									Se,
									0,
									0,
									ye.width,
									ye.height,
									Re,
									ye.data
								)
								: t.compressedTexImage2D(
									3553,
									Se,
									O,
									ye.width,
									ye.height,
									0,
									ye.data
								)
							: console.warn(
								'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'
							)
						: Le
							? t.texSubImage2D(
								3553,
								Se,
								0,
								0,
								ye.width,
								ye.height,
								Re,
								_e,
								ye.data
							)
							: t.texImage2D(
								3553,
								Se,
								O,
								ye.width,
								ye.height,
								0,
								Re,
								_e,
								ye.data
							);
			} else if (y.isDataArrayTexture)
				Le
					? (be &&
                          t.texStorage3D(
                          	35866,
                          	Ne,
                          	O,
                          	T.width,
                          	T.height,
                          	T.depth
                          ),
					t.texSubImage3D(
						35866,
						0,
						0,
						0,
						0,
						T.width,
						T.height,
						T.depth,
						Re,
						_e,
						T.data
					))
					: t.texImage3D(
						35866,
						0,
						O,
						T.width,
						T.height,
						T.depth,
						0,
						Re,
						_e,
						T.data
					);
			else if (y.isData3DTexture)
				Le
					? (be &&
                          t.texStorage3D(
                          	32879,
                          	Ne,
                          	O,
                          	T.width,
                          	T.height,
                          	T.depth
                          ),
					t.texSubImage3D(
						32879,
						0,
						0,
						0,
						0,
						T.width,
						T.height,
						T.depth,
						Re,
						_e,
						T.data
					))
					: t.texImage3D(
						32879,
						0,
						O,
						T.width,
						T.height,
						T.depth,
						0,
						Re,
						_e,
						T.data
					);
			else if (y.isFramebufferTexture)
				Le && be
					? t.texStorage2D(3553, Ne, O, T.width, T.height)
					: t.texImage2D(
						3553,
						0,
						O,
						T.width,
						T.height,
						0,
						Re,
						_e,
						null
					);
			else if (we.length > 0 && se) {
				Le &&
                    be &&
                    t.texStorage2D(3553, Ne, O, we[0].width, we[0].height);
				for (let Se = 0, Ue = we.length; Se < Ue; Se++)
					(ye = we[Se]),
					Le
						? t.texSubImage2D(3553, Se, 0, 0, Re, _e, ye)
						: t.texImage2D(3553, Se, O, Re, _e, ye);
				y.generateMipmaps = !1;
			} else
				Le
					? (be && t.texStorage2D(3553, Ne, O, T.width, T.height),
					t.texSubImage2D(3553, 0, 0, 0, Re, _e, T))
					: t.texImage2D(3553, 0, O, Re, _e, T);
			I(y, se) && D(Y),
			(pe.__currentVersion = pe.version),
			y.onUpdate && y.onUpdate(y);
		}
		_.__version = y.version;
	}
	function Te(_, y, F) {
		if (y.image.length !== 6) return;
		const Y = ve(_, y),
			oe = y.source;
		if (
			(t.activeTexture(33984 + F),
			t.bindTexture(34067, _.__webglTexture),
			oe.version !== oe.__currentVersion || Y === !0)
		) {
			r.pixelStorei(37440, y.flipY),
			r.pixelStorei(37441, y.premultiplyAlpha),
			r.pixelStorei(3317, y.unpackAlignment),
			r.pixelStorei(37443, 0);
			const pe = y.isCompressedTexture || y.image[0].isCompressedTexture,
				Me = y.image[0] && y.image[0].isDataTexture,
				T = [];
			for (let Se = 0; Se < 6; Se++)
				!pe && !Me
					? (T[Se] = A(y.image[Se], !1, !0, c))
					: (T[Se] = Me ? y.image[Se].image : y.image[Se]),
				(T[Se] = ge(y, T[Se]));
			const se = T[0],
				Re = S(se) || o,
				_e = a.convert(y.format, y.encoding),
				O = a.convert(y.type),
				ye = G(y.internalFormat, _e, O, y.encoding),
				we = o && y.isVideoTexture !== !0,
				Le = _.__version === void 0;
			let be = re(y, se, Re);
			U(34067, y, Re);
			let Ne;
			if (pe) {
				we && Le && t.texStorage2D(34067, be, ye, se.width, se.height);
				for (let Se = 0; Se < 6; Se++) {
					Ne = T[Se].mipmaps;
					for (let Ue = 0; Ue < Ne.length; Ue++) {
						const $e = Ne[Ue];
						y.format !== Qt
							? _e !== null
								? we
									? t.compressedTexSubImage2D(
										34069 + Se,
										Ue,
										0,
										0,
										$e.width,
										$e.height,
										_e,
										$e.data
									)
									: t.compressedTexImage2D(
										34069 + Se,
										Ue,
										ye,
										$e.width,
										$e.height,
										0,
										$e.data
									)
								: console.warn(
									'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()'
								)
							: we
								? t.texSubImage2D(
									34069 + Se,
									Ue,
									0,
									0,
									$e.width,
									$e.height,
									_e,
									O,
									$e.data
								)
								: t.texImage2D(
									34069 + Se,
									Ue,
									ye,
									$e.width,
									$e.height,
									0,
									_e,
									O,
									$e.data
								);
					}
				}
			} else {
				(Ne = y.mipmaps),
				we &&
                        Le &&
                        (Ne.length > 0 && be++,
                        t.texStorage2D(34067, be, ye, T[0].width, T[0].height));
				for (let Se = 0; Se < 6; Se++)
					if (Me) {
						we
							? t.texSubImage2D(
								34069 + Se,
								0,
								0,
								0,
								T[Se].width,
								T[Se].height,
								_e,
								O,
								T[Se].data
							)
							: t.texImage2D(
								34069 + Se,
								0,
								ye,
								T[Se].width,
								T[Se].height,
								0,
								_e,
								O,
								T[Se].data
							);
						for (let Ue = 0; Ue < Ne.length; Ue++) {
							const $e = Ne[Ue].image[Se].image;
							we
								? t.texSubImage2D(
									34069 + Se,
									Ue + 1,
									0,
									0,
									$e.width,
									$e.height,
									_e,
									O,
									$e.data
								)
								: t.texImage2D(
									34069 + Se,
									Ue + 1,
									ye,
									$e.width,
									$e.height,
									0,
									_e,
									O,
									$e.data
								);
						}
					} else {
						we
							? t.texSubImage2D(34069 + Se, 0, 0, 0, _e, O, T[Se])
							: t.texImage2D(34069 + Se, 0, ye, _e, O, T[Se]);
						for (let Ue = 0; Ue < Ne.length; Ue++) {
							const $e = Ne[Ue];
							we
								? t.texSubImage2D(
									34069 + Se,
									Ue + 1,
									0,
									0,
									_e,
									O,
									$e.image[Se]
								)
								: t.texImage2D(
									34069 + Se,
									Ue + 1,
									ye,
									_e,
									O,
									$e.image[Se]
								);
						}
					}
			}
			I(y, Re) && D(34067),
			(oe.__currentVersion = oe.version),
			y.onUpdate && y.onUpdate(y);
		}
		_.__version = y.version;
	}
	function ae(_, y, F, Y, oe) {
		const pe = a.convert(F.format, F.encoding),
			Me = a.convert(F.type),
			T = G(F.internalFormat, pe, Me, F.encoding);
		i.get(y).__hasExternalTextures ||
            (oe === 32879 || oe === 35866
            	? t.texImage3D(
            		oe,
            		0,
            		T,
            		y.width,
            		y.height,
            		y.depth,
            		0,
            		pe,
            		Me,
            		null
            	)
            	: t.texImage2D(oe, 0, T, y.width, y.height, 0, pe, Me, null)),
		t.bindFramebuffer(36160, _),
		le(y)
			? d.framebufferTexture2DMultisampleEXT(
				36160,
				Y,
				oe,
				i.get(F).__webglTexture,
				0,
				ne(y)
			)
			: r.framebufferTexture2D(
				36160,
				Y,
				oe,
				i.get(F).__webglTexture,
				0
			),
		t.bindFramebuffer(36160, null);
	}
	function K(_, y, F) {
		if ((r.bindRenderbuffer(36161, _), y.depthBuffer && !y.stencilBuffer)) {
			let Y = 33189;
			if (F || le(y)) {
				const oe = y.depthTexture;
				oe &&
                    oe.isDepthTexture &&
                    (oe.type === wi
                    	? (Y = 36012)
                    	: oe.type === Eo && (Y = 33190));
				const pe = ne(y);
				le(y)
					? d.renderbufferStorageMultisampleEXT(
						36161,
						pe,
						Y,
						y.width,
						y.height
					)
					: r.renderbufferStorageMultisample(
						36161,
						pe,
						Y,
						y.width,
						y.height
					);
			} else r.renderbufferStorage(36161, Y, y.width, y.height);
			r.framebufferRenderbuffer(36160, 36096, 36161, _);
		} else if (y.depthBuffer && y.stencilBuffer) {
			const Y = ne(y);
			F && le(y) === !1
				? r.renderbufferStorageMultisample(
					36161,
					Y,
					35056,
					y.width,
					y.height
				)
				: le(y)
					? d.renderbufferStorageMultisampleEXT(
						36161,
						Y,
						35056,
						y.width,
						y.height
					)
					: r.renderbufferStorage(36161, 34041, y.width, y.height),
			r.framebufferRenderbuffer(36160, 33306, 36161, _);
		} else {
			const Y =
                    y.isWebGLMultipleRenderTargets === !0
                    	? y.texture[0]
                    	: y.texture,
				oe = a.convert(Y.format, Y.encoding),
				pe = a.convert(Y.type),
				Me = G(Y.internalFormat, oe, pe, Y.encoding),
				T = ne(y);
			F && le(y) === !1
				? r.renderbufferStorageMultisample(
					36161,
					T,
					Me,
					y.width,
					y.height
				)
				: le(y)
					? d.renderbufferStorageMultisampleEXT(
						36161,
						T,
						Me,
						y.width,
						y.height
					)
					: r.renderbufferStorage(36161, Me, y.width, y.height);
		}
		r.bindRenderbuffer(36161, null);
	}
	function te(_, y) {
		if (y && y.isWebGLCubeRenderTarget)
			throw new Error(
				'Depth Texture with cube render targets is not supported'
			);
		if (
			(t.bindFramebuffer(36160, _),
			!(y.depthTexture && y.depthTexture.isDepthTexture))
		)
			throw new Error(
				'renderTarget.depthTexture must be an instance of THREE.DepthTexture'
			);
		(!i.get(y.depthTexture).__webglTexture ||
            y.depthTexture.image.width !== y.width ||
            y.depthTexture.image.height !== y.height) &&
            ((y.depthTexture.image.width = y.width),
            (y.depthTexture.image.height = y.height),
            (y.depthTexture.needsUpdate = !0)),
		J(y.depthTexture, 0);
		const F = i.get(y.depthTexture).__webglTexture,
			Y = ne(y);
		if (y.depthTexture.format === rn)
			le(y)
				? d.framebufferTexture2DMultisampleEXT(
					36160,
					36096,
					3553,
					F,
					0,
					Y
				)
				: r.framebufferTexture2D(36160, 36096, 3553, F, 0);
		else if (y.depthTexture.format === la)
			le(y)
				? d.framebufferTexture2DMultisampleEXT(
					36160,
					33306,
					3553,
					F,
					0,
					Y
				)
				: r.framebufferTexture2D(36160, 33306, 3553, F, 0);
		else throw new Error('Unknown depthTexture format');
	}
	function w(_) {
		const y = i.get(_),
			F = _.isWebGLCubeRenderTarget === !0;
		if (_.depthTexture && !y.__autoAllocateDepthBuffer) {
			if (F)
				throw new Error(
					'target.depthTexture not supported in Cube render targets'
				);
			te(y.__webglFramebuffer, _);
		} else if (F) {
			y.__webglDepthbuffer = [];
			for (let Y = 0; Y < 6; Y++)
				t.bindFramebuffer(36160, y.__webglFramebuffer[Y]),
				(y.__webglDepthbuffer[Y] = r.createRenderbuffer()),
				K(y.__webglDepthbuffer[Y], _, !1);
		} else
			t.bindFramebuffer(36160, y.__webglFramebuffer),
			(y.__webglDepthbuffer = r.createRenderbuffer()),
			K(y.__webglDepthbuffer, _, !1);
		t.bindFramebuffer(36160, null);
	}
	function R(_, y, F) {
		const Y = i.get(_);
		y !== void 0 && ae(Y.__webglFramebuffer, _, _.texture, 36064, 3553),
		F !== void 0 && w(_);
	}
	function N(_) {
		const y = _.texture,
			F = i.get(_),
			Y = i.get(y);
		_.addEventListener('dispose', E),
		_.isWebGLMultipleRenderTargets !== !0 &&
                (Y.__webglTexture === void 0 &&
                    (Y.__webglTexture = r.createTexture()),
                (Y.__version = y.version),
                s.memory.textures++);
		const oe = _.isWebGLCubeRenderTarget === !0,
			pe = _.isWebGLMultipleRenderTargets === !0,
			Me = S(_) || o;
		if (oe) {
			F.__webglFramebuffer = [];
			for (let T = 0; T < 6; T++)
				F.__webglFramebuffer[T] = r.createFramebuffer();
		} else if (((F.__webglFramebuffer = r.createFramebuffer()), pe))
			if (n.drawBuffers) {
				const T = _.texture;
				for (let se = 0, Re = T.length; se < Re; se++) {
					const _e = i.get(T[se]);
					_e.__webglTexture === void 0 &&
                        ((_e.__webglTexture = r.createTexture()),
                        s.memory.textures++);
				}
			} else
				console.warn(
					'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.'
				);
		else if (o && _.samples > 0 && le(_) === !1) {
			(F.__webglMultisampledFramebuffer = r.createFramebuffer()),
			(F.__webglColorRenderbuffer = r.createRenderbuffer()),
			r.bindRenderbuffer(36161, F.__webglColorRenderbuffer);
			const T = a.convert(y.format, y.encoding),
				se = a.convert(y.type),
				Re = G(y.internalFormat, T, se, y.encoding),
				_e = ne(_);
			r.renderbufferStorageMultisample(36161, _e, Re, _.width, _.height),
			t.bindFramebuffer(36160, F.__webglMultisampledFramebuffer),
			r.framebufferRenderbuffer(
				36160,
				36064,
				36161,
				F.__webglColorRenderbuffer
			),
			r.bindRenderbuffer(36161, null),
			_.depthBuffer &&
                    ((F.__webglDepthRenderbuffer = r.createRenderbuffer()),
                    K(F.__webglDepthRenderbuffer, _, !0)),
			t.bindFramebuffer(36160, null);
		}
		if (oe) {
			t.bindTexture(34067, Y.__webglTexture), U(34067, y, Me);
			for (let T = 0; T < 6; T++)
				ae(F.__webglFramebuffer[T], _, y, 36064, 34069 + T);
			I(y, Me) && D(34067), t.unbindTexture();
		} else if (pe) {
			const T = _.texture;
			for (let se = 0, Re = T.length; se < Re; se++) {
				const _e = T[se],
					O = i.get(_e);
				t.bindTexture(3553, O.__webglTexture),
				U(3553, _e, Me),
				ae(F.__webglFramebuffer, _, _e, 36064 + se, 3553),
				I(_e, Me) && D(3553);
			}
			t.unbindTexture();
		} else {
			let T = 3553;
			(_.isWebGL3DRenderTarget || _.isWebGLArrayRenderTarget) &&
                (o
                	? (T = _.isWebGL3DRenderTarget ? 32879 : 35866)
                	: console.error(
                		'THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.'
                	)),
			t.bindTexture(T, Y.__webglTexture),
			U(T, y, Me),
			ae(F.__webglFramebuffer, _, y, 36064, T),
			I(y, Me) && D(T),
			t.unbindTexture();
		}
		_.depthBuffer && w(_);
	}
	function q(_) {
		const y = S(_) || o,
			F = _.isWebGLMultipleRenderTargets === !0 ? _.texture : [_.texture];
		for (let Y = 0, oe = F.length; Y < oe; Y++) {
			const pe = F[Y];
			if (I(pe, y)) {
				const Me = _.isWebGLCubeRenderTarget ? 34067 : 3553,
					T = i.get(pe).__webglTexture;
				t.bindTexture(Me, T), D(Me), t.unbindTexture();
			}
		}
	}
	function $(_) {
		if (o && _.samples > 0 && le(_) === !1) {
			const y = _.width,
				F = _.height;
			let Y = 16384;
			const oe = [36064],
				pe = _.stencilBuffer ? 33306 : 36096;
			_.depthBuffer && oe.push(pe);
			const Me = i.get(_),
				T =
                    Me.__ignoreDepthValues !== void 0
                    	? Me.__ignoreDepthValues
                    	: !1;
			T === !1 &&
                (_.depthBuffer && (Y |= 256), _.stencilBuffer && (Y |= 1024)),
			t.bindFramebuffer(36008, Me.__webglMultisampledFramebuffer),
			t.bindFramebuffer(36009, Me.__webglFramebuffer),
			T === !0 &&
                    (r.invalidateFramebuffer(36008, [pe]),
                    r.invalidateFramebuffer(36009, [pe])),
			r.blitFramebuffer(0, 0, y, F, 0, 0, y, F, Y, 9728),
			p && r.invalidateFramebuffer(36008, oe),
			t.bindFramebuffer(36008, null),
			t.bindFramebuffer(36009, Me.__webglMultisampledFramebuffer);
		}
	}
	function ne(_) {
		return Math.min(h, _.samples);
	}
	function le(_) {
		const y = i.get(_);
		return (
			o &&
            _.samples > 0 &&
            e.has('WEBGL_multisampled_render_to_texture') === !0 &&
            y.__useRenderToTexture !== !1
		);
	}
	function he(_) {
		const y = s.render.frame;
		g.get(_) !== y && (g.set(_, y), _.update());
	}
	function ge(_, y) {
		const F = _.encoding,
			Y = _.format,
			oe = _.type;
		return (
			_.isCompressedTexture === !0 ||
                _.isVideoTexture === !0 ||
                _.format === Vc ||
                (F !== Qr &&
                    (F === Ze
                    	? o === !1
                    		? e.has('EXT_sRGB') === !0 && Y === Qt
                    			? ((_.format = Vc),
                    			(_.minFilter = Nt),
                    			(_.generateMipmaps = !1))
                    			: (y = hn.sRGBToLinear(y))
                    		: (Y !== Qt || oe !== sn) &&
                              console.warn(
                              	'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.'
                              )
                    	: console.error(
                    		'THREE.WebGLTextures: Unsupported texture encoding:',
                    		F
                    	))),
			y
		);
	}
	(this.allocateTextureUnit = P),
	(this.resetTextureUnits = k),
	(this.setTexture2D = J),
	(this.setTexture2DArray = fe),
	(this.setTexture3D = ce),
	(this.setTextureCube = xe),
	(this.rebindTextures = R),
	(this.setupRenderTarget = N),
	(this.updateRenderTargetMipmap = q),
	(this.updateMultisampleRenderTarget = $),
	(this.setupDepthRenderbuffer = w),
	(this.setupFrameBufferTexture = ae),
	(this.useMultisampledRTT = le);
}
function ZM(r, e, t) {
	const i = t.isWebGL2;
	function n(a, s = null) {
		let o;
		if (a === sn) return 5121;
		if (a === Cx) return 32819;
		if (a === Px) return 32820;
		if (a === Lx) return 5120;
		if (a === Rx) return 5122;
		if (a === ms) return 5123;
		if (a === kx) return 5124;
		if (a === Eo) return 5125;
		if (a === wi) return 5126;
		if (a === ta)
			return i
				? 5131
				: ((o = e.get('OES_texture_half_float')),
				o !== null ? o.HALF_FLOAT_OES : null);
		if (a === Ix) return 6406;
		if (a === Qt) return 6408;
		if (a === Ox) return 6409;
		if (a === Nx) return 6410;
		if (a === rn) return 6402;
		if (a === la) return 34041;
		if (a === zx) return 6403;
		if (a === Dx)
			return (
				console.warn(
					'THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228'
				),
				6408
			);
		if (a === Vc)
			return (
				(o = e.get('EXT_sRGB')), o !== null ? o.SRGB_ALPHA_EXT : null
			);
		if (a === Ux) return 36244;
		if (a === Bx) return 33319;
		if (a === Fx) return 33320;
		if (a === Hx) return 36249;
		if (a === El || a === Al || a === Ll || a === Rl)
			if (s === Ze)
				if (
					((o = e.get('WEBGL_compressed_texture_s3tc_srgb')),
					o !== null)
				) {
					if (a === El) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
					if (a === Al) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
					if (a === Ll) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
					if (a === Rl) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
				} else return null;
			else if (
				((o = e.get('WEBGL_compressed_texture_s3tc')), o !== null)
			) {
				if (a === El) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if (a === Al) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if (a === Ll) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if (a === Rl) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
			} else return null;
		if (a === ud || a === hd || a === dd || a === pd)
			if (((o = e.get('WEBGL_compressed_texture_pvrtc')), o !== null)) {
				if (a === ud) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if (a === hd) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if (a === dd) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if (a === pd) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
			} else return null;
		if (a === Gx)
			return (
				(o = e.get('WEBGL_compressed_texture_etc1')),
				o !== null ? o.COMPRESSED_RGB_ETC1_WEBGL : null
			);
		if (a === md || a === fd)
			if (((o = e.get('WEBGL_compressed_texture_etc')), o !== null)) {
				if (a === md)
					return s === Ze
						? o.COMPRESSED_SRGB8_ETC2
						: o.COMPRESSED_RGB8_ETC2;
				if (a === fd)
					return s === Ze
						? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
						: o.COMPRESSED_RGBA8_ETC2_EAC;
			} else return null;
		if (
			a === gd ||
            a === vd ||
            a === yd ||
            a === xd ||
            a === bd ||
            a === wd ||
            a === _d ||
            a === Md ||
            a === Sd ||
            a === Td ||
            a === Ed ||
            a === Ad ||
            a === Ld ||
            a === Rd
		)
			if (((o = e.get('WEBGL_compressed_texture_astc')), o !== null)) {
				if (a === gd)
					return s === Ze
						? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
						: o.COMPRESSED_RGBA_ASTC_4x4_KHR;
				if (a === vd)
					return s === Ze
						? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
						: o.COMPRESSED_RGBA_ASTC_5x4_KHR;
				if (a === yd)
					return s === Ze
						? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
						: o.COMPRESSED_RGBA_ASTC_5x5_KHR;
				if (a === xd)
					return s === Ze
						? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
						: o.COMPRESSED_RGBA_ASTC_6x5_KHR;
				if (a === bd)
					return s === Ze
						? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
						: o.COMPRESSED_RGBA_ASTC_6x6_KHR;
				if (a === wd)
					return s === Ze
						? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
						: o.COMPRESSED_RGBA_ASTC_8x5_KHR;
				if (a === _d)
					return s === Ze
						? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
						: o.COMPRESSED_RGBA_ASTC_8x6_KHR;
				if (a === Md)
					return s === Ze
						? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
						: o.COMPRESSED_RGBA_ASTC_8x8_KHR;
				if (a === Sd)
					return s === Ze
						? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
						: o.COMPRESSED_RGBA_ASTC_10x5_KHR;
				if (a === Td)
					return s === Ze
						? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
						: o.COMPRESSED_RGBA_ASTC_10x6_KHR;
				if (a === Ed)
					return s === Ze
						? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
						: o.COMPRESSED_RGBA_ASTC_10x8_KHR;
				if (a === Ad)
					return s === Ze
						? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
						: o.COMPRESSED_RGBA_ASTC_10x10_KHR;
				if (a === Ld)
					return s === Ze
						? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
						: o.COMPRESSED_RGBA_ASTC_12x10_KHR;
				if (a === Rd)
					return s === Ze
						? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
						: o.COMPRESSED_RGBA_ASTC_12x12_KHR;
			} else return null;
		if (a === kd)
			if (((o = e.get('EXT_texture_compression_bptc')), o !== null)) {
				if (a === kd)
					return s === Ze
						? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
						: o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
			} else return null;
		if (a === ra)
			return i
				? 34042
				: ((o = e.get('WEBGL_depth_texture')),
				o !== null ? o.UNSIGNED_INT_24_8_WEBGL : null);
	}
	return { convert: n };
}
class Yf extends zt {
	constructor(e = []) {
		super(), (this.cameras = e);
	}
}
Yf.prototype.isArrayCamera = !0;
class _i extends Je {
	constructor() {
		super(), (this.type = 'Group');
	}
}
_i.prototype.isGroup = !0;
const $M = { type: 'move' };
class ic {
	constructor() {
		(this._targetRay = null), (this._grip = null), (this._hand = null);
	}
	getHandSpace() {
		return (
			this._hand === null &&
                ((this._hand = new _i()),
                (this._hand.matrixAutoUpdate = !1),
                (this._hand.visible = !1),
                (this._hand.joints = {}),
                (this._hand.inputState = { pinching: !1 })),
			this._hand
		);
	}
	getTargetRaySpace() {
		return (
			this._targetRay === null &&
                ((this._targetRay = new _i()),
                (this._targetRay.matrixAutoUpdate = !1),
                (this._targetRay.visible = !1),
                (this._targetRay.hasLinearVelocity = !1),
                (this._targetRay.linearVelocity = new C()),
                (this._targetRay.hasAngularVelocity = !1),
                (this._targetRay.angularVelocity = new C())),
			this._targetRay
		);
	}
	getGripSpace() {
		return (
			this._grip === null &&
                ((this._grip = new _i()),
                (this._grip.matrixAutoUpdate = !1),
                (this._grip.visible = !1),
                (this._grip.hasLinearVelocity = !1),
                (this._grip.linearVelocity = new C()),
                (this._grip.hasAngularVelocity = !1),
                (this._grip.angularVelocity = new C())),
			this._grip
		);
	}
	dispatchEvent(e) {
		return (
			this._targetRay !== null && this._targetRay.dispatchEvent(e),
			this._grip !== null && this._grip.dispatchEvent(e),
			this._hand !== null && this._hand.dispatchEvent(e),
			this
		);
	}
	disconnect(e) {
		return (
			this.dispatchEvent({ type: 'disconnected', data: e }),
			this._targetRay !== null && (this._targetRay.visible = !1),
			this._grip !== null && (this._grip.visible = !1),
			this._hand !== null && (this._hand.visible = !1),
			this
		);
	}
	update(e, t, i) {
		let n = null,
			a = null,
			s = null;
		const o = this._targetRay,
			l = this._grip,
			c = this._hand;
		if (e && t.session.visibilityState !== 'visible-blurred')
			if (
				(o !== null &&
                    ((n = t.getPose(e.targetRaySpace, i)),
                    n !== null &&
                        (o.matrix.fromArray(n.transform.matrix),
                        o.matrix.decompose(o.position, o.rotation, o.scale),
                        n.linearVelocity
                        	? ((o.hasLinearVelocity = !0),
                        	o.linearVelocity.copy(n.linearVelocity))
                        	: (o.hasLinearVelocity = !1),
                        n.angularVelocity
                        	? ((o.hasAngularVelocity = !0),
                        	o.angularVelocity.copy(n.angularVelocity))
                        	: (o.hasAngularVelocity = !1),
                        this.dispatchEvent($M))),
				c && e.hand)
			) {
				s = !0;
				for (const m of e.hand.values()) {
					const f = t.getJointPose(m, i);
					if (c.joints[m.jointName] === void 0) {
						const x = new _i();
						(x.matrixAutoUpdate = !1),
						(x.visible = !1),
						(c.joints[m.jointName] = x),
						c.add(x);
					}
					const v = c.joints[m.jointName];
					f !== null &&
                        (v.matrix.fromArray(f.transform.matrix),
                        v.matrix.decompose(v.position, v.rotation, v.scale),
                        (v.jointRadius = f.radius)),
					(v.visible = f !== null);
				}
				const u = c.joints['index-finger-tip'],
					h = c.joints['thumb-tip'],
					d = u.position.distanceTo(h.position),
					p = 0.02,
					g = 0.005;
				c.inputState.pinching && d > p + g
					? ((c.inputState.pinching = !1),
					this.dispatchEvent({
						type: 'pinchend',
						handedness: e.handedness,
						target: this
					}))
					: !c.inputState.pinching &&
                      d <= p - g &&
                      ((c.inputState.pinching = !0),
                      this.dispatchEvent({
                      	type: 'pinchstart',
                      	handedness: e.handedness,
                      	target: this
                      }));
			} else
				l !== null &&
                    e.gripSpace &&
                    ((a = t.getPose(e.gripSpace, i)),
                    a !== null &&
                        (l.matrix.fromArray(a.transform.matrix),
                        l.matrix.decompose(l.position, l.rotation, l.scale),
                        a.linearVelocity
                        	? ((l.hasLinearVelocity = !0),
                        	l.linearVelocity.copy(a.linearVelocity))
                        	: (l.hasLinearVelocity = !1),
                        a.angularVelocity
                        	? ((l.hasAngularVelocity = !0),
                        	l.angularVelocity.copy(a.angularVelocity))
                        	: (l.hasAngularVelocity = !1)));
		return (
			o !== null && (o.visible = n !== null),
			l !== null && (l.visible = a !== null),
			c !== null && (c.visible = s !== null),
			this
		);
	}
}
class Zf extends wt {
	constructor(e, t, i, n, a, s, o, l, c, u) {
		if (((u = u !== void 0 ? u : rn), u !== rn && u !== la))
			throw new Error(
				'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat'
			);
		i === void 0 && u === rn && (i = ms),
		i === void 0 && u === la && (i = ra),
		super(null, n, a, s, o, l, u, i, c),
		(this.image = { width: e, height: t }),
		(this.magFilter = o !== void 0 ? o : Mt),
		(this.minFilter = l !== void 0 ? l : Mt),
		(this.flipY = !1),
		(this.generateMipmaps = !1);
	}
}
Zf.prototype.isDepthTexture = !0;
class KM extends Di {
	constructor(e, t) {
		super();
		const i = this;
		let n = null,
			a = 1,
			s = null,
			o = 'local-floor',
			l = null,
			c = null,
			u = null,
			h = null,
			d = null;
		const p = t.getContextAttributes();
		let g = null,
			m = null;
		const f = [],
			v = new Map(),
			x = new zt();
		x.layers.enable(1), (x.viewport = new it());
		const A = new zt();
		A.layers.enable(2), (A.viewport = new it());
		const S = [x, A],
			M = new Yf();
		M.layers.enable(1), M.layers.enable(2);
		let I = null,
			D = null;
		(this.cameraAutoUpdate = !0),
		(this.enabled = !1),
		(this.isPresenting = !1),
		(this.getController = function (P) {
			let Z = f[P];
			return (
				Z === void 0 && ((Z = new ic()), (f[P] = Z)),
				Z.getTargetRaySpace()
			);
		}),
		(this.getControllerGrip = function (P) {
			let Z = f[P];
			return (
				Z === void 0 && ((Z = new ic()), (f[P] = Z)),
				Z.getGripSpace()
			);
		}),
		(this.getHand = function (P) {
			let Z = f[P];
			return (
				Z === void 0 && ((Z = new ic()), (f[P] = Z)),
				Z.getHandSpace()
			);
		});
		function G(P) {
			const Z = v.get(P.inputSource);
			Z && Z.dispatchEvent({ type: P.type, data: P.inputSource });
		}
		function re() {
			v.forEach(function (P, Z) {
				P.disconnect(Z);
			}),
			v.clear(),
			(I = null),
			(D = null),
			e.setRenderTarget(g),
			(h = null),
			(u = null),
			(c = null),
			(n = null),
			(m = null),
			k.stop(),
			(i.isPresenting = !1),
			i.dispatchEvent({ type: 'sessionend' });
		}
		(this.setFramebufferScaleFactor = function (P) {
			(a = P),
			i.isPresenting === !0 &&
                    console.warn(
                    	'THREE.WebXRManager: Cannot change framebuffer scale while presenting.'
                    );
		}),
		(this.setReferenceSpaceType = function (P) {
			(o = P),
			i.isPresenting === !0 &&
                        console.warn(
                        	'THREE.WebXRManager: Cannot change reference space type while presenting.'
                        );
		}),
		(this.getReferenceSpace = function () {
			return s;
		}),
		(this.getBaseLayer = function () {
			return u !== null ? u : h;
		}),
		(this.getBinding = function () {
			return c;
		}),
		(this.getFrame = function () {
			return d;
		}),
		(this.getSession = function () {
			return n;
		}),
		(this.setSession = async function (P) {
			if (((n = P), n !== null)) {
				if (
					((g = e.getRenderTarget()),
					n.addEventListener('select', G),
					n.addEventListener('selectstart', G),
					n.addEventListener('selectend', G),
					n.addEventListener('squeeze', G),
					n.addEventListener('squeezestart', G),
					n.addEventListener('squeezeend', G),
					n.addEventListener('end', re),
					n.addEventListener('inputsourceschange', B),
					p.xrCompatible !== !0 && (await t.makeXRCompatible()),
					n.renderState.layers === void 0 ||
                            e.capabilities.isWebGL2 === !1)
				) {
					const Z = {
						antialias:
                                n.renderState.layers === void 0
                                	? p.antialias
                                	: !0,
						alpha: p.alpha,
						depth: p.depth,
						stencil: p.stencil,
						framebufferScaleFactor: a
					};
					(h = new XRWebGLLayer(n, t, Z)),
					n.updateRenderState({ baseLayer: h }),
					(m = new Xt(
						h.framebufferWidth,
						h.framebufferHeight,
						{
							format: Qt,
							type: sn,
							encoding: e.outputEncoding
						}
					));
				} else {
					let Z = null,
						J = null,
						fe = null;
					p.depth &&
                            ((fe = p.stencil ? 35056 : 33190),
                            (Z = p.stencil ? la : rn),
                            (J = p.stencil ? ra : ms));
					const ce = {
						colorFormat:
                                e.outputEncoding === Ze ? 35907 : 32856,
						depthFormat: fe,
						scaleFactor: a
					};
					(c = new XRWebGLBinding(n, t)),
					(u = c.createProjectionLayer(ce)),
					n.updateRenderState({ layers: [u] }),
					(m = new Xt(u.textureWidth, u.textureHeight, {
						format: Qt,
						type: sn,
						depthTexture: new Zf(
							u.textureWidth,
							u.textureHeight,
							J,
							void 0,
							void 0,
							void 0,
							void 0,
							void 0,
							void 0,
							Z
						),
						stencilBuffer: p.stencil,
						encoding: e.outputEncoding,
						samples: p.antialias ? 4 : 0
					}));
					const xe = e.properties.get(m);
					xe.__ignoreDepthValues = u.ignoreDepthValues;
				}
				(m.isXRRenderTarget = !0),
				this.setFoveation(1),
				(s = await n.requestReferenceSpace(o)),
				k.setContext(n),
				k.start(),
				(i.isPresenting = !0),
				i.dispatchEvent({ type: 'sessionstart' });
			}
		});
		function B(P) {
			const Z = n.inputSources;
			for (let J = 0; J < f.length; J++) v.set(Z[J], f[J]);
			for (let J = 0; J < P.removed.length; J++) {
				const fe = P.removed[J],
					ce = v.get(fe);
				ce &&
                    (ce.dispatchEvent({ type: 'disconnected', data: fe }),
                    v.delete(fe));
			}
			for (let J = 0; J < P.added.length; J++) {
				const fe = P.added[J],
					ce = v.get(fe);
				ce && ce.dispatchEvent({ type: 'connected', data: fe });
			}
		}
		const b = new C(),
			E = new C();
		function j(P, Z, J) {
			b.setFromMatrixPosition(Z.matrixWorld),
			E.setFromMatrixPosition(J.matrixWorld);
			const fe = b.distanceTo(E),
				ce = Z.projectionMatrix.elements,
				xe = J.projectionMatrix.elements,
				W = ce[14] / (ce[10] - 1),
				ue = ce[14] / (ce[10] + 1),
				U = (ce[9] + 1) / ce[5],
				ve = (ce[9] - 1) / ce[5],
				Ae = (ce[8] - 1) / ce[0],
				Te = (xe[8] + 1) / xe[0],
				ae = W * Ae,
				K = W * Te,
				te = fe / (-Ae + Te),
				w = te * -Ae;
			Z.matrixWorld.decompose(P.position, P.quaternion, P.scale),
			P.translateX(w),
			P.translateZ(te),
			P.matrixWorld.compose(P.position, P.quaternion, P.scale),
			P.matrixWorldInverse.copy(P.matrixWorld).invert();
			const R = W + te,
				N = ue + te,
				q = ae - w,
				$ = K + (fe - w),
				ne = ((U * ue) / N) * R,
				le = ((ve * ue) / N) * R;
			P.projectionMatrix.makePerspective(q, $, ne, le, R, N);
		}
		function z(P, Z) {
			Z === null
				? P.matrixWorld.copy(P.matrix)
				: P.matrixWorld.multiplyMatrices(Z.matrixWorld, P.matrix),
			P.matrixWorldInverse.copy(P.matrixWorld).invert();
		}
		(this.updateCamera = function (P) {
			if (n === null) return;
			(M.near = A.near = x.near = P.near),
			(M.far = A.far = x.far = P.far),
			(I !== M.near || D !== M.far) &&
                    (n.updateRenderState({
                    	depthNear: M.near,
                    	depthFar: M.far
                    }),
                    (I = M.near),
                    (D = M.far));
			const Z = P.parent,
				J = M.cameras;
			z(M, Z);
			for (let ce = 0; ce < J.length; ce++) z(J[ce], Z);
			M.matrixWorld.decompose(M.position, M.quaternion, M.scale),
			P.position.copy(M.position),
			P.quaternion.copy(M.quaternion),
			P.scale.copy(M.scale),
			P.matrix.copy(M.matrix),
			P.matrixWorld.copy(M.matrixWorld);
			const fe = P.children;
			for (let ce = 0, xe = fe.length; ce < xe; ce++)
				fe[ce].updateMatrixWorld(!0);
			J.length === 2
				? j(M, x, A)
				: M.projectionMatrix.copy(x.projectionMatrix);
		}),
		(this.getCamera = function () {
			return M;
		}),
		(this.getFoveation = function () {
			if (u !== null) return u.fixedFoveation;
			if (h !== null) return h.fixedFoveation;
		}),
		(this.setFoveation = function (P) {
			u !== null && (u.fixedFoveation = P),
			h !== null &&
                        h.fixedFoveation !== void 0 &&
                        (h.fixedFoveation = P);
		});
		let V = null;
		function H(P, Z) {
			if (((l = Z.getViewerPose(s)), (d = Z), l !== null)) {
				const fe = l.views;
				h !== null &&
                    (e.setRenderTargetFramebuffer(m, h.framebuffer),
                    e.setRenderTarget(m));
				let ce = !1;
				fe.length !== M.cameras.length &&
                    ((M.cameras.length = 0), (ce = !0));
				for (let xe = 0; xe < fe.length; xe++) {
					const W = fe[xe];
					let ue = null;
					if (h !== null) ue = h.getViewport(W);
					else {
						const ve = c.getViewSubImage(u, W);
						(ue = ve.viewport),
						xe === 0 &&
                                (e.setRenderTargetTextures(
                                	m,
                                	ve.colorTexture,
                                	u.ignoreDepthValues
                                		? void 0
                                		: ve.depthStencilTexture
                                ),
                                e.setRenderTarget(m));
					}
					const U = S[xe];
					U.matrix.fromArray(W.transform.matrix),
					U.projectionMatrix.fromArray(W.projectionMatrix),
					U.viewport.set(ue.x, ue.y, ue.width, ue.height),
					xe === 0 && M.matrix.copy(U.matrix),
					ce === !0 && M.cameras.push(U);
				}
			}
			const J = n.inputSources;
			for (let fe = 0; fe < f.length; fe++) {
				const ce = f[fe],
					xe = J[fe];
				ce.update(xe, Z, s);
			}
			V && V(P, Z), (d = null);
		}
		const k = new Bf();
		k.setAnimationLoop(H),
		(this.setAnimationLoop = function (P) {
			V = P;
		}),
		(this.dispose = function () {});
	}
}
function JM(r, e) {
	function t(m, f) {
		m.fogColor.value.copy(f.color),
		f.isFog
			? ((m.fogNear.value = f.near), (m.fogFar.value = f.far))
			: f.isFogExp2 && (m.fogDensity.value = f.density);
	}
	function i(m, f, v, x, A) {
		f.isMeshBasicMaterial || f.isMeshLambertMaterial
			? n(m, f)
			: f.isMeshToonMaterial
				? (n(m, f), u(m, f))
				: f.isMeshPhongMaterial
					? (n(m, f), c(m, f))
					: f.isMeshStandardMaterial
						? (n(m, f), h(m, f), f.isMeshPhysicalMaterial && d(m, f, A))
						: f.isMeshMatcapMaterial
							? (n(m, f), p(m, f))
							: f.isMeshDepthMaterial
								? n(m, f)
								: f.isMeshDistanceMaterial
									? (n(m, f), g(m, f))
									: f.isMeshNormalMaterial
										? n(m, f)
										: f.isLineBasicMaterial
											? (a(m, f), f.isLineDashedMaterial && s(m, f))
											: f.isPointsMaterial
												? o(m, f, v, x)
												: f.isSpriteMaterial
													? l(m, f)
													: f.isShadowMaterial
														? (m.color.value.copy(f.color), (m.opacity.value = f.opacity))
														: f.isShaderMaterial && (f.uniformsNeedUpdate = !1);
	}
	function n(m, f) {
		(m.opacity.value = f.opacity),
		f.color && m.diffuse.value.copy(f.color),
		f.emissive &&
                m.emissive.value
                	.copy(f.emissive)
                	.multiplyScalar(f.emissiveIntensity),
		f.map && (m.map.value = f.map),
		f.alphaMap && (m.alphaMap.value = f.alphaMap),
		f.bumpMap &&
                ((m.bumpMap.value = f.bumpMap),
                (m.bumpScale.value = f.bumpScale),
                f.side === rr && (m.bumpScale.value *= -1)),
		f.displacementMap &&
                ((m.displacementMap.value = f.displacementMap),
                (m.displacementScale.value = f.displacementScale),
                (m.displacementBias.value = f.displacementBias)),
		f.emissiveMap && (m.emissiveMap.value = f.emissiveMap),
		f.normalMap &&
                ((m.normalMap.value = f.normalMap),
                m.normalScale.value.copy(f.normalScale),
                f.side === rr && m.normalScale.value.negate()),
		f.specularMap && (m.specularMap.value = f.specularMap),
		f.alphaTest > 0 && (m.alphaTest.value = f.alphaTest);
		const v = e.get(f).envMap;
		if (
			(v &&
                ((m.envMap.value = v),
                (m.flipEnvMap.value =
                    v.isCubeTexture && v.isRenderTargetTexture === !1 ? -1 : 1),
                (m.reflectivity.value = f.reflectivity),
                (m.ior.value = f.ior),
                (m.refractionRatio.value = f.refractionRatio)),
			f.lightMap)
		) {
			m.lightMap.value = f.lightMap;
			const S = r.physicallyCorrectLights !== !0 ? Math.PI : 1;
			m.lightMapIntensity.value = f.lightMapIntensity * S;
		}
		f.aoMap &&
            ((m.aoMap.value = f.aoMap),
            (m.aoMapIntensity.value = f.aoMapIntensity));
		let x;
		f.map
			? (x = f.map)
			: f.specularMap
				? (x = f.specularMap)
				: f.displacementMap
					? (x = f.displacementMap)
					: f.normalMap
						? (x = f.normalMap)
						: f.bumpMap
							? (x = f.bumpMap)
							: f.roughnessMap
								? (x = f.roughnessMap)
								: f.metalnessMap
									? (x = f.metalnessMap)
									: f.alphaMap
										? (x = f.alphaMap)
										: f.emissiveMap
											? (x = f.emissiveMap)
											: f.clearcoatMap
												? (x = f.clearcoatMap)
												: f.clearcoatNormalMap
													? (x = f.clearcoatNormalMap)
													: f.clearcoatRoughnessMap
														? (x = f.clearcoatRoughnessMap)
														: f.specularIntensityMap
															? (x = f.specularIntensityMap)
															: f.specularColorMap
																? (x = f.specularColorMap)
																: f.transmissionMap
																	? (x = f.transmissionMap)
																	: f.thicknessMap
																		? (x = f.thicknessMap)
																		: f.sheenColorMap
																			? (x = f.sheenColorMap)
																			: f.sheenRoughnessMap && (x = f.sheenRoughnessMap),
		x !== void 0 &&
                (x.isWebGLRenderTarget && (x = x.texture),
                x.matrixAutoUpdate === !0 && x.updateMatrix(),
                m.uvTransform.value.copy(x.matrix));
		let A;
		f.aoMap ? (A = f.aoMap) : f.lightMap && (A = f.lightMap),
		A !== void 0 &&
                (A.isWebGLRenderTarget && (A = A.texture),
                A.matrixAutoUpdate === !0 && A.updateMatrix(),
                m.uv2Transform.value.copy(A.matrix));
	}
	function a(m, f) {
		m.diffuse.value.copy(f.color), (m.opacity.value = f.opacity);
	}
	function s(m, f) {
		(m.dashSize.value = f.dashSize),
		(m.totalSize.value = f.dashSize + f.gapSize),
		(m.scale.value = f.scale);
	}
	function o(m, f, v, x) {
		m.diffuse.value.copy(f.color),
		(m.opacity.value = f.opacity),
		(m.size.value = f.size * v),
		(m.scale.value = x * 0.5),
		f.map && (m.map.value = f.map),
		f.alphaMap && (m.alphaMap.value = f.alphaMap),
		f.alphaTest > 0 && (m.alphaTest.value = f.alphaTest);
		let A;
		f.map ? (A = f.map) : f.alphaMap && (A = f.alphaMap),
		A !== void 0 &&
                (A.matrixAutoUpdate === !0 && A.updateMatrix(),
                m.uvTransform.value.copy(A.matrix));
	}
	function l(m, f) {
		m.diffuse.value.copy(f.color),
		(m.opacity.value = f.opacity),
		(m.rotation.value = f.rotation),
		f.map && (m.map.value = f.map),
		f.alphaMap && (m.alphaMap.value = f.alphaMap),
		f.alphaTest > 0 && (m.alphaTest.value = f.alphaTest);
		let v;
		f.map ? (v = f.map) : f.alphaMap && (v = f.alphaMap),
		v !== void 0 &&
                (v.matrixAutoUpdate === !0 && v.updateMatrix(),
                m.uvTransform.value.copy(v.matrix));
	}
	function c(m, f) {
		m.specular.value.copy(f.specular),
		(m.shininess.value = Math.max(f.shininess, 1e-4));
	}
	function u(m, f) {
		f.gradientMap && (m.gradientMap.value = f.gradientMap);
	}
	function h(m, f) {
		(m.roughness.value = f.roughness),
		(m.metalness.value = f.metalness),
		f.roughnessMap && (m.roughnessMap.value = f.roughnessMap),
		f.metalnessMap && (m.metalnessMap.value = f.metalnessMap),
		e.get(f).envMap && (m.envMapIntensity.value = f.envMapIntensity);
	}
	function d(m, f, v) {
		(m.ior.value = f.ior),
		f.sheen > 0 &&
                (m.sheenColor.value.copy(f.sheenColor).multiplyScalar(f.sheen),
                (m.sheenRoughness.value = f.sheenRoughness),
                f.sheenColorMap && (m.sheenColorMap.value = f.sheenColorMap),
                f.sheenRoughnessMap &&
                    (m.sheenRoughnessMap.value = f.sheenRoughnessMap)),
		f.clearcoat > 0 &&
                ((m.clearcoat.value = f.clearcoat),
                (m.clearcoatRoughness.value = f.clearcoatRoughness),
                f.clearcoatMap && (m.clearcoatMap.value = f.clearcoatMap),
                f.clearcoatRoughnessMap &&
                    (m.clearcoatRoughnessMap.value = f.clearcoatRoughnessMap),
                f.clearcoatNormalMap &&
                    (m.clearcoatNormalScale.value.copy(f.clearcoatNormalScale),
                    (m.clearcoatNormalMap.value = f.clearcoatNormalMap),
                    f.side === rr && m.clearcoatNormalScale.value.negate())),
		f.transmission > 0 &&
                ((m.transmission.value = f.transmission),
                (m.transmissionSamplerMap.value = v.texture),
                m.transmissionSamplerSize.value.set(v.width, v.height),
                f.transmissionMap &&
                    (m.transmissionMap.value = f.transmissionMap),
                (m.thickness.value = f.thickness),
                f.thicknessMap && (m.thicknessMap.value = f.thicknessMap),
                (m.attenuationDistance.value = f.attenuationDistance),
                m.attenuationColor.value.copy(f.attenuationColor)),
		(m.specularIntensity.value = f.specularIntensity),
		m.specularColor.value.copy(f.specularColor),
		f.specularIntensityMap &&
                (m.specularIntensityMap.value = f.specularIntensityMap),
		f.specularColorMap &&
                (m.specularColorMap.value = f.specularColorMap);
	}
	function p(m, f) {
		f.matcap && (m.matcap.value = f.matcap);
	}
	function g(m, f) {
		m.referencePosition.value.copy(f.referencePosition),
		(m.nearDistance.value = f.nearDistance),
		(m.farDistance.value = f.farDistance);
	}
	return { refreshFogUniforms: t, refreshMaterialUniforms: i };
}
function QM() {
	const r = ys('canvas');
	return (r.style.display = 'block'), r;
}
function tt(r = {}) {
	const e = r.canvas !== void 0 ? r.canvas : QM(),
		t = r.context !== void 0 ? r.context : null,
		i = r.depth !== void 0 ? r.depth : !0,
		n = r.stencil !== void 0 ? r.stencil : !0,
		a = r.antialias !== void 0 ? r.antialias : !1,
		s = r.premultipliedAlpha !== void 0 ? r.premultipliedAlpha : !0,
		o = r.preserveDrawingBuffer !== void 0 ? r.preserveDrawingBuffer : !1,
		l = r.powerPreference !== void 0 ? r.powerPreference : 'default',
		c =
            r.failIfMajorPerformanceCaveat !== void 0
            	? r.failIfMajorPerformanceCaveat
            	: !1;
	let u;
	r.context !== void 0
		? (u = t.getContextAttributes().alpha)
		: (u = r.alpha !== void 0 ? r.alpha : !1);
	let h = null,
		d = null;
	const p = [],
		g = [];
	(this.domElement = e),
	(this.debug = { checkShaderErrors: !0 }),
	(this.autoClear = !0),
	(this.autoClearColor = !0),
	(this.autoClearDepth = !0),
	(this.autoClearStencil = !0),
	(this.sortObjects = !0),
	(this.clippingPlanes = []),
	(this.localClippingEnabled = !1),
	(this.outputEncoding = Qr),
	(this.physicallyCorrectLights = !1),
	(this.toneMapping = $r),
	(this.toneMappingExposure = 1);
	const m = this;
	let f = !1,
		v = 0,
		x = 0,
		A = null,
		S = -1,
		M = null;
	const I = new it(),
		D = new it();
	let G = null,
		re = e.width,
		B = e.height,
		b = 1,
		E = null,
		j = null;
	const z = new it(0, 0, re, B),
		V = new it(0, 0, re, B);
	let H = !1;
	const k = new al();
	let P = !1,
		Z = !1,
		J = null;
	const fe = new Pe(),
		ce = new me(),
		xe = new C(),
		W = {
			background: null,
			fog: null,
			environment: null,
			overrideMaterial: null,
			isScene: !0
		};
	function ue() {
		return A === null ? b : 1;
	}
	let U = t;
	function ve(L, X) {
		for (let ie = 0; ie < L.length; ie++) {
			const Q = L[ie],
				de = e.getContext(Q, X);
			if (de !== null) return de;
		}
		return null;
	}
	try {
		const L = {
			alpha: !0,
			depth: i,
			stencil: n,
			antialias: a,
			premultipliedAlpha: s,
			preserveDrawingBuffer: o,
			powerPreference: l,
			failIfMajorPerformanceCaveat: c
		};
		if (
			('setAttribute' in e &&
                e.setAttribute('data-engine', `three.js r${Ru}`),
			e.addEventListener('webglcontextlost', O, !1),
			e.addEventListener('webglcontextrestored', ye, !1),
			U === null)
		) {
			const X = ['webgl2', 'webgl', 'experimental-webgl'];
			if (
				(m.isWebGL1Renderer === !0 && X.shift(),
				(U = ve(X, L)),
				U === null)
			)
				throw ve(X)
					? new Error(
						'Error creating WebGL context with your selected attributes.'
					)
					: new Error('Error creating WebGL context.');
		}
		U.getShaderPrecisionFormat === void 0 &&
            (U.getShaderPrecisionFormat = function () {
            	return { rangeMin: 1, rangeMax: 1, precision: 1 };
            });
	} catch (L) {
		throw (console.error('THREE.WebGLRenderer: ' + L.message), L);
	}
	let Ae,
		Te,
		ae,
		K,
		te,
		w,
		R,
		N,
		q,
		$,
		ne,
		le,
		he,
		ge,
		_,
		y,
		F,
		Y,
		oe,
		pe,
		Me,
		T,
		se;
	function Re() {
		(Ae = new v_(U)),
		(Te = new h_(U, Ae, r)),
		Ae.init(Te),
		(T = new ZM(U, Ae, Te)),
		(ae = new qM(U, Ae, Te)),
		(K = new b_()),
		(te = new NM()),
		(w = new YM(U, Ae, ae, te, Te, T, K)),
		(R = new p_(m)),
		(N = new g_(m)),
		(q = new Db(U, Te)),
		(se = new c_(U, Ae, q, Te)),
		($ = new y_(U, q, K, se)),
		(ne = new S_(U, $, q, K)),
		(oe = new M_(U, Te, w)),
		(y = new d_(te)),
		(le = new OM(m, R, N, Ae, Te, se, y)),
		(he = new JM(m, te)),
		(ge = new UM()),
		(_ = new WM(Ae, Te)),
		(Y = new l_(m, R, ae, ne, u, s)),
		(F = new qf(m, ne, Te)),
		(pe = new u_(U, Ae, K, Te)),
		(Me = new x_(U, Ae, K, Te)),
		(K.programs = le.programs),
		(m.capabilities = Te),
		(m.extensions = Ae),
		(m.properties = te),
		(m.renderLists = ge),
		(m.shadowMap = F),
		(m.state = ae),
		(m.info = K);
	}
	Re();
	const _e = new KM(m, U);
	(this.xr = _e),
	(this.getContext = function () {
		return U;
	}),
	(this.getContextAttributes = function () {
		return U.getContextAttributes();
	}),
	(this.forceContextLoss = function () {
		const L = Ae.get('WEBGL_lose_context');
		L && L.loseContext();
	}),
	(this.forceContextRestore = function () {
		const L = Ae.get('WEBGL_lose_context');
		L && L.restoreContext();
	}),
	(this.getPixelRatio = function () {
		return b;
	}),
	(this.setPixelRatio = function (L) {
		L !== void 0 && ((b = L), this.setSize(re, B, !1));
	}),
	(this.getSize = function (L) {
		return L.set(re, B);
	}),
	(this.setSize = function (L, X, ie) {
		if (_e.isPresenting) {
			console.warn(
				'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.'
			);
			return;
		}
		(re = L),
		(B = X),
		(e.width = Math.floor(L * b)),
		(e.height = Math.floor(X * b)),
		ie !== !1 &&
                    ((e.style.width = L + 'px'), (e.style.height = X + 'px')),
		this.setViewport(0, 0, L, X);
	}),
	(this.getDrawingBufferSize = function (L) {
		return L.set(re * b, B * b).floor();
	}),
	(this.setDrawingBufferSize = function (L, X, ie) {
		(re = L),
		(B = X),
		(b = ie),
		(e.width = Math.floor(L * ie)),
		(e.height = Math.floor(X * ie)),
		this.setViewport(0, 0, L, X);
	}),
	(this.getCurrentViewport = function (L) {
		return L.copy(I);
	}),
	(this.getViewport = function (L) {
		return L.copy(z);
	}),
	(this.setViewport = function (L, X, ie, Q) {
		L.isVector4 ? z.set(L.x, L.y, L.z, L.w) : z.set(L, X, ie, Q),
		ae.viewport(I.copy(z).multiplyScalar(b).floor());
	}),
	(this.getScissor = function (L) {
		return L.copy(V);
	}),
	(this.setScissor = function (L, X, ie, Q) {
		L.isVector4 ? V.set(L.x, L.y, L.z, L.w) : V.set(L, X, ie, Q),
		ae.scissor(D.copy(V).multiplyScalar(b).floor());
	}),
	(this.getScissorTest = function () {
		return H;
	}),
	(this.setScissorTest = function (L) {
		ae.setScissorTest((H = L));
	}),
	(this.setOpaqueSort = function (L) {
		E = L;
	}),
	(this.setTransparentSort = function (L) {
		j = L;
	}),
	(this.getClearColor = function (L) {
		return L.copy(Y.getClearColor());
	}),
	(this.setClearColor = function () {
		Y.setClearColor.apply(Y, arguments);
	}),
	(this.getClearAlpha = function () {
		return Y.getClearAlpha();
	}),
	(this.setClearAlpha = function () {
		Y.setClearAlpha.apply(Y, arguments);
	}),
	(this.clear = function (L = !0, X = !0, ie = !0) {
		let Q = 0;
		L && (Q |= 16384), X && (Q |= 256), ie && (Q |= 1024), U.clear(Q);
	}),
	(this.clearColor = function () {
		this.clear(!0, !1, !1);
	}),
	(this.clearDepth = function () {
		this.clear(!1, !0, !1);
	}),
	(this.clearStencil = function () {
		this.clear(!1, !1, !0);
	}),
	(this.dispose = function () {
		e.removeEventListener('webglcontextlost', O, !1),
		e.removeEventListener('webglcontextrestored', ye, !1),
		ge.dispose(),
		_.dispose(),
		te.dispose(),
		R.dispose(),
		N.dispose(),
		ne.dispose(),
		se.dispose(),
		le.dispose(),
		_e.dispose(),
		_e.removeEventListener('sessionstart', Ue),
		_e.removeEventListener('sessionend', $e),
		J && (J.dispose(), (J = null)),
		nt.stop();
	});
	function O(L) {
		L.preventDefault(),
		console.log('THREE.WebGLRenderer: Context Lost.'),
		(f = !0);
	}
	function ye() {
		console.log('THREE.WebGLRenderer: Context Restored.'), (f = !1);
		const L = K.autoReset,
			X = F.enabled,
			ie = F.autoUpdate,
			Q = F.needsUpdate,
			de = F.type;
		Re(),
		(K.autoReset = L),
		(F.enabled = X),
		(F.autoUpdate = ie),
		(F.needsUpdate = Q),
		(F.type = de);
	}
	function we(L) {
		const X = L.target;
		X.removeEventListener('dispose', we), Le(X);
	}
	function Le(L) {
		be(L), te.remove(L);
	}
	function be(L) {
		const X = te.get(L).programs;
		X !== void 0 &&
            (X.forEach(function (ie) {
            	le.releaseProgram(ie);
            }),
            L.isShaderMaterial && le.releaseShaderCache(L));
	}
	(this.renderBufferDirect = function (L, X, ie, Q, de, De) {
		X === null && (X = W);
		const Be = de.isMesh && de.matrixWorld.determinant() < 0,
			Fe = y0(L, X, ie, Q, de);
		ae.setMaterial(Q, Be);
		let je = ie.index;
		const ht = ie.attributes.position;
		if (je === null) {
			if (ht === void 0 || ht.count === 0) return;
		} else if (je.count === 0) return;
		let Xe = 1;
		Q.wireframe === !0 && ((je = $.getWireframeAttribute(ie)), (Xe = 2)),
		se.setup(de, Q, Fe, ie, je);
		let Ye,
			St = pe;
		je !== null && ((Ye = q.get(je)), (St = Me), St.setIndex(Ye));
		const zi = je !== null ? je.count : ht.count,
			fn = ie.drawRange.start * Xe,
			gn = ie.drawRange.count * Xe,
			Mr = De !== null ? De.start * Xe : 0,
			Qe = De !== null ? De.count * Xe : 1 / 0,
			vn = Math.max(fn, Mr),
			Ra = Math.min(zi, fn + gn, Mr + Qe) - 1,
			Sr = Math.max(0, Ra - vn + 1);
		if (Sr !== 0) {
			if (de.isMesh)
				Q.wireframe === !0
					? (ae.setLineWidth(Q.wireframeLinewidth * ue()),
					St.setMode(1))
					: St.setMode(4);
			else if (de.isLine) {
				let ii = Q.linewidth;
				ii === void 0 && (ii = 1),
				ae.setLineWidth(ii * ue()),
				de.isLineSegments
					? St.setMode(1)
					: de.isLineLoop
						? St.setMode(2)
						: St.setMode(3);
			} else de.isPoints ? St.setMode(0) : de.isSprite && St.setMode(4);
			if (de.isInstancedMesh) St.renderInstances(vn, Sr, de.count);
			else if (ie.isInstancedBufferGeometry) {
				const ii = Math.min(ie.instanceCount, ie._maxInstanceCount);
				St.renderInstances(vn, Sr, ii);
			} else St.render(vn, Sr);
		}
	}),
	(this.compile = function (L, X) {
		(d = _.get(L)),
		d.init(),
		g.push(d),
		L.traverseVisible(function (ie) {
			ie.isLight &&
                        ie.layers.test(X.layers) &&
                        (d.pushLight(ie), ie.castShadow && d.pushShadow(ie));
		}),
		d.setupLights(m.physicallyCorrectLights),
		L.traverse(function (ie) {
			const Q = ie.material;
			if (Q)
				if (Array.isArray(Q))
					for (let de = 0; de < Q.length; de++) {
						const De = Q[de];
						yl(De, L, ie);
					}
				else yl(Q, L, ie);
		}),
		g.pop(),
		(d = null);
	});
	let Ne = null;
	function Se(L) {
		Ne && Ne(L);
	}
	function Ue() {
		nt.stop();
	}
	function $e() {
		nt.start();
	}
	const nt = new Bf();
	nt.setAnimationLoop(Se),
	typeof self != 'undefined' && nt.setContext(self),
	(this.setAnimationLoop = function (L) {
		(Ne = L),
		_e.setAnimationLoop(L),
		L === null ? nt.stop() : nt.start();
	}),
	_e.addEventListener('sessionstart', Ue),
	_e.addEventListener('sessionend', $e),
	(this.render = function (L, X) {
		if (X !== void 0 && X.isCamera !== !0) {
			console.error(
				'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.'
			);
			return;
		}
		if (f === !0) return;
		L.autoUpdate === !0 && L.updateMatrixWorld(),
		X.parent === null && X.updateMatrixWorld(),
		_e.enabled === !0 &&
                    _e.isPresenting === !0 &&
                    (_e.cameraAutoUpdate === !0 && _e.updateCamera(X),
                    (X = _e.getCamera())),
		L.isScene === !0 && L.onBeforeRender(m, L, X, A),
		(d = _.get(L, g.length)),
		d.init(),
		g.push(d),
		fe.multiplyMatrices(X.projectionMatrix, X.matrixWorldInverse),
		k.setFromProjectionMatrix(fe),
		(Z = this.localClippingEnabled),
		(P = y.init(this.clippingPlanes, Z, X)),
		(h = ge.get(L, p.length)),
		h.init(),
		p.push(h),
		wr(L, X, 0, m.sortObjects),
		h.finish(),
		m.sortObjects === !0 && h.sort(E, j),
		P === !0 && y.beginShadows();
		const ie = d.state.shadowsArray;
		if (
			(F.render(ie, L, X),
			P === !0 && y.endShadows(),
			this.info.autoReset === !0 && this.info.reset(),
			Y.render(h, L),
			d.setupLights(m.physicallyCorrectLights),
			X.isArrayCamera)
		) {
			const Q = X.cameras;
			for (let de = 0, De = Q.length; de < De; de++) {
				const Be = Q[de];
				_r(h, L, Be, Be.viewport);
			}
		} else _r(h, L, X);
		A !== null &&
                (w.updateMultisampleRenderTarget(A),
                w.updateRenderTargetMipmap(A)),
		L.isScene === !0 && L.onAfterRender(m, L, X),
		se.resetDefaultState(),
		(S = -1),
		(M = null),
		g.pop(),
		g.length > 0 ? (d = g[g.length - 1]) : (d = null),
		p.pop(),
		p.length > 0 ? (h = p[p.length - 1]) : (h = null);
	});
	function wr(L, X, ie, Q) {
		if (L.visible === !1) return;
		if (L.layers.test(X.layers)) {
			if (L.isGroup) ie = L.renderOrder;
			else if (L.isLOD) L.autoUpdate === !0 && L.update(X);
			else if (L.isLight) d.pushLight(L), L.castShadow && d.pushShadow(L);
			else if (L.isSprite) {
				if (!L.frustumCulled || k.intersectsSprite(L)) {
					Q &&
                        xe
                        	.setFromMatrixPosition(L.matrixWorld)
                        	.applyMatrix4(fe);
					const De = ne.update(L),
						Be = L.material;
					Be.visible && h.push(L, De, Be, ie, xe.z, null);
				}
			} else if (
				(L.isMesh || L.isLine || L.isPoints) &&
                (L.isSkinnedMesh &&
                    L.skeleton.frame !== K.render.frame &&
                    (L.skeleton.update(), (L.skeleton.frame = K.render.frame)),
                !L.frustumCulled || k.intersectsObject(L))
			) {
				Q && xe.setFromMatrixPosition(L.matrixWorld).applyMatrix4(fe);
				const De = ne.update(L),
					Be = L.material;
				if (Array.isArray(Be)) {
					const Fe = De.groups;
					for (let je = 0, ht = Fe.length; je < ht; je++) {
						const Xe = Fe[je],
							Ye = Be[Xe.materialIndex];
						Ye && Ye.visible && h.push(L, De, Ye, ie, xe.z, Xe);
					}
				} else Be.visible && h.push(L, De, Be, ie, xe.z, null);
			}
		}
		const de = L.children;
		for (let De = 0, Be = de.length; De < Be; De++) wr(de[De], X, ie, Q);
	}
	function _r(L, X, ie, Q) {
		const de = L.opaque,
			De = L.transmissive,
			Be = L.transparent;
		d.setupLightsView(ie),
		De.length > 0 && g0(de, X, ie),
		Q && ae.viewport(I.copy(Q)),
		de.length > 0 && Cs(de, X, ie),
		De.length > 0 && Cs(De, X, ie),
		Be.length > 0 && Cs(Be, X, ie),
		ae.buffers.depth.setTest(!0),
		ae.buffers.depth.setMask(!0),
		ae.buffers.color.setMask(!0),
		ae.setPolygonOffset(!1);
	}
	function g0(L, X, ie) {
		const Q = Te.isWebGL2;
		J === null &&
            (J = new Xt(1, 1, {
            	generateMipmaps: !0,
            	type: T.convert(ta) !== null ? ta : sn,
            	minFilter: ba,
            	samples: Q && a === !0 ? 4 : 0
            })),
		m.getDrawingBufferSize(ce),
		Q ? J.setSize(ce.x, ce.y) : J.setSize(Uo(ce.x), Uo(ce.y));
		const de = m.getRenderTarget();
		m.setRenderTarget(J), m.clear();
		const De = m.toneMapping;
		(m.toneMapping = $r),
		Cs(L, X, ie),
		(m.toneMapping = De),
		w.updateMultisampleRenderTarget(J),
		w.updateRenderTargetMipmap(J),
		m.setRenderTarget(de);
	}
	function Cs(L, X, ie) {
		const Q = X.isScene === !0 ? X.overrideMaterial : null;
		for (let de = 0, De = L.length; de < De; de++) {
			const Be = L[de],
				Fe = Be.object,
				je = Be.geometry,
				ht = Q === null ? Be.material : Q,
				Xe = Be.group;
			Fe.layers.test(ie.layers) && v0(Fe, X, ie, je, ht, Xe);
		}
	}
	function v0(L, X, ie, Q, de, De) {
		L.onBeforeRender(m, X, ie, Q, de, De),
		L.modelViewMatrix.multiplyMatrices(
			ie.matrixWorldInverse,
			L.matrixWorld
		),
		L.normalMatrix.getNormalMatrix(L.modelViewMatrix),
		de.onBeforeRender(m, X, ie, Q, L, De),
		de.transparent === !0 && de.side === an
			? ((de.side = rr),
			(de.needsUpdate = !0),
			m.renderBufferDirect(ie, X, Q, de, L, De),
			(de.side = na),
			(de.needsUpdate = !0),
			m.renderBufferDirect(ie, X, Q, de, L, De),
			(de.side = an))
			: m.renderBufferDirect(ie, X, Q, de, L, De),
		L.onAfterRender(m, X, ie, Q, de, De);
	}
	function yl(L, X, ie) {
		X.isScene !== !0 && (X = W);
		const Q = te.get(L),
			de = d.state.lights,
			De = d.state.shadowsArray,
			Be = de.state.version,
			Fe = le.getParameters(L, de.state, De, X, ie),
			je = le.getProgramCacheKey(Fe);
		let ht = Q.programs;
		(Q.environment = L.isMeshStandardMaterial ? X.environment : null),
		(Q.fog = X.fog),
		(Q.envMap = (L.isMeshStandardMaterial ? N : R).get(
			L.envMap || Q.environment
		)),
		ht === void 0 &&
                (L.addEventListener('dispose', we),
                (ht = new Map()),
                (Q.programs = ht));
		let Xe = ht.get(je);
		if (Xe !== void 0) {
			if (Q.currentProgram === Xe && Q.lightsStateVersion === Be)
				return yh(L, Fe), Xe;
		} else
			(Fe.uniforms = le.getUniforms(L)),
			L.onBuild(ie, Fe, m),
			L.onBeforeCompile(Fe, m),
			(Xe = le.acquireProgram(Fe, je)),
			ht.set(je, Xe),
			(Q.uniforms = Fe.uniforms);
		const Ye = Q.uniforms;
		((!L.isShaderMaterial && !L.isRawShaderMaterial) ||
            L.clipping === !0) &&
            (Ye.clippingPlanes = y.uniform),
		yh(L, Fe),
		(Q.needsLights = b0(L)),
		(Q.lightsStateVersion = Be),
		Q.needsLights &&
                ((Ye.ambientLightColor.value = de.state.ambient),
                (Ye.lightProbe.value = de.state.probe),
                (Ye.directionalLights.value = de.state.directional),
                (Ye.directionalLightShadows.value = de.state.directionalShadow),
                (Ye.spotLights.value = de.state.spot),
                (Ye.spotLightShadows.value = de.state.spotShadow),
                (Ye.rectAreaLights.value = de.state.rectArea),
                (Ye.ltc_1.value = de.state.rectAreaLTC1),
                (Ye.ltc_2.value = de.state.rectAreaLTC2),
                (Ye.pointLights.value = de.state.point),
                (Ye.pointLightShadows.value = de.state.pointShadow),
                (Ye.hemisphereLights.value = de.state.hemi),
                (Ye.directionalShadowMap.value = de.state.directionalShadowMap),
                (Ye.directionalShadowMatrix.value =
                    de.state.directionalShadowMatrix),
                (Ye.spotShadowMap.value = de.state.spotShadowMap),
                (Ye.spotShadowMatrix.value = de.state.spotShadowMatrix),
                (Ye.pointShadowMap.value = de.state.pointShadowMap),
                (Ye.pointShadowMatrix.value = de.state.pointShadowMatrix));
		const St = Xe.getUniforms(),
			zi = Ai.seqWithValue(St.seq, Ye);
		return (Q.currentProgram = Xe), (Q.uniformsList = zi), Xe;
	}
	function yh(L, X) {
		const ie = te.get(L);
		(ie.outputEncoding = X.outputEncoding),
		(ie.instancing = X.instancing),
		(ie.skinning = X.skinning),
		(ie.morphTargets = X.morphTargets),
		(ie.morphNormals = X.morphNormals),
		(ie.morphColors = X.morphColors),
		(ie.morphTargetsCount = X.morphTargetsCount),
		(ie.numClippingPlanes = X.numClippingPlanes),
		(ie.numIntersection = X.numClipIntersection),
		(ie.vertexAlphas = X.vertexAlphas),
		(ie.vertexTangents = X.vertexTangents),
		(ie.toneMapping = X.toneMapping);
	}
	function y0(L, X, ie, Q, de) {
		X.isScene !== !0 && (X = W), w.resetTextureUnits();
		const De = X.fog,
			Be = Q.isMeshStandardMaterial ? X.environment : null,
			Fe =
                A === null
                	? m.outputEncoding
                	: A.isXRRenderTarget === !0
                		? A.texture.encoding
                		: Qr,
			je = (Q.isMeshStandardMaterial ? N : R).get(Q.envMap || Be),
			ht =
                Q.vertexColors === !0 &&
                !!ie.attributes.color &&
                ie.attributes.color.itemSize === 4,
			Xe = !!Q.normalMap && !!ie.attributes.tangent,
			Ye = !!ie.morphAttributes.position,
			St = !!ie.morphAttributes.normal,
			zi = !!ie.morphAttributes.color,
			fn = Q.toneMapped ? m.toneMapping : $r,
			gn =
                ie.morphAttributes.position ||
                ie.morphAttributes.normal ||
                ie.morphAttributes.color,
			Mr = gn !== void 0 ? gn.length : 0,
			Qe = te.get(Q),
			vn = d.state.lights;
		if (P === !0 && (Z === !0 || L !== M)) {
			const lr = L === M && Q.id === S;
			y.setState(Q, L, lr);
		}
		let Ra = !1;
		Q.version === Qe.__version
			? ((Qe.needsLights && Qe.lightsStateVersion !== vn.state.version) ||
                  Qe.outputEncoding !== Fe ||
                  (de.isInstancedMesh && Qe.instancing === !1) ||
                  (!de.isInstancedMesh && Qe.instancing === !0) ||
                  (de.isSkinnedMesh && Qe.skinning === !1) ||
                  (!de.isSkinnedMesh && Qe.skinning === !0) ||
                  Qe.envMap !== je ||
                  (Q.fog && Qe.fog !== De) ||
                  (Qe.numClippingPlanes !== void 0 &&
                      (Qe.numClippingPlanes !== y.numPlanes ||
                          Qe.numIntersection !== y.numIntersection)) ||
                  Qe.vertexAlphas !== ht ||
                  Qe.vertexTangents !== Xe ||
                  Qe.morphTargets !== Ye ||
                  Qe.morphNormals !== St ||
                  Qe.morphColors !== zi ||
                  Qe.toneMapping !== fn ||
                  (Te.isWebGL2 === !0 && Qe.morphTargetsCount !== Mr)) &&
              (Ra = !0)
			: ((Ra = !0), (Qe.__version = Q.version));
		let Sr = Qe.currentProgram;
		Ra === !0 && (Sr = yl(Q, X, de));
		let ii = !1,
			ka = !1,
			xl = !1;
		const It = Sr.getUniforms(),
			Ca = Qe.uniforms;
		if (
			(ae.useProgram(Sr.program) && ((ii = !0), (ka = !0), (xl = !0)),
			Q.id !== S && ((S = Q.id), (ka = !0)),
			ii || M !== L)
		) {
			if (
				(It.setValue(U, 'projectionMatrix', L.projectionMatrix),
				Te.logarithmicDepthBuffer &&
                    It.setValue(
                    	U,
                    	'logDepthBufFC',
                    	2 / (Math.log(L.far + 1) / Math.LN2)
                    ),
				M !== L && ((M = L), (ka = !0), (xl = !0)),
				Q.isShaderMaterial ||
                    Q.isMeshPhongMaterial ||
                    Q.isMeshToonMaterial ||
                    Q.isMeshStandardMaterial ||
                    Q.envMap)
			) {
				const lr = It.map.cameraPosition;
				lr !== void 0 &&
                    lr.setValue(U, xe.setFromMatrixPosition(L.matrixWorld));
			}
			(Q.isMeshPhongMaterial ||
                Q.isMeshToonMaterial ||
                Q.isMeshLambertMaterial ||
                Q.isMeshBasicMaterial ||
                Q.isMeshStandardMaterial ||
                Q.isShaderMaterial) &&
                It.setValue(U, 'isOrthographic', L.isOrthographicCamera === !0),
			(Q.isMeshPhongMaterial ||
                    Q.isMeshToonMaterial ||
                    Q.isMeshLambertMaterial ||
                    Q.isMeshBasicMaterial ||
                    Q.isMeshStandardMaterial ||
                    Q.isShaderMaterial ||
                    Q.isShadowMaterial ||
                    de.isSkinnedMesh) &&
                    It.setValue(U, 'viewMatrix', L.matrixWorldInverse);
		}
		if (de.isSkinnedMesh) {
			It.setOptional(U, de, 'bindMatrix'),
			It.setOptional(U, de, 'bindMatrixInverse');
			const lr = de.skeleton;
			lr &&
                (Te.floatVertexTextures
                	? (lr.boneTexture === null && lr.computeBoneTexture(),
                	It.setValue(U, 'boneTexture', lr.boneTexture, w),
                	It.setValue(U, 'boneTextureSize', lr.boneTextureSize))
                	: It.setOptional(U, lr, 'boneMatrices'));
		}
		const bl = ie.morphAttributes;
		return (
			(bl.position !== void 0 ||
                bl.normal !== void 0 ||
                (bl.color !== void 0 && Te.isWebGL2 === !0)) &&
                oe.update(de, ie, Q, Sr),
			(ka || Qe.receiveShadow !== de.receiveShadow) &&
                ((Qe.receiveShadow = de.receiveShadow),
                It.setValue(U, 'receiveShadow', de.receiveShadow)),
			ka &&
                (It.setValue(U, 'toneMappingExposure', m.toneMappingExposure),
                Qe.needsLights && x0(Ca, xl),
                De && Q.fog && he.refreshFogUniforms(Ca, De),
                he.refreshMaterialUniforms(Ca, Q, b, B, J),
                Ai.upload(U, Qe.uniformsList, Ca, w)),
			Q.isShaderMaterial &&
                Q.uniformsNeedUpdate === !0 &&
                (Ai.upload(U, Qe.uniformsList, Ca, w),
                (Q.uniformsNeedUpdate = !1)),
			Q.isSpriteMaterial && It.setValue(U, 'center', de.center),
			It.setValue(U, 'modelViewMatrix', de.modelViewMatrix),
			It.setValue(U, 'normalMatrix', de.normalMatrix),
			It.setValue(U, 'modelMatrix', de.matrixWorld),
			Sr
		);
	}
	function x0(L, X) {
		(L.ambientLightColor.needsUpdate = X),
		(L.lightProbe.needsUpdate = X),
		(L.directionalLights.needsUpdate = X),
		(L.directionalLightShadows.needsUpdate = X),
		(L.pointLights.needsUpdate = X),
		(L.pointLightShadows.needsUpdate = X),
		(L.spotLights.needsUpdate = X),
		(L.spotLightShadows.needsUpdate = X),
		(L.rectAreaLights.needsUpdate = X),
		(L.hemisphereLights.needsUpdate = X);
	}
	function b0(L) {
		return (
			L.isMeshLambertMaterial ||
            L.isMeshToonMaterial ||
            L.isMeshPhongMaterial ||
            L.isMeshStandardMaterial ||
            L.isShadowMaterial ||
            (L.isShaderMaterial && L.lights === !0)
		);
	}
	(this.getActiveCubeFace = function () {
		return v;
	}),
	(this.getActiveMipmapLevel = function () {
		return x;
	}),
	(this.getRenderTarget = function () {
		return A;
	}),
	(this.setRenderTargetTextures = function (L, X, ie) {
		(te.get(L.texture).__webglTexture = X),
		(te.get(L.depthTexture).__webglTexture = ie);
		const Q = te.get(L);
		(Q.__hasExternalTextures = !0),
		Q.__hasExternalTextures &&
                    ((Q.__autoAllocateDepthBuffer = ie === void 0),
                    Q.__autoAllocateDepthBuffer ||
                        (Ae.has('WEBGL_multisampled_render_to_texture') ===
                            !0 &&
                            (console.warn(
                            	'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided'
                            ),
                            (Q.__useRenderToTexture = !1))));
	}),
	(this.setRenderTargetFramebuffer = function (L, X) {
		const ie = te.get(L);
		(ie.__webglFramebuffer = X),
		(ie.__useDefaultFramebuffer = X === void 0);
	}),
	(this.setRenderTarget = function (L, X = 0, ie = 0) {
		(A = L), (v = X), (x = ie);
		let Q = !0;
		if (L) {
			const Fe = te.get(L);
			Fe.__useDefaultFramebuffer !== void 0
				? (ae.bindFramebuffer(36160, null), (Q = !1))
				: Fe.__webglFramebuffer === void 0
					? w.setupRenderTarget(L)
					: Fe.__hasExternalTextures &&
                      w.rebindTextures(
                      	L,
                      	te.get(L.texture).__webglTexture,
                      	te.get(L.depthTexture).__webglTexture
                      );
		}
		let de = null,
			De = !1,
			Be = !1;
		if (L) {
			const Fe = L.texture;
			(Fe.isData3DTexture || Fe.isDataArrayTexture) && (Be = !0);
			const je = te.get(L).__webglFramebuffer;
			L.isWebGLCubeRenderTarget
				? ((de = je[X]), (De = !0))
				: Te.isWebGL2 &&
                      L.samples > 0 &&
                      w.useMultisampledRTT(L) === !1
					? (de = te.get(L).__webglMultisampledFramebuffer)
					: (de = je),
			I.copy(L.viewport),
			D.copy(L.scissor),
			(G = L.scissorTest);
		} else
			I.copy(z).multiplyScalar(b).floor(),
			D.copy(V).multiplyScalar(b).floor(),
			(G = H);
		if (
			(ae.bindFramebuffer(36160, de) &&
                    Te.drawBuffers &&
                    Q &&
                    ae.drawBuffers(L, de),
			ae.viewport(I),
			ae.scissor(D),
			ae.setScissorTest(G),
			De)
		) {
			const Fe = te.get(L.texture);
			U.framebufferTexture2D(
				36160,
				36064,
				34069 + X,
				Fe.__webglTexture,
				ie
			);
		} else if (Be) {
			const Fe = te.get(L.texture),
				je = X || 0;
			U.framebufferTextureLayer(
				36160,
				36064,
				Fe.__webglTexture,
				ie || 0,
				je
			);
		}
		S = -1;
	}),
	(this.readRenderTargetPixels = function (L, X, ie, Q, de, De, Be) {
		if (!(L && L.isWebGLRenderTarget)) {
			console.error(
				'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.'
			);
			return;
		}
		let Fe = te.get(L).__webglFramebuffer;
		if (
			(L.isWebGLCubeRenderTarget && Be !== void 0 && (Fe = Fe[Be]),
			Fe)
		) {
			ae.bindFramebuffer(36160, Fe);
			try {
				const je = L.texture,
					ht = je.format,
					Xe = je.type;
				if (ht !== Qt && T.convert(ht) !== U.getParameter(35739)) {
					console.error(
						'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.'
					);
					return;
				}
				const Ye =
                        Xe === ta &&
                        (Ae.has('EXT_color_buffer_half_float') ||
                            (Te.isWebGL2 && Ae.has('EXT_color_buffer_float')));
				if (
					Xe !== sn &&
                        T.convert(Xe) !== U.getParameter(35738) &&
                        !(
                        	Xe === wi &&
                            (Te.isWebGL2 ||
                                Ae.has('OES_texture_float') ||
                                Ae.has('WEBGL_color_buffer_float'))
                        ) &&
                        !Ye
				) {
					console.error(
						'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.'
					);
					return;
				}
				X >= 0 &&
                        X <= L.width - Q &&
                        ie >= 0 &&
                        ie <= L.height - de &&
                        U.readPixels(
                        	X,
                        	ie,
                        	Q,
                        	de,
                        	T.convert(ht),
                        	T.convert(Xe),
                        	De
                        );
			} finally {
				const je = A !== null ? te.get(A).__webglFramebuffer : null;
				ae.bindFramebuffer(36160, je);
			}
		}
	}),
	(this.copyFramebufferToTexture = function (L, X, ie = 0) {
		if (X.isFramebufferTexture !== !0) {
			console.error(
				'THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.'
			);
			return;
		}
		const Q = Math.pow(2, -ie),
			de = Math.floor(X.image.width * Q),
			De = Math.floor(X.image.height * Q);
		w.setTexture2D(X, 0),
		U.copyTexSubImage2D(3553, ie, 0, 0, L.x, L.y, de, De),
		ae.unbindTexture();
	}),
	(this.copyTextureToTexture = function (L, X, ie, Q = 0) {
		const de = X.image.width,
			De = X.image.height,
			Be = T.convert(ie.format),
			Fe = T.convert(ie.type);
		w.setTexture2D(ie, 0),
		U.pixelStorei(37440, ie.flipY),
		U.pixelStorei(37441, ie.premultiplyAlpha),
		U.pixelStorei(3317, ie.unpackAlignment),
		X.isDataTexture
			? U.texSubImage2D(
				3553,
				Q,
				L.x,
				L.y,
				de,
				De,
				Be,
				Fe,
				X.image.data
			)
			: X.isCompressedTexture
				? U.compressedTexSubImage2D(
					3553,
					Q,
					L.x,
					L.y,
					X.mipmaps[0].width,
					X.mipmaps[0].height,
					Be,
					X.mipmaps[0].data
				)
				: U.texSubImage2D(3553, Q, L.x, L.y, Be, Fe, X.image),
		Q === 0 && ie.generateMipmaps && U.generateMipmap(3553),
		ae.unbindTexture();
	}),
	(this.copyTextureToTexture3D = function (L, X, ie, Q, de = 0) {
		if (m.isWebGL1Renderer) {
			console.warn(
				'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.'
			);
			return;
		}
		const De = L.max.x - L.min.x + 1,
			Be = L.max.y - L.min.y + 1,
			Fe = L.max.z - L.min.z + 1,
			je = T.convert(Q.format),
			ht = T.convert(Q.type);
		let Xe;
		if (Q.isData3DTexture) w.setTexture3D(Q, 0), (Xe = 32879);
		else if (Q.isDataArrayTexture)
			w.setTexture2DArray(Q, 0), (Xe = 35866);
		else {
			console.warn(
				'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.'
			);
			return;
		}
		U.pixelStorei(37440, Q.flipY),
		U.pixelStorei(37441, Q.premultiplyAlpha),
		U.pixelStorei(3317, Q.unpackAlignment);
		const Ye = U.getParameter(3314),
			St = U.getParameter(32878),
			zi = U.getParameter(3316),
			fn = U.getParameter(3315),
			gn = U.getParameter(32877),
			Mr = ie.isCompressedTexture ? ie.mipmaps[0] : ie.image;
		U.pixelStorei(3314, Mr.width),
		U.pixelStorei(32878, Mr.height),
		U.pixelStorei(3316, L.min.x),
		U.pixelStorei(3315, L.min.y),
		U.pixelStorei(32877, L.min.z),
		ie.isDataTexture || ie.isData3DTexture
			? U.texSubImage3D(
				Xe,
				de,
				X.x,
				X.y,
				X.z,
				De,
				Be,
				Fe,
				je,
				ht,
				Mr.data
			)
			: ie.isCompressedTexture
				? (console.warn(
					'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.'
				),
				U.compressedTexSubImage3D(
					Xe,
					de,
					X.x,
					X.y,
					X.z,
					De,
					Be,
					Fe,
					je,
					Mr.data
				))
				: U.texSubImage3D(
					Xe,
					de,
					X.x,
					X.y,
					X.z,
					De,
					Be,
					Fe,
					je,
					ht,
					Mr
				),
		U.pixelStorei(3314, Ye),
		U.pixelStorei(32878, St),
		U.pixelStorei(3316, zi),
		U.pixelStorei(3315, fn),
		U.pixelStorei(32877, gn),
		de === 0 && Q.generateMipmaps && U.generateMipmap(Xe),
		ae.unbindTexture();
	}),
	(this.initTexture = function (L) {
		w.setTexture2D(L, 0), ae.unbindTexture();
	}),
	(this.resetState = function () {
		(v = 0), (x = 0), (A = null), ae.reset(), se.reset();
	}),
	typeof __THREE_DEVTOOLS__ != 'undefined' &&
            __THREE_DEVTOOLS__.dispatchEvent(
            	new CustomEvent('observe', { detail: this })
            );
}
tt.prototype.isWebGLRenderer = !0;
class eS extends tt {}
eS.prototype.isWebGL1Renderer = !0;
class ll extends Je {
	constructor() {
		super(),
		(this.type = 'Scene'),
		(this.background = null),
		(this.environment = null),
		(this.fog = null),
		(this.overrideMaterial = null),
		(this.autoUpdate = !0),
		typeof __THREE_DEVTOOLS__ != 'undefined' &&
                __THREE_DEVTOOLS__.dispatchEvent(
                	new CustomEvent('observe', { detail: this })
                );
	}
	copy(e, t) {
		return (
			super.copy(e, t),
			e.background !== null && (this.background = e.background.clone()),
			e.environment !== null &&
                (this.environment = e.environment.clone()),
			e.fog !== null && (this.fog = e.fog.clone()),
			e.overrideMaterial !== null &&
                (this.overrideMaterial = e.overrideMaterial.clone()),
			(this.autoUpdate = e.autoUpdate),
			(this.matrixAutoUpdate = e.matrixAutoUpdate),
			this
		);
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return this.fog !== null && (t.object.fog = this.fog.toJSON()), t;
	}
}
ll.prototype.isScene = !0;
class Sa {
	constructor(e, t) {
		(this.array = e),
		(this.stride = t),
		(this.count = e !== void 0 ? e.length / t : 0),
		(this.usage = gs),
		(this.updateRange = { offset: 0, count: -1 }),
		(this.version = 0),
		(this.uuid = ir());
	}
	onUploadCallback() {}
	set needsUpdate(e) {
		e === !0 && this.version++;
	}
	setUsage(e) {
		return (this.usage = e), this;
	}
	copy(e) {
		return (
			(this.array = new e.array.constructor(e.array)),
			(this.count = e.count),
			(this.stride = e.stride),
			(this.usage = e.usage),
			this
		);
	}
	copyAt(e, t, i) {
		(e *= this.stride), (i *= t.stride);
		for (let n = 0, a = this.stride; n < a; n++)
			this.array[e + n] = t.array[i + n];
		return this;
	}
	set(e, t = 0) {
		return this.array.set(e, t), this;
	}
	clone(e) {
		e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
		this.array.buffer._uuid === void 0 &&
                (this.array.buffer._uuid = ir()),
		e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
                (e.arrayBuffers[this.array.buffer._uuid] =
                    this.array.slice(0).buffer);
		const t = new this.array.constructor(
				e.arrayBuffers[this.array.buffer._uuid]
			),
			i = new this.constructor(t, this.stride);
		return i.setUsage(this.usage), i;
	}
	onUpload(e) {
		return (this.onUploadCallback = e), this;
	}
	toJSON(e) {
		return (
			e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
			this.array.buffer._uuid === void 0 &&
                (this.array.buffer._uuid = ir()),
			e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
                (e.arrayBuffers[this.array.buffer._uuid] =
                    Array.prototype.slice.call(
                    	new Uint32Array(this.array.buffer)
                    )),
			{
				uuid: this.uuid,
				buffer: this.array.buffer._uuid,
				type: this.array.constructor.name,
				stride: this.stride
			}
		);
	}
}
Sa.prototype.isInterleavedBuffer = !0;
const Bt = new C();
class ha {
	constructor(e, t, i, n = !1) {
		(this.name = ''),
		(this.data = e),
		(this.itemSize = t),
		(this.offset = i),
		(this.normalized = n === !0);
	}
	get count() {
		return this.data.count;
	}
	get array() {
		return this.data.array;
	}
	set needsUpdate(e) {
		this.data.needsUpdate = e;
	}
	applyMatrix4(e) {
		for (let t = 0, i = this.data.count; t < i; t++)
			Bt.fromBufferAttribute(this, t),
			Bt.applyMatrix4(e),
			this.setXYZ(t, Bt.x, Bt.y, Bt.z);
		return this;
	}
	applyNormalMatrix(e) {
		for (let t = 0, i = this.count; t < i; t++)
			Bt.fromBufferAttribute(this, t),
			Bt.applyNormalMatrix(e),
			this.setXYZ(t, Bt.x, Bt.y, Bt.z);
		return this;
	}
	transformDirection(e) {
		for (let t = 0, i = this.count; t < i; t++)
			Bt.fromBufferAttribute(this, t),
			Bt.transformDirection(e),
			this.setXYZ(t, Bt.x, Bt.y, Bt.z);
		return this;
	}
	setX(e, t) {
		return (this.data.array[e * this.data.stride + this.offset] = t), this;
	}
	setY(e, t) {
		return (
			(this.data.array[e * this.data.stride + this.offset + 1] = t), this
		);
	}
	setZ(e, t) {
		return (
			(this.data.array[e * this.data.stride + this.offset + 2] = t), this
		);
	}
	setW(e, t) {
		return (
			(this.data.array[e * this.data.stride + this.offset + 3] = t), this
		);
	}
	getX(e) {
		return this.data.array[e * this.data.stride + this.offset];
	}
	getY(e) {
		return this.data.array[e * this.data.stride + this.offset + 1];
	}
	getZ(e) {
		return this.data.array[e * this.data.stride + this.offset + 2];
	}
	getW(e) {
		return this.data.array[e * this.data.stride + this.offset + 3];
	}
	setXY(e, t, i) {
		return (
			(e = e * this.data.stride + this.offset),
			(this.data.array[e + 0] = t),
			(this.data.array[e + 1] = i),
			this
		);
	}
	setXYZ(e, t, i, n) {
		return (
			(e = e * this.data.stride + this.offset),
			(this.data.array[e + 0] = t),
			(this.data.array[e + 1] = i),
			(this.data.array[e + 2] = n),
			this
		);
	}
	setXYZW(e, t, i, n, a) {
		return (
			(e = e * this.data.stride + this.offset),
			(this.data.array[e + 0] = t),
			(this.data.array[e + 1] = i),
			(this.data.array[e + 2] = n),
			(this.data.array[e + 3] = a),
			this
		);
	}
	clone(e) {
		if (e === void 0) {
			console.log(
				'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.'
			);
			const t = [];
			for (let i = 0; i < this.count; i++) {
				const n = i * this.data.stride + this.offset;
				for (let a = 0; a < this.itemSize; a++)
					t.push(this.data.array[n + a]);
			}
			return new mt(
				new this.array.constructor(t),
				this.itemSize,
				this.normalized
			);
		} else
			return (
				e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
				e.interleavedBuffers[this.data.uuid] === void 0 &&
                    (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
				new ha(
					e.interleavedBuffers[this.data.uuid],
					this.itemSize,
					this.offset,
					this.normalized
				)
			);
	}
	toJSON(e) {
		if (e === void 0) {
			console.log(
				'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.'
			);
			const t = [];
			for (let i = 0; i < this.count; i++) {
				const n = i * this.data.stride + this.offset;
				for (let a = 0; a < this.itemSize; a++)
					t.push(this.data.array[n + a]);
			}
			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: t,
				normalized: this.normalized
			};
		} else
			return (
				e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
				e.interleavedBuffers[this.data.uuid] === void 0 &&
                    (e.interleavedBuffers[this.data.uuid] =
                        this.data.toJSON(e)),
				{
					isInterleavedBufferAttribute: !0,
					itemSize: this.itemSize,
					data: this.data.uuid,
					offset: this.offset,
					normalized: this.normalized
				}
			);
	}
}
ha.prototype.isInterleavedBufferAttribute = !0;
class Bu extends dt {
	constructor(e) {
		super(),
		(this.type = 'SpriteMaterial'),
		(this.color = new ke(16777215)),
		(this.map = null),
		(this.alphaMap = null),
		(this.rotation = 0),
		(this.sizeAttenuation = !0),
		(this.transparent = !0),
		this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			this.color.copy(e.color),
			(this.map = e.map),
			(this.alphaMap = e.alphaMap),
			(this.rotation = e.rotation),
			(this.sizeAttenuation = e.sizeAttenuation),
			this
		);
	}
}
Bu.prototype.isSpriteMaterial = !0;
let Dn;
const za = new C(),
	On = new C(),
	Nn = new C(),
	zn = new me(),
	Ua = new me(),
	$f = new Pe(),
	ao = new C(),
	Ba = new C(),
	so = new C(),
	hp = new me(),
	nc = new me(),
	dp = new me();
class tS extends Je {
	constructor(e) {
		if ((super(), (this.type = 'Sprite'), Dn === void 0)) {
			Dn = new ot();
			const t = new Float32Array([
					-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1,
					-0.5, 0.5, 0, 0, 1
				]),
				i = new Sa(t, 5);
			Dn.setIndex([0, 1, 2, 0, 2, 3]),
			Dn.setAttribute('position', new ha(i, 3, 0, !1)),
			Dn.setAttribute('uv', new ha(i, 2, 3, !1));
		}
		(this.geometry = Dn),
		(this.material = e !== void 0 ? e : new Bu()),
		(this.center = new me(0.5, 0.5));
	}
	raycast(e, t) {
		e.camera === null &&
            console.error(
            	'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
            ),
		On.setFromMatrixScale(this.matrixWorld),
		$f.copy(e.camera.matrixWorld),
		this.modelViewMatrix.multiplyMatrices(
			e.camera.matrixWorldInverse,
			this.matrixWorld
		),
		Nn.setFromMatrixPosition(this.modelViewMatrix),
		e.camera.isPerspectiveCamera &&
                this.material.sizeAttenuation === !1 &&
                On.multiplyScalar(-Nn.z);
		const i = this.material.rotation;
		let n, a;
		i !== 0 && ((a = Math.cos(i)), (n = Math.sin(i)));
		const s = this.center;
		oo(ao.set(-0.5, -0.5, 0), Nn, s, On, n, a),
		oo(Ba.set(0.5, -0.5, 0), Nn, s, On, n, a),
		oo(so.set(0.5, 0.5, 0), Nn, s, On, n, a),
		hp.set(0, 0),
		nc.set(1, 0),
		dp.set(1, 1);
		let o = e.ray.intersectTriangle(ao, Ba, so, !1, za);
		if (
			o === null &&
            (oo(Ba.set(-0.5, 0.5, 0), Nn, s, On, n, a),
            nc.set(0, 1),
            (o = e.ray.intersectTriangle(ao, so, Ba, !1, za)),
            o === null)
		)
			return;
		const l = e.ray.origin.distanceTo(za);
		l < e.near ||
            l > e.far ||
            t.push({
            	distance: l,
            	point: za.clone(),
            	uv: vt.getUV(za, ao, Ba, so, hp, nc, dp, new me()),
            	face: null,
            	object: this
            });
	}
	copy(e) {
		return (
			super.copy(e),
			e.center !== void 0 && this.center.copy(e.center),
			(this.material = e.material),
			this
		);
	}
}
tS.prototype.isSprite = !0;
function oo(r, e, t, i, n, a) {
	zn.subVectors(r, t).addScalar(0.5).multiply(i),
	n !== void 0
		? ((Ua.x = a * zn.x - n * zn.y), (Ua.y = n * zn.x + a * zn.y))
		: Ua.copy(zn),
	r.copy(e),
	(r.x += Ua.x),
	(r.y += Ua.y),
	r.applyMatrix4($f);
}
const pp = new C(),
	mp = new it(),
	fp = new it(),
	rS = new C(),
	gp = new Pe();
class Fu extends rt {
	constructor(e, t) {
		super(e, t),
		(this.type = 'SkinnedMesh'),
		(this.bindMode = 'attached'),
		(this.bindMatrix = new Pe()),
		(this.bindMatrixInverse = new Pe());
	}
	copy(e) {
		return (
			super.copy(e),
			(this.bindMode = e.bindMode),
			this.bindMatrix.copy(e.bindMatrix),
			this.bindMatrixInverse.copy(e.bindMatrixInverse),
			(this.skeleton = e.skeleton),
			this
		);
	}
	bind(e, t) {
		(this.skeleton = e),
		t === void 0 &&
                (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                (t = this.matrixWorld)),
		this.bindMatrix.copy(t),
		this.bindMatrixInverse.copy(t).invert();
	}
	pose() {
		this.skeleton.pose();
	}
	normalizeSkinWeights() {
		const e = new it(),
			t = this.geometry.attributes.skinWeight;
		for (let i = 0, n = t.count; i < n; i++) {
			e.fromBufferAttribute(t, i);
			const a = 1 / e.manhattanLength();
			a !== 1 / 0 ? e.multiplyScalar(a) : e.set(1, 0, 0, 0),
			t.setXYZW(i, e.x, e.y, e.z, e.w);
		}
	}
	updateMatrixWorld(e) {
		super.updateMatrixWorld(e),
		this.bindMode === 'attached'
			? this.bindMatrixInverse.copy(this.matrixWorld).invert()
			: this.bindMode === 'detached'
				? this.bindMatrixInverse.copy(this.bindMatrix).invert()
				: console.warn(
					'THREE.SkinnedMesh: Unrecognized bindMode: ' +
                          this.bindMode
				);
	}
	boneTransform(e, t) {
		const i = this.skeleton,
			n = this.geometry;
		mp.fromBufferAttribute(n.attributes.skinIndex, e),
		fp.fromBufferAttribute(n.attributes.skinWeight, e),
		pp.copy(t).applyMatrix4(this.bindMatrix),
		t.set(0, 0, 0);
		for (let a = 0; a < 4; a++) {
			const s = fp.getComponent(a);
			if (s !== 0) {
				const o = mp.getComponent(a);
				gp.multiplyMatrices(i.bones[o].matrixWorld, i.boneInverses[o]),
				t.addScaledVector(rS.copy(pp).applyMatrix4(gp), s);
			}
		}
		return t.applyMatrix4(this.bindMatrixInverse);
	}
}
Fu.prototype.isSkinnedMesh = !0;
class Hu extends Je {
	constructor() {
		super(), (this.type = 'Bone');
	}
}
Hu.prototype.isBone = !0;
class Kf extends wt {
	constructor(e = null, t = 1, i = 1, n, a, s, o, l, c = Mt, u = Mt, h, d) {
		super(null, s, o, l, c, u, n, a, h, d),
		(this.image = { data: e, width: t, height: i }),
		(this.generateMipmaps = !1),
		(this.flipY = !1),
		(this.unpackAlignment = 1);
	}
}
Kf.prototype.isDataTexture = !0;
const vp = new Pe(),
	iS = new Pe();
class Gu {
	constructor(e = [], t = []) {
		(this.uuid = ir()),
		(this.bones = e.slice(0)),
		(this.boneInverses = t),
		(this.boneMatrices = null),
		(this.boneTexture = null),
		(this.boneTextureSize = 0),
		(this.frame = -1),
		this.init();
	}
	init() {
		const e = this.bones,
			t = this.boneInverses;
		if (
			((this.boneMatrices = new Float32Array(e.length * 16)),
			t.length === 0)
		)
			this.calculateInverses();
		else if (e.length !== t.length) {
			console.warn(
				'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.'
			),
			(this.boneInverses = []);
			for (let i = 0, n = this.bones.length; i < n; i++)
				this.boneInverses.push(new Pe());
		}
	}
	calculateInverses() {
		this.boneInverses.length = 0;
		for (let e = 0, t = this.bones.length; e < t; e++) {
			const i = new Pe();
			this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
			this.boneInverses.push(i);
		}
	}
	pose() {
		for (let e = 0, t = this.bones.length; e < t; e++) {
			const i = this.bones[e];
			i && i.matrixWorld.copy(this.boneInverses[e]).invert();
		}
		for (let e = 0, t = this.bones.length; e < t; e++) {
			const i = this.bones[e];
			i &&
                (i.parent && i.parent.isBone
                	? (i.matrix.copy(i.parent.matrixWorld).invert(),
                	i.matrix.multiply(i.matrixWorld))
                	: i.matrix.copy(i.matrixWorld),
                i.matrix.decompose(i.position, i.quaternion, i.scale));
		}
	}
	update() {
		const e = this.bones,
			t = this.boneInverses,
			i = this.boneMatrices,
			n = this.boneTexture;
		for (let a = 0, s = e.length; a < s; a++) {
			const o = e[a] ? e[a].matrixWorld : iS;
			vp.multiplyMatrices(o, t[a]), vp.toArray(i, a * 16);
		}
		n !== null && (n.needsUpdate = !0);
	}
	clone() {
		return new Gu(this.bones, this.boneInverses);
	}
	computeBoneTexture() {
		let e = Math.sqrt(this.bones.length * 4);
		(e = Cf(e)), (e = Math.max(e, 4));
		const t = new Float32Array(e * e * 4);
		t.set(this.boneMatrices);
		const i = new Kf(t, e, e, Qt, wi);
		return (
			(i.needsUpdate = !0),
			(this.boneMatrices = t),
			(this.boneTexture = i),
			(this.boneTextureSize = e),
			this
		);
	}
	getBoneByName(e) {
		for (let t = 0, i = this.bones.length; t < i; t++) {
			const n = this.bones[t];
			if (n.name === e) return n;
		}
	}
	dispose() {
		this.boneTexture !== null &&
            (this.boneTexture.dispose(), (this.boneTexture = null));
	}
	fromJSON(e, t) {
		this.uuid = e.uuid;
		for (let i = 0, n = e.bones.length; i < n; i++) {
			const a = e.bones[i];
			let s = t[a];
			s === void 0 &&
                (console.warn('THREE.Skeleton: No bone found with UUID:', a),
                (s = new Hu())),
			this.bones.push(s),
			this.boneInverses.push(new Pe().fromArray(e.boneInverses[i]));
		}
		return this.init(), this;
	}
	toJSON() {
		const e = {
			metadata: {
				version: 4.5,
				type: 'Skeleton',
				generator: 'Skeleton.toJSON'
			},
			bones: [],
			boneInverses: []
		};
		e.uuid = this.uuid;
		const t = this.bones,
			i = this.boneInverses;
		for (let n = 0, a = t.length; n < a; n++) {
			const s = t[n];
			e.bones.push(s.uuid);
			const o = i[n];
			e.boneInverses.push(o.toArray());
		}
		return e;
	}
}
class qc extends mt {
	constructor(e, t, i, n = 1) {
		typeof i == 'number' &&
            ((n = i),
            (i = !1),
            console.error(
            	'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.'
            )),
		super(e, t, i),
		(this.meshPerAttribute = n);
	}
	copy(e) {
		return (
			super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
		);
	}
	toJSON() {
		const e = super.toJSON();
		return (
			(e.meshPerAttribute = this.meshPerAttribute),
			(e.isInstancedBufferAttribute = !0),
			e
		);
	}
}
qc.prototype.isInstancedBufferAttribute = !0;
const yp = new Pe(),
	xp = new Pe(),
	lo = [],
	Fa = new rt();
class nS extends rt {
	constructor(e, t, i) {
		super(e, t),
		(this.instanceMatrix = new qc(new Float32Array(i * 16), 16)),
		(this.instanceColor = null),
		(this.count = i),
		(this.frustumCulled = !1);
	}
	copy(e) {
		return (
			super.copy(e),
			this.instanceMatrix.copy(e.instanceMatrix),
			e.instanceColor !== null &&
                (this.instanceColor = e.instanceColor.clone()),
			(this.count = e.count),
			this
		);
	}
	getColorAt(e, t) {
		t.fromArray(this.instanceColor.array, e * 3);
	}
	getMatrixAt(e, t) {
		t.fromArray(this.instanceMatrix.array, e * 16);
	}
	raycast(e, t) {
		const i = this.matrixWorld,
			n = this.count;
		if (
			((Fa.geometry = this.geometry),
			(Fa.material = this.material),
			Fa.material !== void 0)
		)
			for (let a = 0; a < n; a++) {
				this.getMatrixAt(a, yp),
				xp.multiplyMatrices(i, yp),
				(Fa.matrixWorld = xp),
				Fa.raycast(e, lo);
				for (let s = 0, o = lo.length; s < o; s++) {
					const l = lo[s];
					(l.instanceId = a), (l.object = this), t.push(l);
				}
				lo.length = 0;
			}
	}
	setColorAt(e, t) {
		this.instanceColor === null &&
            (this.instanceColor = new qc(
            	new Float32Array(this.instanceMatrix.count * 3),
            	3
            )),
		t.toArray(this.instanceColor.array, e * 3);
	}
	setMatrixAt(e, t) {
		t.toArray(this.instanceMatrix.array, e * 16);
	}
	updateMorphTargets() {}
	dispose() {
		this.dispatchEvent({ type: 'dispose' });
	}
}
nS.prototype.isInstancedMesh = !0;
class Oi extends dt {
	constructor(e) {
		super(),
		(this.type = 'LineBasicMaterial'),
		(this.color = new ke(16777215)),
		(this.linewidth = 1),
		(this.linecap = 'round'),
		(this.linejoin = 'round'),
		this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			this.color.copy(e.color),
			(this.linewidth = e.linewidth),
			(this.linecap = e.linecap),
			(this.linejoin = e.linejoin),
			this
		);
	}
}
Oi.prototype.isLineBasicMaterial = !0;
const bp = new C(),
	wp = new C(),
	_p = new Pe(),
	ac = new wa(),
	co = new dn();
class da extends Je {
	constructor(e = new ot(), t = new Oi()) {
		super(),
		(this.type = 'Line'),
		(this.geometry = e),
		(this.material = t),
		this.updateMorphTargets();
	}
	copy(e) {
		return (
			super.copy(e),
			(this.material = e.material),
			(this.geometry = e.geometry),
			this
		);
	}
	computeLineDistances() {
		const e = this.geometry;
		if (e.isBufferGeometry)
			if (e.index === null) {
				const t = e.attributes.position,
					i = [0];
				for (let n = 1, a = t.count; n < a; n++)
					bp.fromBufferAttribute(t, n - 1),
					wp.fromBufferAttribute(t, n),
					(i[n] = i[n - 1]),
					(i[n] += bp.distanceTo(wp));
				e.setAttribute('lineDistance', new yt(i, 1));
			} else
				console.warn(
					'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.'
				);
		else
			e.isGeometry &&
                console.error(
                	'THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
                );
		return this;
	}
	raycast(e, t) {
		const i = this.geometry,
			n = this.matrixWorld,
			a = e.params.Line.threshold,
			s = i.drawRange;
		if (
			(i.boundingSphere === null && i.computeBoundingSphere(),
			co.copy(i.boundingSphere),
			co.applyMatrix4(n),
			(co.radius += a),
			e.ray.intersectsSphere(co) === !1)
		)
			return;
		_p.copy(n).invert(), ac.copy(e.ray).applyMatrix4(_p);
		const o = a / ((this.scale.x + this.scale.y + this.scale.z) / 3),
			l = o * o,
			c = new C(),
			u = new C(),
			h = new C(),
			d = new C(),
			p = this.isLineSegments ? 2 : 1;
		if (i.isBufferGeometry) {
			const g = i.index,
				m = i.attributes.position;
			if (g !== null) {
				const f = Math.max(0, s.start),
					v = Math.min(g.count, s.start + s.count);
				for (let x = f, A = v - 1; x < A; x += p) {
					const S = g.getX(x),
						M = g.getX(x + 1);
					if (
						(c.fromBufferAttribute(m, S),
						u.fromBufferAttribute(m, M),
						ac.distanceSqToSegment(c, u, d, h) > l)
					)
						continue;
					d.applyMatrix4(this.matrixWorld);
					const I = e.ray.origin.distanceTo(d);
					I < e.near ||
                        I > e.far ||
                        t.push({
                        	distance: I,
                        	point: h.clone().applyMatrix4(this.matrixWorld),
                        	index: x,
                        	face: null,
                        	faceIndex: null,
                        	object: this
                        });
				}
			} else {
				const f = Math.max(0, s.start),
					v = Math.min(m.count, s.start + s.count);
				for (let x = f, A = v - 1; x < A; x += p) {
					if (
						(c.fromBufferAttribute(m, x),
						u.fromBufferAttribute(m, x + 1),
						ac.distanceSqToSegment(c, u, d, h) > l)
					)
						continue;
					d.applyMatrix4(this.matrixWorld);
					const S = e.ray.origin.distanceTo(d);
					S < e.near ||
                        S > e.far ||
                        t.push({
                        	distance: S,
                        	point: h.clone().applyMatrix4(this.matrixWorld),
                        	index: x,
                        	face: null,
                        	faceIndex: null,
                        	object: this
                        });
				}
			}
		} else
			i.isGeometry &&
                console.error(
                	'THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
                );
	}
	updateMorphTargets() {
		const e = this.geometry;
		if (e.isBufferGeometry) {
			const t = e.morphAttributes,
				i = Object.keys(t);
			if (i.length > 0) {
				const n = t[i[0]];
				if (n !== void 0) {
					(this.morphTargetInfluences = []),
					(this.morphTargetDictionary = {});
					for (let a = 0, s = n.length; a < s; a++) {
						const o = n[a].name || String(a);
						this.morphTargetInfluences.push(0),
						(this.morphTargetDictionary[o] = a);
					}
				}
			}
		} else {
			const t = e.morphTargets;
			t !== void 0 &&
                t.length > 0 &&
                console.error(
                	'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.'
                );
		}
	}
}
da.prototype.isLine = !0;
const Mp = new C(),
	Sp = new C();
class cl extends da {
	constructor(e, t) {
		super(e, t), (this.type = 'LineSegments');
	}
	computeLineDistances() {
		const e = this.geometry;
		if (e.isBufferGeometry)
			if (e.index === null) {
				const t = e.attributes.position,
					i = [];
				for (let n = 0, a = t.count; n < a; n += 2)
					Mp.fromBufferAttribute(t, n),
					Sp.fromBufferAttribute(t, n + 1),
					(i[n] = n === 0 ? 0 : i[n - 1]),
					(i[n + 1] = i[n] + Mp.distanceTo(Sp));
				e.setAttribute('lineDistance', new yt(i, 1));
			} else
				console.warn(
					'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.'
				);
		else
			e.isGeometry &&
                console.error(
                	'THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
                );
		return this;
	}
}
cl.prototype.isLineSegments = !0;
class Jf extends da {
	constructor(e, t) {
		super(e, t), (this.type = 'LineLoop');
	}
}
Jf.prototype.isLineLoop = !0;
class ul extends dt {
	constructor(e) {
		super(),
		(this.type = 'PointsMaterial'),
		(this.color = new ke(16777215)),
		(this.map = null),
		(this.alphaMap = null),
		(this.size = 1),
		(this.sizeAttenuation = !0),
		this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			this.color.copy(e.color),
			(this.map = e.map),
			(this.alphaMap = e.alphaMap),
			(this.size = e.size),
			(this.sizeAttenuation = e.sizeAttenuation),
			this
		);
	}
}
ul.prototype.isPointsMaterial = !0;
const Tp = new Pe(),
	Yc = new wa(),
	uo = new dn(),
	ho = new C();
class Qf extends Je {
	constructor(e = new ot(), t = new ul()) {
		super(),
		(this.type = 'Points'),
		(this.geometry = e),
		(this.material = t),
		this.updateMorphTargets();
	}
	copy(e) {
		return (
			super.copy(e),
			(this.material = e.material),
			(this.geometry = e.geometry),
			this
		);
	}
	raycast(e, t) {
		const i = this.geometry,
			n = this.matrixWorld,
			a = e.params.Points.threshold,
			s = i.drawRange;
		if (
			(i.boundingSphere === null && i.computeBoundingSphere(),
			uo.copy(i.boundingSphere),
			uo.applyMatrix4(n),
			(uo.radius += a),
			e.ray.intersectsSphere(uo) === !1)
		)
			return;
		Tp.copy(n).invert(), Yc.copy(e.ray).applyMatrix4(Tp);
		const o = a / ((this.scale.x + this.scale.y + this.scale.z) / 3),
			l = o * o;
		if (i.isBufferGeometry) {
			const c = i.index,
				u = i.attributes.position;
			if (c !== null) {
				const h = Math.max(0, s.start),
					d = Math.min(c.count, s.start + s.count);
				for (let p = h, g = d; p < g; p++) {
					const m = c.getX(p);
					ho.fromBufferAttribute(u, m), Ep(ho, m, l, n, e, t, this);
				}
			} else {
				const h = Math.max(0, s.start),
					d = Math.min(u.count, s.start + s.count);
				for (let p = h, g = d; p < g; p++)
					ho.fromBufferAttribute(u, p), Ep(ho, p, l, n, e, t, this);
			}
		} else
			console.error(
				'THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
			);
	}
	updateMorphTargets() {
		const e = this.geometry;
		if (e.isBufferGeometry) {
			const t = e.morphAttributes,
				i = Object.keys(t);
			if (i.length > 0) {
				const n = t[i[0]];
				if (n !== void 0) {
					(this.morphTargetInfluences = []),
					(this.morphTargetDictionary = {});
					for (let a = 0, s = n.length; a < s; a++) {
						const o = n[a].name || String(a);
						this.morphTargetInfluences.push(0),
						(this.morphTargetDictionary[o] = a);
					}
				}
			}
		} else {
			const t = e.morphTargets;
			t !== void 0 &&
                t.length > 0 &&
                console.error(
                	'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.'
                );
		}
	}
}
Qf.prototype.isPoints = !0;
function Ep(r, e, t, i, n, a, s) {
	const o = Yc.distanceSqToPoint(r);
	if (o < t) {
		const l = new C();
		Yc.closestPointToPoint(r, l), l.applyMatrix4(i);
		const c = n.ray.origin.distanceTo(l);
		if (c < n.near || c > n.far) return;
		a.push({
			distance: c,
			distanceToRay: Math.sqrt(o),
			point: l,
			index: e,
			face: null,
			object: s
		});
	}
}
class aS extends wt {
	constructor(e, t, i, n, a, s, o, l, c) {
		super(e, t, i, n, a, s, o, l, c),
		(this.minFilter = s !== void 0 ? s : Nt),
		(this.magFilter = a !== void 0 ? a : Nt),
		(this.generateMipmaps = !1);
		const u = this;
		function h() {
			(u.needsUpdate = !0), e.requestVideoFrameCallback(h);
		}
		'requestVideoFrameCallback' in e && e.requestVideoFrameCallback(h);
	}
	clone() {
		return new this.constructor(this.image).copy(this);
	}
	update() {
		const e = this.image;
		!('requestVideoFrameCallback' in e) &&
            e.readyState >= e.HAVE_CURRENT_DATA &&
            (this.needsUpdate = !0);
	}
}
aS.prototype.isVideoTexture = !0;
class sS extends wt {
	constructor(e, t, i) {
		super({ width: e, height: t }),
		(this.format = i),
		(this.magFilter = Mt),
		(this.minFilter = Mt),
		(this.generateMipmaps = !1),
		(this.needsUpdate = !0);
	}
}
sS.prototype.isFramebufferTexture = !0;
class oS extends wt {
	constructor(e, t, i, n, a, s, o, l, c, u, h, d) {
		super(null, s, o, l, c, u, n, a, h, d),
		(this.image = { width: t, height: i }),
		(this.mipmaps = e),
		(this.flipY = !1),
		(this.generateMipmaps = !1);
	}
}
oS.prototype.isCompressedTexture = !0;
class lS extends wt {
	constructor(e, t, i, n, a, s, o, l, c) {
		super(e, t, i, n, a, s, o, l, c), (this.needsUpdate = !0);
	}
}
lS.prototype.isCanvasTexture = !0;
class sr {
	constructor() {
		(this.type = 'Curve'), (this.arcLengthDivisions = 200);
	}
	getPoint() {
		return console.warn('THREE.Curve: .getPoint() not implemented.'), null;
	}
	getPointAt(e, t) {
		const i = this.getUtoTmapping(e);
		return this.getPoint(i, t);
	}
	getPoints(e = 5) {
		const t = [];
		for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
		return t;
	}
	getSpacedPoints(e = 5) {
		const t = [];
		for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
		return t;
	}
	getLength() {
		const e = this.getLengths();
		return e[e.length - 1];
	}
	getLengths(e = this.arcLengthDivisions) {
		if (
			this.cacheArcLengths &&
            this.cacheArcLengths.length === e + 1 &&
            !this.needsUpdate
		)
			return this.cacheArcLengths;
		this.needsUpdate = !1;
		const t = [];
		let i,
			n = this.getPoint(0),
			a = 0;
		t.push(0);
		for (let s = 1; s <= e; s++)
			(i = this.getPoint(s / e)),
			(a += i.distanceTo(n)),
			t.push(a),
			(n = i);
		return (this.cacheArcLengths = t), t;
	}
	updateArcLengths() {
		(this.needsUpdate = !0), this.getLengths();
	}
	getUtoTmapping(e, t) {
		const i = this.getLengths();
		let n = 0;
		const a = i.length;
		let s;
		t ? (s = t) : (s = e * i[a - 1]);
		let o = 0,
			l = a - 1,
			c;
		for (; o <= l; )
			if (((n = Math.floor(o + (l - o) / 2)), (c = i[n] - s), c < 0))
				o = n + 1;
			else if (c > 0) l = n - 1;
			else {
				l = n;
				break;
			}
		if (((n = l), i[n] === s)) return n / (a - 1);
		const u = i[n],
			h = i[n + 1] - u,
			d = (s - u) / h;
		return (n + d) / (a - 1);
	}
	getTangent(e, t) {
		let i = e - 1e-4,
			n = e + 1e-4;
		i < 0 && (i = 0), n > 1 && (n = 1);
		const a = this.getPoint(i),
			s = this.getPoint(n),
			o = t || (a.isVector2 ? new me() : new C());
		return o.copy(s).sub(a).normalize(), o;
	}
	getTangentAt(e, t) {
		const i = this.getUtoTmapping(e);
		return this.getTangent(i, t);
	}
	computeFrenetFrames(e, t) {
		const i = new C(),
			n = [],
			a = [],
			s = [],
			o = new C(),
			l = new Pe();
		for (let p = 0; p <= e; p++) {
			const g = p / e;
			n[p] = this.getTangentAt(g, new C());
		}
		(a[0] = new C()), (s[0] = new C());
		let c = Number.MAX_VALUE;
		const u = Math.abs(n[0].x),
			h = Math.abs(n[0].y),
			d = Math.abs(n[0].z);
		u <= c && ((c = u), i.set(1, 0, 0)),
		h <= c && ((c = h), i.set(0, 1, 0)),
		d <= c && i.set(0, 0, 1),
		o.crossVectors(n[0], i).normalize(),
		a[0].crossVectors(n[0], o),
		s[0].crossVectors(n[0], a[0]);
		for (let p = 1; p <= e; p++) {
			if (
				((a[p] = a[p - 1].clone()),
				(s[p] = s[p - 1].clone()),
				o.crossVectors(n[p - 1], n[p]),
				o.length() > Number.EPSILON)
			) {
				o.normalize();
				const g = Math.acos(Et(n[p - 1].dot(n[p]), -1, 1));
				a[p].applyMatrix4(l.makeRotationAxis(o, g));
			}
			s[p].crossVectors(n[p], a[p]);
		}
		if (t === !0) {
			let p = Math.acos(Et(a[0].dot(a[e]), -1, 1));
			(p /= e), n[0].dot(o.crossVectors(a[0], a[e])) > 0 && (p = -p);
			for (let g = 1; g <= e; g++)
				a[g].applyMatrix4(l.makeRotationAxis(n[g], p * g)),
				s[g].crossVectors(n[g], a[g]);
		}
		return { tangents: n, normals: a, binormals: s };
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(e) {
		return (this.arcLengthDivisions = e.arcLengthDivisions), this;
	}
	toJSON() {
		const e = {
			metadata: { version: 4.5, type: 'Curve', generator: 'Curve.toJSON' }
		};
		return (
			(e.arcLengthDivisions = this.arcLengthDivisions),
			(e.type = this.type),
			e
		);
	}
	fromJSON(e) {
		return (this.arcLengthDivisions = e.arcLengthDivisions), this;
	}
}
class hl extends sr {
	constructor(
		e = 0,
		t = 0,
		i = 1,
		n = 1,
		a = 0,
		s = Math.PI * 2,
		o = !1,
		l = 0
	) {
		super(),
		(this.type = 'EllipseCurve'),
		(this.aX = e),
		(this.aY = t),
		(this.xRadius = i),
		(this.yRadius = n),
		(this.aStartAngle = a),
		(this.aEndAngle = s),
		(this.aClockwise = o),
		(this.aRotation = l);
	}
	getPoint(e, t) {
		const i = t || new me(),
			n = Math.PI * 2;
		let a = this.aEndAngle - this.aStartAngle;
		const s = Math.abs(a) < Number.EPSILON;
		for (; a < 0; ) a += n;
		for (; a > n; ) a -= n;
		a < Number.EPSILON && (s ? (a = 0) : (a = n)),
		this.aClockwise === !0 && !s && (a === n ? (a = -n) : (a = a - n));
		const o = this.aStartAngle + e * a;
		let l = this.aX + this.xRadius * Math.cos(o),
			c = this.aY + this.yRadius * Math.sin(o);
		if (this.aRotation !== 0) {
			const u = Math.cos(this.aRotation),
				h = Math.sin(this.aRotation),
				d = l - this.aX,
				p = c - this.aY;
			(l = d * u - p * h + this.aX), (c = d * h + p * u + this.aY);
		}
		return i.set(l, c);
	}
	copy(e) {
		return (
			super.copy(e),
			(this.aX = e.aX),
			(this.aY = e.aY),
			(this.xRadius = e.xRadius),
			(this.yRadius = e.yRadius),
			(this.aStartAngle = e.aStartAngle),
			(this.aEndAngle = e.aEndAngle),
			(this.aClockwise = e.aClockwise),
			(this.aRotation = e.aRotation),
			this
		);
	}
	toJSON() {
		const e = super.toJSON();
		return (
			(e.aX = this.aX),
			(e.aY = this.aY),
			(e.xRadius = this.xRadius),
			(e.yRadius = this.yRadius),
			(e.aStartAngle = this.aStartAngle),
			(e.aEndAngle = this.aEndAngle),
			(e.aClockwise = this.aClockwise),
			(e.aRotation = this.aRotation),
			e
		);
	}
	fromJSON(e) {
		return (
			super.fromJSON(e),
			(this.aX = e.aX),
			(this.aY = e.aY),
			(this.xRadius = e.xRadius),
			(this.yRadius = e.yRadius),
			(this.aStartAngle = e.aStartAngle),
			(this.aEndAngle = e.aEndAngle),
			(this.aClockwise = e.aClockwise),
			(this.aRotation = e.aRotation),
			this
		);
	}
}
hl.prototype.isEllipseCurve = !0;
class eg extends hl {
	constructor(e, t, i, n, a, s) {
		super(e, t, i, i, n, a, s), (this.type = 'ArcCurve');
	}
}
eg.prototype.isArcCurve = !0;
function Vu() {
	let r = 0,
		e = 0,
		t = 0,
		i = 0;
	function n(a, s, o, l) {
		(r = a),
		(e = o),
		(t = -3 * a + 3 * s - 2 * o - l),
		(i = 2 * a - 2 * s + o + l);
	}
	return {
		initCatmullRom: function (a, s, o, l, c) {
			n(s, o, c * (o - a), c * (l - s));
		},
		initNonuniformCatmullRom: function (a, s, o, l, c, u, h) {
			let d = (s - a) / c - (o - a) / (c + u) + (o - s) / u,
				p = (o - s) / u - (l - s) / (u + h) + (l - o) / h;
			(d *= u), (p *= u), n(s, o, d, p);
		},
		calc: function (a) {
			const s = a * a,
				o = s * a;
			return r + e * a + t * s + i * o;
		}
	};
}
const po = new C(),
	sc = new Vu(),
	oc = new Vu(),
	lc = new Vu();
class tg extends sr {
	constructor(e = [], t = !1, i = 'centripetal', n = 0.5) {
		super(),
		(this.type = 'CatmullRomCurve3'),
		(this.points = e),
		(this.closed = t),
		(this.curveType = i),
		(this.tension = n);
	}
	getPoint(e, t = new C()) {
		const i = t,
			n = this.points,
			a = n.length,
			s = (a - (this.closed ? 0 : 1)) * e;
		let o = Math.floor(s),
			l = s - o;
		this.closed
			? (o += o > 0 ? 0 : (Math.floor(Math.abs(o) / a) + 1) * a)
			: l === 0 && o === a - 1 && ((o = a - 2), (l = 1));
		let c, u;
		this.closed || o > 0
			? (c = n[(o - 1) % a])
			: (po.subVectors(n[0], n[1]).add(n[0]), (c = po));
		const h = n[o % a],
			d = n[(o + 1) % a];
		if (
			(this.closed || o + 2 < a
				? (u = n[(o + 2) % a])
				: (po.subVectors(n[a - 1], n[a - 2]).add(n[a - 1]), (u = po)),
			this.curveType === 'centripetal' || this.curveType === 'chordal')
		) {
			const p = this.curveType === 'chordal' ? 0.5 : 0.25;
			let g = Math.pow(c.distanceToSquared(h), p),
				m = Math.pow(h.distanceToSquared(d), p),
				f = Math.pow(d.distanceToSquared(u), p);
			m < 1e-4 && (m = 1),
			g < 1e-4 && (g = m),
			f < 1e-4 && (f = m),
			sc.initNonuniformCatmullRom(c.x, h.x, d.x, u.x, g, m, f),
			oc.initNonuniformCatmullRom(c.y, h.y, d.y, u.y, g, m, f),
			lc.initNonuniformCatmullRom(c.z, h.z, d.z, u.z, g, m, f);
		} else
			this.curveType === 'catmullrom' &&
                (sc.initCatmullRom(c.x, h.x, d.x, u.x, this.tension),
                oc.initCatmullRom(c.y, h.y, d.y, u.y, this.tension),
                lc.initCatmullRom(c.z, h.z, d.z, u.z, this.tension));
		return i.set(sc.calc(l), oc.calc(l), lc.calc(l)), i;
	}
	copy(e) {
		super.copy(e), (this.points = []);
		for (let t = 0, i = e.points.length; t < i; t++) {
			const n = e.points[t];
			this.points.push(n.clone());
		}
		return (
			(this.closed = e.closed),
			(this.curveType = e.curveType),
			(this.tension = e.tension),
			this
		);
	}
	toJSON() {
		const e = super.toJSON();
		e.points = [];
		for (let t = 0, i = this.points.length; t < i; t++) {
			const n = this.points[t];
			e.points.push(n.toArray());
		}
		return (
			(e.closed = this.closed),
			(e.curveType = this.curveType),
			(e.tension = this.tension),
			e
		);
	}
	fromJSON(e) {
		super.fromJSON(e), (this.points = []);
		for (let t = 0, i = e.points.length; t < i; t++) {
			const n = e.points[t];
			this.points.push(new C().fromArray(n));
		}
		return (
			(this.closed = e.closed),
			(this.curveType = e.curveType),
			(this.tension = e.tension),
			this
		);
	}
}
tg.prototype.isCatmullRomCurve3 = !0;
function Ap(r, e, t, i, n) {
	const a = (i - e) * 0.5,
		s = (n - t) * 0.5,
		o = r * r,
		l = r * o;
	return (
		(2 * t - 2 * i + a + s) * l +
        (-3 * t + 3 * i - 2 * a - s) * o +
        a * r +
        t
	);
}
function cS(r, e) {
	const t = 1 - r;
	return t * t * e;
}
function uS(r, e) {
	return 2 * (1 - r) * r * e;
}
function hS(r, e) {
	return r * r * e;
}
function rs(r, e, t, i) {
	return cS(r, e) + uS(r, t) + hS(r, i);
}
function dS(r, e) {
	const t = 1 - r;
	return t * t * t * e;
}
function pS(r, e) {
	const t = 1 - r;
	return 3 * t * t * r * e;
}
function mS(r, e) {
	return 3 * (1 - r) * r * r * e;
}
function fS(r, e) {
	return r * r * r * e;
}
function is(r, e, t, i, n) {
	return dS(r, e) + pS(r, t) + mS(r, i) + fS(r, n);
}
class Wu extends sr {
	constructor(e = new me(), t = new me(), i = new me(), n = new me()) {
		super(),
		(this.type = 'CubicBezierCurve'),
		(this.v0 = e),
		(this.v1 = t),
		(this.v2 = i),
		(this.v3 = n);
	}
	getPoint(e, t = new me()) {
		const i = t,
			n = this.v0,
			a = this.v1,
			s = this.v2,
			o = this.v3;
		return i.set(is(e, n.x, a.x, s.x, o.x), is(e, n.y, a.y, s.y, o.y)), i;
	}
	copy(e) {
		return (
			super.copy(e),
			this.v0.copy(e.v0),
			this.v1.copy(e.v1),
			this.v2.copy(e.v2),
			this.v3.copy(e.v3),
			this
		);
	}
	toJSON() {
		const e = super.toJSON();
		return (
			(e.v0 = this.v0.toArray()),
			(e.v1 = this.v1.toArray()),
			(e.v2 = this.v2.toArray()),
			(e.v3 = this.v3.toArray()),
			e
		);
	}
	fromJSON(e) {
		return (
			super.fromJSON(e),
			this.v0.fromArray(e.v0),
			this.v1.fromArray(e.v1),
			this.v2.fromArray(e.v2),
			this.v3.fromArray(e.v3),
			this
		);
	}
}
Wu.prototype.isCubicBezierCurve = !0;
class rg extends sr {
	constructor(e = new C(), t = new C(), i = new C(), n = new C()) {
		super(),
		(this.type = 'CubicBezierCurve3'),
		(this.v0 = e),
		(this.v1 = t),
		(this.v2 = i),
		(this.v3 = n);
	}
	getPoint(e, t = new C()) {
		const i = t,
			n = this.v0,
			a = this.v1,
			s = this.v2,
			o = this.v3;
		return (
			i.set(
				is(e, n.x, a.x, s.x, o.x),
				is(e, n.y, a.y, s.y, o.y),
				is(e, n.z, a.z, s.z, o.z)
			),
			i
		);
	}
	copy(e) {
		return (
			super.copy(e),
			this.v0.copy(e.v0),
			this.v1.copy(e.v1),
			this.v2.copy(e.v2),
			this.v3.copy(e.v3),
			this
		);
	}
	toJSON() {
		const e = super.toJSON();
		return (
			(e.v0 = this.v0.toArray()),
			(e.v1 = this.v1.toArray()),
			(e.v2 = this.v2.toArray()),
			(e.v3 = this.v3.toArray()),
			e
		);
	}
	fromJSON(e) {
		return (
			super.fromJSON(e),
			this.v0.fromArray(e.v0),
			this.v1.fromArray(e.v1),
			this.v2.fromArray(e.v2),
			this.v3.fromArray(e.v3),
			this
		);
	}
}
rg.prototype.isCubicBezierCurve3 = !0;
class dl extends sr {
	constructor(e = new me(), t = new me()) {
		super(), (this.type = 'LineCurve'), (this.v1 = e), (this.v2 = t);
	}
	getPoint(e, t = new me()) {
		const i = t;
		return (
			e === 1
				? i.copy(this.v2)
				: (i.copy(this.v2).sub(this.v1),
				i.multiplyScalar(e).add(this.v1)),
			i
		);
	}
	getPointAt(e, t) {
		return this.getPoint(e, t);
	}
	getTangent(e, t) {
		const i = t || new me();
		return i.copy(this.v2).sub(this.v1).normalize(), i;
	}
	copy(e) {
		return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
	}
	toJSON() {
		const e = super.toJSON();
		return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
	}
	fromJSON(e) {
		return (
			super.fromJSON(e),
			this.v1.fromArray(e.v1),
			this.v2.fromArray(e.v2),
			this
		);
	}
}
dl.prototype.isLineCurve = !0;
class gS extends sr {
	constructor(e = new C(), t = new C()) {
		super(),
		(this.type = 'LineCurve3'),
		(this.isLineCurve3 = !0),
		(this.v1 = e),
		(this.v2 = t);
	}
	getPoint(e, t = new C()) {
		const i = t;
		return (
			e === 1
				? i.copy(this.v2)
				: (i.copy(this.v2).sub(this.v1),
				i.multiplyScalar(e).add(this.v1)),
			i
		);
	}
	getPointAt(e, t) {
		return this.getPoint(e, t);
	}
	copy(e) {
		return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
	}
	toJSON() {
		const e = super.toJSON();
		return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
	}
	fromJSON(e) {
		return (
			super.fromJSON(e),
			this.v1.fromArray(e.v1),
			this.v2.fromArray(e.v2),
			this
		);
	}
}
class ju extends sr {
	constructor(e = new me(), t = new me(), i = new me()) {
		super(),
		(this.type = 'QuadraticBezierCurve'),
		(this.v0 = e),
		(this.v1 = t),
		(this.v2 = i);
	}
	getPoint(e, t = new me()) {
		const i = t,
			n = this.v0,
			a = this.v1,
			s = this.v2;
		return i.set(rs(e, n.x, a.x, s.x), rs(e, n.y, a.y, s.y)), i;
	}
	copy(e) {
		return (
			super.copy(e),
			this.v0.copy(e.v0),
			this.v1.copy(e.v1),
			this.v2.copy(e.v2),
			this
		);
	}
	toJSON() {
		const e = super.toJSON();
		return (
			(e.v0 = this.v0.toArray()),
			(e.v1 = this.v1.toArray()),
			(e.v2 = this.v2.toArray()),
			e
		);
	}
	fromJSON(e) {
		return (
			super.fromJSON(e),
			this.v0.fromArray(e.v0),
			this.v1.fromArray(e.v1),
			this.v2.fromArray(e.v2),
			this
		);
	}
}
ju.prototype.isQuadraticBezierCurve = !0;
class ig extends sr {
	constructor(e = new C(), t = new C(), i = new C()) {
		super(),
		(this.type = 'QuadraticBezierCurve3'),
		(this.v0 = e),
		(this.v1 = t),
		(this.v2 = i);
	}
	getPoint(e, t = new C()) {
		const i = t,
			n = this.v0,
			a = this.v1,
			s = this.v2;
		return (
			i.set(
				rs(e, n.x, a.x, s.x),
				rs(e, n.y, a.y, s.y),
				rs(e, n.z, a.z, s.z)
			),
			i
		);
	}
	copy(e) {
		return (
			super.copy(e),
			this.v0.copy(e.v0),
			this.v1.copy(e.v1),
			this.v2.copy(e.v2),
			this
		);
	}
	toJSON() {
		const e = super.toJSON();
		return (
			(e.v0 = this.v0.toArray()),
			(e.v1 = this.v1.toArray()),
			(e.v2 = this.v2.toArray()),
			e
		);
	}
	fromJSON(e) {
		return (
			super.fromJSON(e),
			this.v0.fromArray(e.v0),
			this.v1.fromArray(e.v1),
			this.v2.fromArray(e.v2),
			this
		);
	}
}
ig.prototype.isQuadraticBezierCurve3 = !0;
class Xu extends sr {
	constructor(e = []) {
		super(), (this.type = 'SplineCurve'), (this.points = e);
	}
	getPoint(e, t = new me()) {
		const i = t,
			n = this.points,
			a = (n.length - 1) * e,
			s = Math.floor(a),
			o = a - s,
			l = n[s === 0 ? s : s - 1],
			c = n[s],
			u = n[s > n.length - 2 ? n.length - 1 : s + 1],
			h = n[s > n.length - 3 ? n.length - 1 : s + 2];
		return i.set(Ap(o, l.x, c.x, u.x, h.x), Ap(o, l.y, c.y, u.y, h.y)), i;
	}
	copy(e) {
		super.copy(e), (this.points = []);
		for (let t = 0, i = e.points.length; t < i; t++) {
			const n = e.points[t];
			this.points.push(n.clone());
		}
		return this;
	}
	toJSON() {
		const e = super.toJSON();
		e.points = [];
		for (let t = 0, i = this.points.length; t < i; t++) {
			const n = this.points[t];
			e.points.push(n.toArray());
		}
		return e;
	}
	fromJSON(e) {
		super.fromJSON(e), (this.points = []);
		for (let t = 0, i = e.points.length; t < i; t++) {
			const n = e.points[t];
			this.points.push(new me().fromArray(n));
		}
		return this;
	}
}
Xu.prototype.isSplineCurve = !0;
var ng = Object.freeze({
	__proto__: null,
	ArcCurve: eg,
	CatmullRomCurve3: tg,
	CubicBezierCurve: Wu,
	CubicBezierCurve3: rg,
	EllipseCurve: hl,
	LineCurve: dl,
	LineCurve3: gS,
	QuadraticBezierCurve: ju,
	QuadraticBezierCurve3: ig,
	SplineCurve: Xu
});
class vS extends sr {
	constructor() {
		super(),
		(this.type = 'CurvePath'),
		(this.curves = []),
		(this.autoClose = !1);
	}
	add(e) {
		this.curves.push(e);
	}
	closePath() {
		const e = this.curves[0].getPoint(0),
			t = this.curves[this.curves.length - 1].getPoint(1);
		e.equals(t) || this.curves.push(new dl(t, e));
	}
	getPoint(e, t) {
		const i = e * this.getLength(),
			n = this.getCurveLengths();
		let a = 0;
		for (; a < n.length; ) {
			if (n[a] >= i) {
				const s = n[a] - i,
					o = this.curves[a],
					l = o.getLength(),
					c = l === 0 ? 0 : 1 - s / l;
				return o.getPointAt(c, t);
			}
			a++;
		}
		return null;
	}
	getLength() {
		const e = this.getCurveLengths();
		return e[e.length - 1];
	}
	updateArcLengths() {
		(this.needsUpdate = !0),
		(this.cacheLengths = null),
		this.getCurveLengths();
	}
	getCurveLengths() {
		if (
			this.cacheLengths &&
            this.cacheLengths.length === this.curves.length
		)
			return this.cacheLengths;
		const e = [];
		let t = 0;
		for (let i = 0, n = this.curves.length; i < n; i++)
			(t += this.curves[i].getLength()), e.push(t);
		return (this.cacheLengths = e), e;
	}
	getSpacedPoints(e = 40) {
		const t = [];
		for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
		return this.autoClose && t.push(t[0]), t;
	}
	getPoints(e = 12) {
		const t = [];
		let i;
		for (let n = 0, a = this.curves; n < a.length; n++) {
			const s = a[n],
				o = s.isEllipseCurve
					? e * 2
					: s.isLineCurve || s.isLineCurve3
						? 1
						: s.isSplineCurve
							? e * s.points.length
							: e,
				l = s.getPoints(o);
			for (let c = 0; c < l.length; c++) {
				const u = l[c];
				(i && i.equals(u)) || (t.push(u), (i = u));
			}
		}
		return (
			this.autoClose &&
                t.length > 1 &&
                !t[t.length - 1].equals(t[0]) &&
                t.push(t[0]),
			t
		);
	}
	copy(e) {
		super.copy(e), (this.curves = []);
		for (let t = 0, i = e.curves.length; t < i; t++) {
			const n = e.curves[t];
			this.curves.push(n.clone());
		}
		return (this.autoClose = e.autoClose), this;
	}
	toJSON() {
		const e = super.toJSON();
		(e.autoClose = this.autoClose), (e.curves = []);
		for (let t = 0, i = this.curves.length; t < i; t++) {
			const n = this.curves[t];
			e.curves.push(n.toJSON());
		}
		return e;
	}
	fromJSON(e) {
		super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
		for (let t = 0, i = e.curves.length; t < i; t++) {
			const n = e.curves[t];
			this.curves.push(new ng[n.type]().fromJSON(n));
		}
		return this;
	}
}
class Zc extends vS {
	constructor(e) {
		super(),
		(this.type = 'Path'),
		(this.currentPoint = new me()),
		e && this.setFromPoints(e);
	}
	setFromPoints(e) {
		this.moveTo(e[0].x, e[0].y);
		for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y);
		return this;
	}
	moveTo(e, t) {
		return this.currentPoint.set(e, t), this;
	}
	lineTo(e, t) {
		const i = new dl(this.currentPoint.clone(), new me(e, t));
		return this.curves.push(i), this.currentPoint.set(e, t), this;
	}
	quadraticCurveTo(e, t, i, n) {
		const a = new ju(this.currentPoint.clone(), new me(e, t), new me(i, n));
		return this.curves.push(a), this.currentPoint.set(i, n), this;
	}
	bezierCurveTo(e, t, i, n, a, s) {
		const o = new Wu(
			this.currentPoint.clone(),
			new me(e, t),
			new me(i, n),
			new me(a, s)
		);
		return this.curves.push(o), this.currentPoint.set(a, s), this;
	}
	splineThru(e) {
		const t = [this.currentPoint.clone()].concat(e),
			i = new Xu(t);
		return (
			this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this
		);
	}
	arc(e, t, i, n, a, s) {
		const o = this.currentPoint.x,
			l = this.currentPoint.y;
		return this.absarc(e + o, t + l, i, n, a, s), this;
	}
	absarc(e, t, i, n, a, s) {
		return this.absellipse(e, t, i, i, n, a, s), this;
	}
	ellipse(e, t, i, n, a, s, o, l) {
		const c = this.currentPoint.x,
			u = this.currentPoint.y;
		return this.absellipse(e + c, t + u, i, n, a, s, o, l), this;
	}
	absellipse(e, t, i, n, a, s, o, l) {
		const c = new hl(e, t, i, n, a, s, o, l);
		if (this.curves.length > 0) {
			const h = c.getPoint(0);
			h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
		}
		this.curves.push(c);
		const u = c.getPoint(1);
		return this.currentPoint.copy(u), this;
	}
	copy(e) {
		return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
	}
	toJSON() {
		const e = super.toJSON();
		return (e.currentPoint = this.currentPoint.toArray()), e;
	}
	fromJSON(e) {
		return (
			super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
		);
	}
}
new C();
new C();
new C();
new vt();
class Ls extends Zc {
	constructor(e) {
		super(e), (this.uuid = ir()), (this.type = 'Shape'), (this.holes = []);
	}
	getPointsHoles(e) {
		const t = [];
		for (let i = 0, n = this.holes.length; i < n; i++)
			t[i] = this.holes[i].getPoints(e);
		return t;
	}
	extractPoints(e) {
		return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
	}
	copy(e) {
		super.copy(e), (this.holes = []);
		for (let t = 0, i = e.holes.length; t < i; t++) {
			const n = e.holes[t];
			this.holes.push(n.clone());
		}
		return this;
	}
	toJSON() {
		const e = super.toJSON();
		(e.uuid = this.uuid), (e.holes = []);
		for (let t = 0, i = this.holes.length; t < i; t++) {
			const n = this.holes[t];
			e.holes.push(n.toJSON());
		}
		return e;
	}
	fromJSON(e) {
		super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
		for (let t = 0, i = e.holes.length; t < i; t++) {
			const n = e.holes[t];
			this.holes.push(new Zc().fromJSON(n));
		}
		return this;
	}
}
const yS = {
	triangulate: function (r, e, t = 2) {
		const i = e && e.length,
			n = i ? e[0] * t : r.length;
		let a = ag(r, 0, n, t, !0);
		const s = [];
		if (!a || a.next === a.prev) return s;
		let o, l, c, u, h, d, p;
		if ((i && (a = MS(r, e, a, t)), r.length > 80 * t)) {
			(o = c = r[0]), (l = u = r[1]);
			for (let g = t; g < n; g += t)
				(h = r[g]),
				(d = r[g + 1]),
				h < o && (o = h),
				d < l && (l = d),
				h > c && (c = h),
				d > u && (u = d);
			(p = Math.max(c - o, u - l)), (p = p !== 0 ? 1 / p : 0);
		}
		return xs(a, s, t, o, l, p), s;
	}
};
function ag(r, e, t, i, n) {
	let a, s;
	if (n === DS(r, e, t, i) > 0)
		for (a = e; a < t; a += i) s = Lp(a, r[a], r[a + 1], s);
	else for (a = t - i; a >= e; a -= i) s = Lp(a, r[a], r[a + 1], s);
	return s && pl(s, s.next) && (ws(s), (s = s.next)), s;
}
function Pi(r, e) {
	if (!r) return r;
	e || (e = r);
	let t = r,
		i;
	do
		if (
			((i = !1),
			!t.steiner && (pl(t, t.next) || ut(t.prev, t, t.next) === 0))
		) {
			if ((ws(t), (t = e = t.prev), t === t.next)) break;
			i = !0;
		} else t = t.next;
	while (i || t !== e);
	return e;
}
function xs(r, e, t, i, n, a, s) {
	if (!r) return;
	!s && a && LS(r, i, n, a);
	let o = r,
		l,
		c;
	for (; r.prev !== r.next; ) {
		if (((l = r.prev), (c = r.next), a ? bS(r, i, n, a) : xS(r))) {
			e.push(l.i / t),
			e.push(r.i / t),
			e.push(c.i / t),
			ws(r),
			(r = c.next),
			(o = c.next);
			continue;
		}
		if (((r = c), r === o)) {
			s
				? s === 1
					? ((r = wS(Pi(r), e, t)), xs(r, e, t, i, n, a, 2))
					: s === 2 && _S(r, e, t, i, n, a)
				: xs(Pi(r), e, t, i, n, a, 1);
			break;
		}
	}
}
function xS(r) {
	const e = r.prev,
		t = r,
		i = r.next;
	if (ut(e, t, i) >= 0) return !1;
	let n = r.next.next;
	for (; n !== r.prev; ) {
		if (
			Zn(e.x, e.y, t.x, t.y, i.x, i.y, n.x, n.y) &&
            ut(n.prev, n, n.next) >= 0
		)
			return !1;
		n = n.next;
	}
	return !0;
}
function bS(r, e, t, i) {
	const n = r.prev,
		a = r,
		s = r.next;
	if (ut(n, a, s) >= 0) return !1;
	const o = n.x < a.x ? (n.x < s.x ? n.x : s.x) : a.x < s.x ? a.x : s.x,
		l = n.y < a.y ? (n.y < s.y ? n.y : s.y) : a.y < s.y ? a.y : s.y,
		c = n.x > a.x ? (n.x > s.x ? n.x : s.x) : a.x > s.x ? a.x : s.x,
		u = n.y > a.y ? (n.y > s.y ? n.y : s.y) : a.y > s.y ? a.y : s.y,
		h = $c(o, l, e, t, i),
		d = $c(c, u, e, t, i);
	let p = r.prevZ,
		g = r.nextZ;
	for (; p && p.z >= h && g && g.z <= d; ) {
		if (
			(p !== r.prev &&
                p !== r.next &&
                Zn(n.x, n.y, a.x, a.y, s.x, s.y, p.x, p.y) &&
                ut(p.prev, p, p.next) >= 0) ||
            ((p = p.prevZ),
            g !== r.prev &&
                g !== r.next &&
                Zn(n.x, n.y, a.x, a.y, s.x, s.y, g.x, g.y) &&
                ut(g.prev, g, g.next) >= 0)
		)
			return !1;
		g = g.nextZ;
	}
	for (; p && p.z >= h; ) {
		if (
			p !== r.prev &&
            p !== r.next &&
            Zn(n.x, n.y, a.x, a.y, s.x, s.y, p.x, p.y) &&
            ut(p.prev, p, p.next) >= 0
		)
			return !1;
		p = p.prevZ;
	}
	for (; g && g.z <= d; ) {
		if (
			g !== r.prev &&
            g !== r.next &&
            Zn(n.x, n.y, a.x, a.y, s.x, s.y, g.x, g.y) &&
            ut(g.prev, g, g.next) >= 0
		)
			return !1;
		g = g.nextZ;
	}
	return !0;
}
function wS(r, e, t) {
	let i = r;
	do {
		const n = i.prev,
			a = i.next.next;
		!pl(n, a) &&
            sg(n, i, i.next, a) &&
            bs(n, a) &&
            bs(a, n) &&
            (e.push(n.i / t),
            e.push(i.i / t),
            e.push(a.i / t),
            ws(i),
            ws(i.next),
            (i = r = a)),
		(i = i.next);
	} while (i !== r);
	return Pi(i);
}
function _S(r, e, t, i, n, a) {
	let s = r;
	do {
		let o = s.next.next;
		for (; o !== s.prev; ) {
			if (s.i !== o.i && CS(s, o)) {
				let l = og(s, o);
				(s = Pi(s, s.next)),
				(l = Pi(l, l.next)),
				xs(s, e, t, i, n, a),
				xs(l, e, t, i, n, a);
				return;
			}
			o = o.next;
		}
		s = s.next;
	} while (s !== r);
}
function MS(r, e, t, i) {
	const n = [];
	let a, s, o, l, c;
	for (a = 0, s = e.length; a < s; a++)
		(o = e[a] * i),
		(l = a < s - 1 ? e[a + 1] * i : r.length),
		(c = ag(r, o, l, i, !1)),
		c === c.next && (c.steiner = !0),
		n.push(kS(c));
	for (n.sort(SS), a = 0; a < n.length; a++) TS(n[a], t), (t = Pi(t, t.next));
	return t;
}
function SS(r, e) {
	return r.x - e.x;
}
function TS(r, e) {
	if (((e = ES(r, e)), e)) {
		const t = og(e, r);
		Pi(e, e.next), Pi(t, t.next);
	}
}
function ES(r, e) {
	let t = e;
	const i = r.x,
		n = r.y;
	let a = -1 / 0,
		s;
	do {
		if (n <= t.y && n >= t.next.y && t.next.y !== t.y) {
			const d = t.x + ((n - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
			if (d <= i && d > a) {
				if (((a = d), d === i)) {
					if (n === t.y) return t;
					if (n === t.next.y) return t.next;
				}
				s = t.x < t.next.x ? t : t.next;
			}
		}
		t = t.next;
	} while (t !== e);
	if (!s) return null;
	if (i === a) return s;
	const o = s,
		l = s.x,
		c = s.y;
	let u = 1 / 0,
		h;
	t = s;
	do
		i >= t.x &&
            t.x >= l &&
            i !== t.x &&
            Zn(n < c ? i : a, n, l, c, n < c ? a : i, n, t.x, t.y) &&
            ((h = Math.abs(n - t.y) / (i - t.x)),
            bs(t, r) &&
                (h < u ||
                    (h === u && (t.x > s.x || (t.x === s.x && AS(s, t))))) &&
                ((s = t), (u = h))),
		(t = t.next);
	while (t !== o);
	return s;
}
function AS(r, e) {
	return ut(r.prev, r, e.prev) < 0 && ut(e.next, r, r.next) < 0;
}
function LS(r, e, t, i) {
	let n = r;
	do
		n.z === null && (n.z = $c(n.x, n.y, e, t, i)),
		(n.prevZ = n.prev),
		(n.nextZ = n.next),
		(n = n.next);
	while (n !== r);
	(n.prevZ.nextZ = null), (n.prevZ = null), RS(n);
}
function RS(r) {
	let e,
		t,
		i,
		n,
		a,
		s,
		o,
		l,
		c = 1;
	do {
		for (t = r, r = null, a = null, s = 0; t; ) {
			for (
				s++, i = t, o = 0, e = 0;
				e < c && (o++, (i = i.nextZ), !!i);
				e++
			);
			for (l = c; o > 0 || (l > 0 && i); )
				o !== 0 && (l === 0 || !i || t.z <= i.z)
					? ((n = t), (t = t.nextZ), o--)
					: ((n = i), (i = i.nextZ), l--),
				a ? (a.nextZ = n) : (r = n),
				(n.prevZ = a),
				(a = n);
			t = i;
		}
		(a.nextZ = null), (c *= 2);
	} while (s > 1);
	return r;
}
function $c(r, e, t, i, n) {
	return (
		(r = 32767 * (r - t) * n),
		(e = 32767 * (e - i) * n),
		(r = (r | (r << 8)) & 16711935),
		(r = (r | (r << 4)) & 252645135),
		(r = (r | (r << 2)) & 858993459),
		(r = (r | (r << 1)) & 1431655765),
		(e = (e | (e << 8)) & 16711935),
		(e = (e | (e << 4)) & 252645135),
		(e = (e | (e << 2)) & 858993459),
		(e = (e | (e << 1)) & 1431655765),
		r | (e << 1)
	);
}
function kS(r) {
	let e = r,
		t = r;
	do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
	while (e !== r);
	return t;
}
function Zn(r, e, t, i, n, a, s, o) {
	return (
		(n - s) * (e - o) - (r - s) * (a - o) >= 0 &&
        (r - s) * (i - o) - (t - s) * (e - o) >= 0 &&
        (t - s) * (a - o) - (n - s) * (i - o) >= 0
	);
}
function CS(r, e) {
	return (
		r.next.i !== e.i &&
        r.prev.i !== e.i &&
        !PS(r, e) &&
        ((bs(r, e) &&
            bs(e, r) &&
            IS(r, e) &&
            (ut(r.prev, r, e.prev) || ut(r, e.prev, e))) ||
            (pl(r, e) &&
                ut(r.prev, r, r.next) > 0 &&
                ut(e.prev, e, e.next) > 0))
	);
}
function ut(r, e, t) {
	return (e.y - r.y) * (t.x - e.x) - (e.x - r.x) * (t.y - e.y);
}
function pl(r, e) {
	return r.x === e.x && r.y === e.y;
}
function sg(r, e, t, i) {
	const n = fo(ut(r, e, t)),
		a = fo(ut(r, e, i)),
		s = fo(ut(t, i, r)),
		o = fo(ut(t, i, e));
	return !!(
		(n !== a && s !== o) ||
        (n === 0 && mo(r, t, e)) ||
        (a === 0 && mo(r, i, e)) ||
        (s === 0 && mo(t, r, i)) ||
        (o === 0 && mo(t, e, i))
	);
}
function mo(r, e, t) {
	return (
		e.x <= Math.max(r.x, t.x) &&
        e.x >= Math.min(r.x, t.x) &&
        e.y <= Math.max(r.y, t.y) &&
        e.y >= Math.min(r.y, t.y)
	);
}
function fo(r) {
	return r > 0 ? 1 : r < 0 ? -1 : 0;
}
function PS(r, e) {
	let t = r;
	do {
		if (
			t.i !== r.i &&
            t.next.i !== r.i &&
            t.i !== e.i &&
            t.next.i !== e.i &&
            sg(t, t.next, r, e)
		)
			return !0;
		t = t.next;
	} while (t !== r);
	return !1;
}
function bs(r, e) {
	return ut(r.prev, r, r.next) < 0
		? ut(r, e, r.next) >= 0 && ut(r, r.prev, e) >= 0
		: ut(r, e, r.prev) < 0 || ut(r, r.next, e) < 0;
}
function IS(r, e) {
	let t = r,
		i = !1;
	const n = (r.x + e.x) / 2,
		a = (r.y + e.y) / 2;
	do
		t.y > a != t.next.y > a &&
            t.next.y !== t.y &&
            n < ((t.next.x - t.x) * (a - t.y)) / (t.next.y - t.y) + t.x &&
            (i = !i),
		(t = t.next);
	while (t !== r);
	return i;
}
function og(r, e) {
	const t = new Kc(r.i, r.x, r.y),
		i = new Kc(e.i, e.x, e.y),
		n = r.next,
		a = e.prev;
	return (
		(r.next = e),
		(e.prev = r),
		(t.next = n),
		(n.prev = t),
		(i.next = t),
		(t.prev = i),
		(a.next = i),
		(i.prev = a),
		i
	);
}
function Lp(r, e, t, i) {
	const n = new Kc(r, e, t);
	return (
		i
			? ((n.next = i.next), (n.prev = i), (i.next.prev = n), (i.next = n))
			: ((n.prev = n), (n.next = n)),
		n
	);
}
function ws(r) {
	(r.next.prev = r.prev),
	(r.prev.next = r.next),
	r.prevZ && (r.prevZ.nextZ = r.nextZ),
	r.nextZ && (r.nextZ.prevZ = r.prevZ);
}
function Kc(r, e, t) {
	(this.i = r),
	(this.x = e),
	(this.y = t),
	(this.prev = null),
	(this.next = null),
	(this.z = null),
	(this.prevZ = null),
	(this.nextZ = null),
	(this.steiner = !1);
}
function DS(r, e, t, i) {
	let n = 0;
	for (let a = e, s = t - i; a < t; a += i)
		(n += (r[s] - r[a]) * (r[a + 1] + r[s + 1])), (s = a);
	return n;
}
class Li {
	static area(e) {
		const t = e.length;
		let i = 0;
		for (let n = t - 1, a = 0; a < t; n = a++)
			i += e[n].x * e[a].y - e[a].x * e[n].y;
		return i * 0.5;
	}
	static isClockWise(e) {
		return Li.area(e) < 0;
	}
	static triangulateShape(e, t) {
		const i = [],
			n = [],
			a = [];
		Rp(e), kp(i, e);
		let s = e.length;
		t.forEach(Rp);
		for (let l = 0; l < t.length; l++)
			n.push(s), (s += t[l].length), kp(i, t[l]);
		const o = yS.triangulate(i, n);
		for (let l = 0; l < o.length; l += 3) a.push(o.slice(l, l + 3));
		return a;
	}
}
function Rp(r) {
	const e = r.length;
	e > 2 && r[e - 1].equals(r[0]) && r.pop();
}
function kp(r, e) {
	for (let t = 0; t < e.length; t++) r.push(e[t].x), r.push(e[t].y);
}
class Ta extends ot {
	constructor(
		e = new Ls([
			new me(0.5, 0.5),
			new me(-0.5, 0.5),
			new me(-0.5, -0.5),
			new me(0.5, -0.5)
		]),
		t = {}
	) {
		super(),
		(this.type = 'ExtrudeGeometry'),
		(this.parameters = { shapes: e, options: t }),
		(e = Array.isArray(e) ? e : [e]);
		const i = this,
			n = [],
			a = [];
		for (let o = 0, l = e.length; o < l; o++) {
			const c = e[o];
			s(c);
		}
		this.setAttribute('position', new yt(n, 3)),
		this.setAttribute('uv', new yt(a, 2)),
		this.computeVertexNormals();
		function s(o) {
			const l = [],
				c = t.curveSegments !== void 0 ? t.curveSegments : 12,
				u = t.steps !== void 0 ? t.steps : 1;
			let h = t.depth !== void 0 ? t.depth : 1,
				d = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
				p = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
				g = t.bevelSize !== void 0 ? t.bevelSize : p - 0.1,
				m = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
				f = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
			const v = t.extrudePath,
				x = t.UVGenerator !== void 0 ? t.UVGenerator : OS;
			t.amount !== void 0 &&
                (console.warn(
                	'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.'
                ),
                (h = t.amount));
			let A,
				S = !1,
				M,
				I,
				D,
				G;
			v &&
                ((A = v.getSpacedPoints(u)),
                (S = !0),
                (d = !1),
                (M = v.computeFrenetFrames(u, !1)),
                (I = new C()),
                (D = new C()),
                (G = new C())),
			d || ((f = 0), (p = 0), (g = 0), (m = 0));
			const re = o.extractPoints(c);
			let B = re.shape;
			const b = re.holes;
			if (!Li.isClockWise(B)) {
				B = B.reverse();
				for (let K = 0, te = b.length; K < te; K++) {
					const w = b[K];
					Li.isClockWise(w) && (b[K] = w.reverse());
				}
			}
			const E = Li.triangulateShape(B, b),
				j = B;
			for (let K = 0, te = b.length; K < te; K++) {
				const w = b[K];
				B = B.concat(w);
			}
			function z(K, te, w) {
				return (
					te ||
                        console.error(
                        	'THREE.ExtrudeGeometry: vec does not exist'
                        ),
					te.clone().multiplyScalar(w).add(K)
				);
			}
			const V = B.length,
				H = E.length;
			function k(K, te, w) {
				let R, N, q;
				const $ = K.x - te.x,
					ne = K.y - te.y,
					le = w.x - K.x,
					he = w.y - K.y,
					ge = $ * $ + ne * ne,
					_ = $ * he - ne * le;
				if (Math.abs(_) > Number.EPSILON) {
					const y = Math.sqrt(ge),
						F = Math.sqrt(le * le + he * he),
						Y = te.x - ne / y,
						oe = te.y + $ / y,
						pe = w.x - he / F,
						Me = w.y + le / F,
						T =
                            ((pe - Y) * he - (Me - oe) * le) /
                            ($ * he - ne * le);
					(R = Y + $ * T - K.x), (N = oe + ne * T - K.y);
					const se = R * R + N * N;
					if (se <= 2) return new me(R, N);
					q = Math.sqrt(se / 2);
				} else {
					let y = !1;
					$ > Number.EPSILON
						? le > Number.EPSILON && (y = !0)
						: $ < -Number.EPSILON
							? le < -Number.EPSILON && (y = !0)
							: Math.sign(ne) === Math.sign(he) && (y = !0),
					y
						? ((R = -ne), (N = $), (q = Math.sqrt(ge)))
						: ((R = $), (N = ne), (q = Math.sqrt(ge / 2)));
				}
				return new me(R / q, N / q);
			}
			const P = [];
			for (
				let K = 0, te = j.length, w = te - 1, R = K + 1;
				K < te;
				K++, w++, R++
			)
				w === te && (w = 0),
				R === te && (R = 0),
				(P[K] = k(j[K], j[w], j[R]));
			const Z = [];
			let J,
				fe = P.concat();
			for (let K = 0, te = b.length; K < te; K++) {
				const w = b[K];
				J = [];
				for (
					let R = 0, N = w.length, q = N - 1, $ = R + 1;
					R < N;
					R++, q++, $++
				)
					q === N && (q = 0),
					$ === N && ($ = 0),
					(J[R] = k(w[R], w[q], w[$]));
				Z.push(J), (fe = fe.concat(J));
			}
			for (let K = 0; K < f; K++) {
				const te = K / f,
					w = p * Math.cos((te * Math.PI) / 2),
					R = g * Math.sin((te * Math.PI) / 2) + m;
				for (let N = 0, q = j.length; N < q; N++) {
					const $ = z(j[N], P[N], R);
					U($.x, $.y, -w);
				}
				for (let N = 0, q = b.length; N < q; N++) {
					const $ = b[N];
					J = Z[N];
					for (let ne = 0, le = $.length; ne < le; ne++) {
						const he = z($[ne], J[ne], R);
						U(he.x, he.y, -w);
					}
				}
			}
			const ce = g + m;
			for (let K = 0; K < V; K++) {
				const te = d ? z(B[K], fe[K], ce) : B[K];
				S
					? (D.copy(M.normals[0]).multiplyScalar(te.x),
					I.copy(M.binormals[0]).multiplyScalar(te.y),
					G.copy(A[0]).add(D).add(I),
					U(G.x, G.y, G.z))
					: U(te.x, te.y, 0);
			}
			for (let K = 1; K <= u; K++)
				for (let te = 0; te < V; te++) {
					const w = d ? z(B[te], fe[te], ce) : B[te];
					S
						? (D.copy(M.normals[K]).multiplyScalar(w.x),
						I.copy(M.binormals[K]).multiplyScalar(w.y),
						G.copy(A[K]).add(D).add(I),
						U(G.x, G.y, G.z))
						: U(w.x, w.y, (h / u) * K);
				}
			for (let K = f - 1; K >= 0; K--) {
				const te = K / f,
					w = p * Math.cos((te * Math.PI) / 2),
					R = g * Math.sin((te * Math.PI) / 2) + m;
				for (let N = 0, q = j.length; N < q; N++) {
					const $ = z(j[N], P[N], R);
					U($.x, $.y, h + w);
				}
				for (let N = 0, q = b.length; N < q; N++) {
					const $ = b[N];
					J = Z[N];
					for (let ne = 0, le = $.length; ne < le; ne++) {
						const he = z($[ne], J[ne], R);
						S
							? U(he.x, he.y + A[u - 1].y, A[u - 1].x + w)
							: U(he.x, he.y, h + w);
					}
				}
			}
			xe(), W();
			function xe() {
				const K = n.length / 3;
				if (d) {
					let te = 0,
						w = V * te;
					for (let R = 0; R < H; R++) {
						const N = E[R];
						ve(N[2] + w, N[1] + w, N[0] + w);
					}
					(te = u + f * 2), (w = V * te);
					for (let R = 0; R < H; R++) {
						const N = E[R];
						ve(N[0] + w, N[1] + w, N[2] + w);
					}
				} else {
					for (let te = 0; te < H; te++) {
						const w = E[te];
						ve(w[2], w[1], w[0]);
					}
					for (let te = 0; te < H; te++) {
						const w = E[te];
						ve(w[0] + V * u, w[1] + V * u, w[2] + V * u);
					}
				}
				i.addGroup(K, n.length / 3 - K, 0);
			}
			function W() {
				const K = n.length / 3;
				let te = 0;
				ue(j, te), (te += j.length);
				for (let w = 0, R = b.length; w < R; w++) {
					const N = b[w];
					ue(N, te), (te += N.length);
				}
				i.addGroup(K, n.length / 3 - K, 1);
			}
			function ue(K, te) {
				let w = K.length;
				for (; --w >= 0; ) {
					const R = w;
					let N = w - 1;
					N < 0 && (N = K.length - 1);
					for (let q = 0, $ = u + f * 2; q < $; q++) {
						const ne = V * q,
							le = V * (q + 1),
							he = te + R + ne,
							ge = te + N + ne,
							_ = te + N + le,
							y = te + R + le;
						Ae(he, ge, _, y);
					}
				}
			}
			function U(K, te, w) {
				l.push(K), l.push(te), l.push(w);
			}
			function ve(K, te, w) {
				Te(K), Te(te), Te(w);
				const R = n.length / 3,
					N = x.generateTopUV(i, n, R - 3, R - 2, R - 1);
				ae(N[0]), ae(N[1]), ae(N[2]);
			}
			function Ae(K, te, w, R) {
				Te(K), Te(te), Te(R), Te(te), Te(w), Te(R);
				const N = n.length / 3,
					q = x.generateSideWallUV(i, n, N - 6, N - 3, N - 2, N - 1);
				ae(q[0]), ae(q[1]), ae(q[3]), ae(q[1]), ae(q[2]), ae(q[3]);
			}
			function Te(K) {
				n.push(l[K * 3 + 0]),
				n.push(l[K * 3 + 1]),
				n.push(l[K * 3 + 2]);
			}
			function ae(K) {
				a.push(K.x), a.push(K.y);
			}
		}
	}
	toJSON() {
		const e = super.toJSON(),
			t = this.parameters.shapes,
			i = this.parameters.options;
		return NS(t, i, e);
	}
	static fromJSON(e, t) {
		const i = [];
		for (let a = 0, s = e.shapes.length; a < s; a++) {
			const o = t[e.shapes[a]];
			i.push(o);
		}
		const n = e.options.extrudePath;
		return (
			n !== void 0 &&
                (e.options.extrudePath = new ng[n.type]().fromJSON(n)),
			new Ta(i, e.options)
		);
	}
}
const OS = {
	generateTopUV: function (r, e, t, i, n) {
		const a = e[t * 3],
			s = e[t * 3 + 1],
			o = e[i * 3],
			l = e[i * 3 + 1],
			c = e[n * 3],
			u = e[n * 3 + 1];
		return [new me(a, s), new me(o, l), new me(c, u)];
	},
	generateSideWallUV: function (r, e, t, i, n, a) {
		const s = e[t * 3],
			o = e[t * 3 + 1],
			l = e[t * 3 + 2],
			c = e[i * 3],
			u = e[i * 3 + 1],
			h = e[i * 3 + 2],
			d = e[n * 3],
			p = e[n * 3 + 1],
			g = e[n * 3 + 2],
			m = e[a * 3],
			f = e[a * 3 + 1],
			v = e[a * 3 + 2];
		return Math.abs(o - u) < Math.abs(s - c)
			? [
				new me(s, 1 - l),
				new me(c, 1 - h),
				new me(d, 1 - g),
				new me(m, 1 - v)
			]
			: [
				new me(o, 1 - l),
				new me(u, 1 - h),
				new me(p, 1 - g),
				new me(f, 1 - v)
			];
	}
};
function NS(r, e, t) {
	if (((t.shapes = []), Array.isArray(r)))
		for (let i = 0, n = r.length; i < n; i++) {
			const a = r[i];
			t.shapes.push(a.uuid);
		}
	else t.shapes.push(r.uuid);
	return (
		e.extrudePath !== void 0 &&
            (t.options.extrudePath = e.extrudePath.toJSON()),
		t
	);
}
class qu extends ot {
	constructor(
		e = new Ls([new me(0, 0.5), new me(-0.5, -0.5), new me(0.5, -0.5)]),
		t = 12
	) {
		super(),
		(this.type = 'ShapeGeometry'),
		(this.parameters = { shapes: e, curveSegments: t });
		const i = [],
			n = [],
			a = [],
			s = [];
		let o = 0,
			l = 0;
		if (Array.isArray(e) === !1) c(e);
		else
			for (let u = 0; u < e.length; u++)
				c(e[u]), this.addGroup(o, l, u), (o += l), (l = 0);
		this.setIndex(i),
		this.setAttribute('position', new yt(n, 3)),
		this.setAttribute('normal', new yt(a, 3)),
		this.setAttribute('uv', new yt(s, 2));
		function c(u) {
			const h = n.length / 3,
				d = u.extractPoints(t);
			let p = d.shape;
			const g = d.holes;
			Li.isClockWise(p) === !1 && (p = p.reverse());
			for (let f = 0, v = g.length; f < v; f++) {
				const x = g[f];
				Li.isClockWise(x) === !0 && (g[f] = x.reverse());
			}
			const m = Li.triangulateShape(p, g);
			for (let f = 0, v = g.length; f < v; f++) {
				const x = g[f];
				p = p.concat(x);
			}
			for (let f = 0, v = p.length; f < v; f++) {
				const x = p[f];
				n.push(x.x, x.y, 0), a.push(0, 0, 1), s.push(x.x, x.y);
			}
			for (let f = 0, v = m.length; f < v; f++) {
				const x = m[f],
					A = x[0] + h,
					S = x[1] + h,
					M = x[2] + h;
				i.push(A, S, M), (l += 3);
			}
		}
	}
	toJSON() {
		const e = super.toJSON(),
			t = this.parameters.shapes;
		return zS(t, e);
	}
	static fromJSON(e, t) {
		const i = [];
		for (let n = 0, a = e.shapes.length; n < a; n++) {
			const s = t[e.shapes[n]];
			i.push(s);
		}
		return new qu(i, e.curveSegments);
	}
}
function zS(r, e) {
	if (((e.shapes = []), Array.isArray(r)))
		for (let t = 0, i = r.length; t < i; t++) {
			const n = r[t];
			e.shapes.push(n.uuid);
		}
	else e.shapes.push(r.uuid);
	return e;
}
class lg extends dt {
	constructor(e) {
		super(),
		(this.type = 'ShadowMaterial'),
		(this.color = new ke(0)),
		(this.transparent = !0),
		this.setValues(e);
	}
	copy(e) {
		return super.copy(e), this.color.copy(e.color), this;
	}
}
lg.prototype.isShadowMaterial = !0;
class cg extends br {
	constructor(e) {
		super(e), (this.type = 'RawShaderMaterial');
	}
}
cg.prototype.isRawShaderMaterial = !0;
class Ii extends dt {
	constructor(e) {
		super(),
		(this.defines = { STANDARD: '' }),
		(this.type = 'MeshStandardMaterial'),
		(this.color = new ke(16777215)),
		(this.roughness = 1),
		(this.metalness = 0),
		(this.map = null),
		(this.lightMap = null),
		(this.lightMapIntensity = 1),
		(this.aoMap = null),
		(this.aoMapIntensity = 1),
		(this.emissive = new ke(0)),
		(this.emissiveIntensity = 1),
		(this.emissiveMap = null),
		(this.bumpMap = null),
		(this.bumpScale = 1),
		(this.normalMap = null),
		(this.normalMapType = un),
		(this.normalScale = new me(1, 1)),
		(this.displacementMap = null),
		(this.displacementScale = 1),
		(this.displacementBias = 0),
		(this.roughnessMap = null),
		(this.metalnessMap = null),
		(this.alphaMap = null),
		(this.envMap = null),
		(this.envMapIntensity = 1),
		(this.wireframe = !1),
		(this.wireframeLinewidth = 1),
		(this.wireframeLinecap = 'round'),
		(this.wireframeLinejoin = 'round'),
		(this.flatShading = !1),
		this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			(this.defines = { STANDARD: '' }),
			this.color.copy(e.color),
			(this.roughness = e.roughness),
			(this.metalness = e.metalness),
			(this.map = e.map),
			(this.lightMap = e.lightMap),
			(this.lightMapIntensity = e.lightMapIntensity),
			(this.aoMap = e.aoMap),
			(this.aoMapIntensity = e.aoMapIntensity),
			this.emissive.copy(e.emissive),
			(this.emissiveMap = e.emissiveMap),
			(this.emissiveIntensity = e.emissiveIntensity),
			(this.bumpMap = e.bumpMap),
			(this.bumpScale = e.bumpScale),
			(this.normalMap = e.normalMap),
			(this.normalMapType = e.normalMapType),
			this.normalScale.copy(e.normalScale),
			(this.displacementMap = e.displacementMap),
			(this.displacementScale = e.displacementScale),
			(this.displacementBias = e.displacementBias),
			(this.roughnessMap = e.roughnessMap),
			(this.metalnessMap = e.metalnessMap),
			(this.alphaMap = e.alphaMap),
			(this.envMap = e.envMap),
			(this.envMapIntensity = e.envMapIntensity),
			(this.wireframe = e.wireframe),
			(this.wireframeLinewidth = e.wireframeLinewidth),
			(this.wireframeLinecap = e.wireframeLinecap),
			(this.wireframeLinejoin = e.wireframeLinejoin),
			(this.flatShading = e.flatShading),
			this
		);
	}
}
Ii.prototype.isMeshStandardMaterial = !0;
class Ni extends Ii {
	constructor(e) {
		super(),
		(this.defines = { STANDARD: '', PHYSICAL: '' }),
		(this.type = 'MeshPhysicalMaterial'),
		(this.clearcoatMap = null),
		(this.clearcoatRoughness = 0),
		(this.clearcoatRoughnessMap = null),
		(this.clearcoatNormalScale = new me(1, 1)),
		(this.clearcoatNormalMap = null),
		(this.ior = 1.5),
		Object.defineProperty(this, 'reflectivity', {
			get: function () {
				return Et((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
			},
			set: function (t) {
				this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
			}
		}),
		(this.sheenColor = new ke(0)),
		(this.sheenColorMap = null),
		(this.sheenRoughness = 1),
		(this.sheenRoughnessMap = null),
		(this.transmissionMap = null),
		(this.thickness = 0),
		(this.thicknessMap = null),
		(this.attenuationDistance = 0),
		(this.attenuationColor = new ke(1, 1, 1)),
		(this.specularIntensity = 1),
		(this.specularIntensityMap = null),
		(this.specularColor = new ke(1, 1, 1)),
		(this.specularColorMap = null),
		(this._sheen = 0),
		(this._clearcoat = 0),
		(this._transmission = 0),
		this.setValues(e);
	}
	get sheen() {
		return this._sheen;
	}
	set sheen(e) {
		this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
	}
	get clearcoat() {
		return this._clearcoat;
	}
	set clearcoat(e) {
		this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
	}
	get transmission() {
		return this._transmission;
	}
	set transmission(e) {
		this._transmission > 0 != e > 0 && this.version++,
		(this._transmission = e);
	}
	copy(e) {
		return (
			super.copy(e),
			(this.defines = { STANDARD: '', PHYSICAL: '' }),
			(this.clearcoat = e.clearcoat),
			(this.clearcoatMap = e.clearcoatMap),
			(this.clearcoatRoughness = e.clearcoatRoughness),
			(this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
			(this.clearcoatNormalMap = e.clearcoatNormalMap),
			this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
			(this.ior = e.ior),
			(this.sheen = e.sheen),
			this.sheenColor.copy(e.sheenColor),
			(this.sheenColorMap = e.sheenColorMap),
			(this.sheenRoughness = e.sheenRoughness),
			(this.sheenRoughnessMap = e.sheenRoughnessMap),
			(this.transmission = e.transmission),
			(this.transmissionMap = e.transmissionMap),
			(this.thickness = e.thickness),
			(this.thicknessMap = e.thicknessMap),
			(this.attenuationDistance = e.attenuationDistance),
			this.attenuationColor.copy(e.attenuationColor),
			(this.specularIntensity = e.specularIntensity),
			(this.specularIntensityMap = e.specularIntensityMap),
			this.specularColor.copy(e.specularColor),
			(this.specularColorMap = e.specularColorMap),
			this
		);
	}
}
Ni.prototype.isMeshPhysicalMaterial = !0;
class ug extends dt {
	constructor(e) {
		super(),
		(this.type = 'MeshPhongMaterial'),
		(this.color = new ke(16777215)),
		(this.specular = new ke(1118481)),
		(this.shininess = 30),
		(this.map = null),
		(this.lightMap = null),
		(this.lightMapIntensity = 1),
		(this.aoMap = null),
		(this.aoMapIntensity = 1),
		(this.emissive = new ke(0)),
		(this.emissiveIntensity = 1),
		(this.emissiveMap = null),
		(this.bumpMap = null),
		(this.bumpScale = 1),
		(this.normalMap = null),
		(this.normalMapType = un),
		(this.normalScale = new me(1, 1)),
		(this.displacementMap = null),
		(this.displacementScale = 1),
		(this.displacementBias = 0),
		(this.specularMap = null),
		(this.alphaMap = null),
		(this.envMap = null),
		(this.combine = tl),
		(this.reflectivity = 1),
		(this.refractionRatio = 0.98),
		(this.wireframe = !1),
		(this.wireframeLinewidth = 1),
		(this.wireframeLinecap = 'round'),
		(this.wireframeLinejoin = 'round'),
		(this.flatShading = !1),
		this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			this.color.copy(e.color),
			this.specular.copy(e.specular),
			(this.shininess = e.shininess),
			(this.map = e.map),
			(this.lightMap = e.lightMap),
			(this.lightMapIntensity = e.lightMapIntensity),
			(this.aoMap = e.aoMap),
			(this.aoMapIntensity = e.aoMapIntensity),
			this.emissive.copy(e.emissive),
			(this.emissiveMap = e.emissiveMap),
			(this.emissiveIntensity = e.emissiveIntensity),
			(this.bumpMap = e.bumpMap),
			(this.bumpScale = e.bumpScale),
			(this.normalMap = e.normalMap),
			(this.normalMapType = e.normalMapType),
			this.normalScale.copy(e.normalScale),
			(this.displacementMap = e.displacementMap),
			(this.displacementScale = e.displacementScale),
			(this.displacementBias = e.displacementBias),
			(this.specularMap = e.specularMap),
			(this.alphaMap = e.alphaMap),
			(this.envMap = e.envMap),
			(this.combine = e.combine),
			(this.reflectivity = e.reflectivity),
			(this.refractionRatio = e.refractionRatio),
			(this.wireframe = e.wireframe),
			(this.wireframeLinewidth = e.wireframeLinewidth),
			(this.wireframeLinecap = e.wireframeLinecap),
			(this.wireframeLinejoin = e.wireframeLinejoin),
			(this.flatShading = e.flatShading),
			this
		);
	}
}
ug.prototype.isMeshPhongMaterial = !0;
class hg extends dt {
	constructor(e) {
		super(),
		(this.defines = { TOON: '' }),
		(this.type = 'MeshToonMaterial'),
		(this.color = new ke(16777215)),
		(this.map = null),
		(this.gradientMap = null),
		(this.lightMap = null),
		(this.lightMapIntensity = 1),
		(this.aoMap = null),
		(this.aoMapIntensity = 1),
		(this.emissive = new ke(0)),
		(this.emissiveIntensity = 1),
		(this.emissiveMap = null),
		(this.bumpMap = null),
		(this.bumpScale = 1),
		(this.normalMap = null),
		(this.normalMapType = un),
		(this.normalScale = new me(1, 1)),
		(this.displacementMap = null),
		(this.displacementScale = 1),
		(this.displacementBias = 0),
		(this.alphaMap = null),
		(this.wireframe = !1),
		(this.wireframeLinewidth = 1),
		(this.wireframeLinecap = 'round'),
		(this.wireframeLinejoin = 'round'),
		this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			this.color.copy(e.color),
			(this.map = e.map),
			(this.gradientMap = e.gradientMap),
			(this.lightMap = e.lightMap),
			(this.lightMapIntensity = e.lightMapIntensity),
			(this.aoMap = e.aoMap),
			(this.aoMapIntensity = e.aoMapIntensity),
			this.emissive.copy(e.emissive),
			(this.emissiveMap = e.emissiveMap),
			(this.emissiveIntensity = e.emissiveIntensity),
			(this.bumpMap = e.bumpMap),
			(this.bumpScale = e.bumpScale),
			(this.normalMap = e.normalMap),
			(this.normalMapType = e.normalMapType),
			this.normalScale.copy(e.normalScale),
			(this.displacementMap = e.displacementMap),
			(this.displacementScale = e.displacementScale),
			(this.displacementBias = e.displacementBias),
			(this.alphaMap = e.alphaMap),
			(this.wireframe = e.wireframe),
			(this.wireframeLinewidth = e.wireframeLinewidth),
			(this.wireframeLinecap = e.wireframeLinecap),
			(this.wireframeLinejoin = e.wireframeLinejoin),
			this
		);
	}
}
hg.prototype.isMeshToonMaterial = !0;
class dg extends dt {
	constructor(e) {
		super(),
		(this.type = 'MeshNormalMaterial'),
		(this.bumpMap = null),
		(this.bumpScale = 1),
		(this.normalMap = null),
		(this.normalMapType = un),
		(this.normalScale = new me(1, 1)),
		(this.displacementMap = null),
		(this.displacementScale = 1),
		(this.displacementBias = 0),
		(this.wireframe = !1),
		(this.wireframeLinewidth = 1),
		(this.fog = !1),
		(this.flatShading = !1),
		this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			(this.bumpMap = e.bumpMap),
			(this.bumpScale = e.bumpScale),
			(this.normalMap = e.normalMap),
			(this.normalMapType = e.normalMapType),
			this.normalScale.copy(e.normalScale),
			(this.displacementMap = e.displacementMap),
			(this.displacementScale = e.displacementScale),
			(this.displacementBias = e.displacementBias),
			(this.wireframe = e.wireframe),
			(this.wireframeLinewidth = e.wireframeLinewidth),
			(this.flatShading = e.flatShading),
			this
		);
	}
}
dg.prototype.isMeshNormalMaterial = !0;
class pg extends dt {
	constructor(e) {
		super(),
		(this.type = 'MeshLambertMaterial'),
		(this.color = new ke(16777215)),
		(this.map = null),
		(this.lightMap = null),
		(this.lightMapIntensity = 1),
		(this.aoMap = null),
		(this.aoMapIntensity = 1),
		(this.emissive = new ke(0)),
		(this.emissiveIntensity = 1),
		(this.emissiveMap = null),
		(this.specularMap = null),
		(this.alphaMap = null),
		(this.envMap = null),
		(this.combine = tl),
		(this.reflectivity = 1),
		(this.refractionRatio = 0.98),
		(this.wireframe = !1),
		(this.wireframeLinewidth = 1),
		(this.wireframeLinecap = 'round'),
		(this.wireframeLinejoin = 'round'),
		this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			this.color.copy(e.color),
			(this.map = e.map),
			(this.lightMap = e.lightMap),
			(this.lightMapIntensity = e.lightMapIntensity),
			(this.aoMap = e.aoMap),
			(this.aoMapIntensity = e.aoMapIntensity),
			this.emissive.copy(e.emissive),
			(this.emissiveMap = e.emissiveMap),
			(this.emissiveIntensity = e.emissiveIntensity),
			(this.specularMap = e.specularMap),
			(this.alphaMap = e.alphaMap),
			(this.envMap = e.envMap),
			(this.combine = e.combine),
			(this.reflectivity = e.reflectivity),
			(this.refractionRatio = e.refractionRatio),
			(this.wireframe = e.wireframe),
			(this.wireframeLinewidth = e.wireframeLinewidth),
			(this.wireframeLinecap = e.wireframeLinecap),
			(this.wireframeLinejoin = e.wireframeLinejoin),
			this
		);
	}
}
pg.prototype.isMeshLambertMaterial = !0;
class mg extends dt {
	constructor(e) {
		super(),
		(this.defines = { MATCAP: '' }),
		(this.type = 'MeshMatcapMaterial'),
		(this.color = new ke(16777215)),
		(this.matcap = null),
		(this.map = null),
		(this.bumpMap = null),
		(this.bumpScale = 1),
		(this.normalMap = null),
		(this.normalMapType = un),
		(this.normalScale = new me(1, 1)),
		(this.displacementMap = null),
		(this.displacementScale = 1),
		(this.displacementBias = 0),
		(this.alphaMap = null),
		(this.flatShading = !1),
		this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			(this.defines = { MATCAP: '' }),
			this.color.copy(e.color),
			(this.matcap = e.matcap),
			(this.map = e.map),
			(this.bumpMap = e.bumpMap),
			(this.bumpScale = e.bumpScale),
			(this.normalMap = e.normalMap),
			(this.normalMapType = e.normalMapType),
			this.normalScale.copy(e.normalScale),
			(this.displacementMap = e.displacementMap),
			(this.displacementScale = e.displacementScale),
			(this.displacementBias = e.displacementBias),
			(this.alphaMap = e.alphaMap),
			(this.flatShading = e.flatShading),
			this
		);
	}
}
mg.prototype.isMeshMatcapMaterial = !0;
class fg extends Oi {
	constructor(e) {
		super(),
		(this.type = 'LineDashedMaterial'),
		(this.scale = 1),
		(this.dashSize = 3),
		(this.gapSize = 1),
		this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			(this.scale = e.scale),
			(this.dashSize = e.dashSize),
			(this.gapSize = e.gapSize),
			this
		);
	}
}
fg.prototype.isLineDashedMaterial = !0;
const US = {
	ShadowMaterial: lg,
	SpriteMaterial: Bu,
	RawShaderMaterial: cg,
	ShaderMaterial: br,
	PointsMaterial: ul,
	MeshPhysicalMaterial: Ni,
	MeshStandardMaterial: Ii,
	MeshPhongMaterial: ug,
	MeshToonMaterial: hg,
	MeshNormalMaterial: dg,
	MeshLambertMaterial: pg,
	MeshDepthMaterial: zu,
	MeshDistanceMaterial: Uu,
	MeshBasicMaterial: Cr,
	MeshMatcapMaterial: mg,
	LineDashedMaterial: fg,
	LineBasicMaterial: Oi,
	Material: dt
};
dt.fromType = function (r) {
	return new US[r]();
};
const ct = {
	arraySlice: function (r, e, t) {
		return ct.isTypedArray(r)
			? new r.constructor(r.subarray(e, t !== void 0 ? t : r.length))
			: r.slice(e, t);
	},
	convertArray: function (r, e, t) {
		return !r || (!t && r.constructor === e)
			? r
			: typeof e.BYTES_PER_ELEMENT == 'number'
				? new e(r)
				: Array.prototype.slice.call(r);
	},
	isTypedArray: function (r) {
		return ArrayBuffer.isView(r) && !(r instanceof DataView);
	},
	getKeyframeOrder: function (r) {
		function e(n, a) {
			return r[n] - r[a];
		}
		const t = r.length,
			i = new Array(t);
		for (let n = 0; n !== t; ++n) i[n] = n;
		return i.sort(e), i;
	},
	sortedArray: function (r, e, t) {
		const i = r.length,
			n = new r.constructor(i);
		for (let a = 0, s = 0; s !== i; ++a) {
			const o = t[a] * e;
			for (let l = 0; l !== e; ++l) n[s++] = r[o + l];
		}
		return n;
	},
	flattenJSON: function (r, e, t, i) {
		let n = 1,
			a = r[0];
		for (; a !== void 0 && a[i] === void 0; ) a = r[n++];
		if (a === void 0) return;
		let s = a[i];
		if (s !== void 0)
			if (Array.isArray(s))
				do
					(s = a[i]),
					s !== void 0 && (e.push(a.time), t.push.apply(t, s)),
					(a = r[n++]);
				while (a !== void 0);
			else if (s.toArray !== void 0)
				do
					(s = a[i]),
					s !== void 0 &&
                            (e.push(a.time), s.toArray(t, t.length)),
					(a = r[n++]);
				while (a !== void 0);
			else
				do
					(s = a[i]),
					s !== void 0 && (e.push(a.time), t.push(s)),
					(a = r[n++]);
				while (a !== void 0);
	},
	subclip: function (r, e, t, i, n = 30) {
		const a = r.clone();
		a.name = e;
		const s = [];
		for (let l = 0; l < a.tracks.length; ++l) {
			const c = a.tracks[l],
				u = c.getValueSize(),
				h = [],
				d = [];
			for (let p = 0; p < c.times.length; ++p) {
				const g = c.times[p] * n;
				if (!(g < t || g >= i)) {
					h.push(c.times[p]);
					for (let m = 0; m < u; ++m) d.push(c.values[p * u + m]);
				}
			}
			h.length !== 0 &&
                ((c.times = ct.convertArray(h, c.times.constructor)),
                (c.values = ct.convertArray(d, c.values.constructor)),
                s.push(c));
		}
		a.tracks = s;
		let o = 1 / 0;
		for (let l = 0; l < a.tracks.length; ++l)
			o > a.tracks[l].times[0] && (o = a.tracks[l].times[0]);
		for (let l = 0; l < a.tracks.length; ++l) a.tracks[l].shift(-1 * o);
		return a.resetDuration(), a;
	},
	makeClipAdditive: function (r, e = 0, t = r, i = 30) {
		i <= 0 && (i = 30);
		const n = t.tracks.length,
			a = e / i;
		for (let s = 0; s < n; ++s) {
			const o = t.tracks[s],
				l = o.ValueTypeName;
			if (l === 'bool' || l === 'string') continue;
			const c = r.tracks.find(function (v) {
				return v.name === o.name && v.ValueTypeName === l;
			});
			if (c === void 0) continue;
			let u = 0;
			const h = o.getValueSize();
			o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
                (u = h / 3);
			let d = 0;
			const p = c.getValueSize();
			c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
                (d = p / 3);
			const g = o.times.length - 1;
			let m;
			if (a <= o.times[0]) {
				const v = u,
					x = h - u;
				m = ct.arraySlice(o.values, v, x);
			} else if (a >= o.times[g]) {
				const v = g * h + u,
					x = v + h - u;
				m = ct.arraySlice(o.values, v, x);
			} else {
				const v = o.createInterpolant(),
					x = u,
					A = h - u;
				v.evaluate(a), (m = ct.arraySlice(v.resultBuffer, x, A));
			}
			l === 'quaternion' &&
                new Ct().fromArray(m).normalize().conjugate().toArray(m);
			const f = c.times.length;
			for (let v = 0; v < f; ++v) {
				const x = v * p + d;
				if (l === 'quaternion')
					Ct.multiplyQuaternionsFlat(c.values, x, m, 0, c.values, x);
				else {
					const A = p - d * 2;
					for (let S = 0; S < A; ++S) c.values[x + S] -= m[S];
				}
			}
		}
		return (r.blendMode = Rf), r;
	}
};
class ei {
	constructor(e, t, i, n) {
		(this.parameterPositions = e),
		(this._cachedIndex = 0),
		(this.resultBuffer = n !== void 0 ? n : new t.constructor(i)),
		(this.sampleValues = t),
		(this.valueSize = i),
		(this.settings = null),
		(this.DefaultSettings_ = {});
	}
	evaluate(e) {
		const t = this.parameterPositions;
		let i = this._cachedIndex,
			n = t[i],
			a = t[i - 1];
		e: {
			t: {
				let s;
				r: {
					i: if (!(e < n)) {
						for (let o = i + 2; ; ) {
							if (n === void 0) {
								if (e < a) break i;
								return (
									(i = t.length),
									(this._cachedIndex = i),
									this.afterEnd_(i - 1, e, a)
								);
							}
							if (i === o) break;
							if (((a = n), (n = t[++i]), e < n)) break t;
						}
						s = t.length;
						break r;
					}
					if (!(e >= a)) {
						const o = t[1];
						e < o && ((i = 2), (a = o));
						for (let l = i - 2; ; ) {
							if (a === void 0)
								return (
									(this._cachedIndex = 0),
									this.beforeStart_(0, e, n)
								);
							if (i === l) break;
							if (((n = a), (a = t[--i - 1]), e >= a)) break t;
						}
						(s = i), (i = 0);
						break r;
					}
					break e;
				}
				for (; i < s; ) {
					const o = (i + s) >>> 1;
					e < t[o] ? (s = o) : (i = o + 1);
				}
				if (((n = t[i]), (a = t[i - 1]), a === void 0))
					return (this._cachedIndex = 0), this.beforeStart_(0, e, n);
				if (n === void 0)
					return (
						(i = t.length),
						(this._cachedIndex = i),
						this.afterEnd_(i - 1, a, e)
					);
			}
			(this._cachedIndex = i), this.intervalChanged_(i, a, n);
		}
		return this.interpolate_(i, a, e, n);
	}
	getSettings_() {
		return this.settings || this.DefaultSettings_;
	}
	copySampleValue_(e) {
		const t = this.resultBuffer,
			i = this.sampleValues,
			n = this.valueSize,
			a = e * n;
		for (let s = 0; s !== n; ++s) t[s] = i[a + s];
		return t;
	}
	interpolate_() {
		throw new Error('call to abstract method');
	}
	intervalChanged_() {}
}
ei.prototype.beforeStart_ = ei.prototype.copySampleValue_;
ei.prototype.afterEnd_ = ei.prototype.copySampleValue_;
class BS extends ei {
	constructor(e, t, i, n) {
		super(e, t, i, n),
		(this._weightPrev = -0),
		(this._offsetPrev = -0),
		(this._weightNext = -0),
		(this._offsetNext = -0),
		(this.DefaultSettings_ = { endingStart: Xn, endingEnd: Xn });
	}
	intervalChanged_(e, t, i) {
		const n = this.parameterPositions;
		let a = e - 2,
			s = e + 1,
			o = n[a],
			l = n[s];
		if (o === void 0)
			switch (this.getSettings_().endingStart) {
			case qn:
				(a = e), (o = 2 * t - i);
				break;
			case No:
				(a = n.length - 2), (o = t + n[a] - n[a + 1]);
				break;
			default:
				(a = e), (o = i);
			}
		if (l === void 0)
			switch (this.getSettings_().endingEnd) {
			case qn:
				(s = e), (l = 2 * i - t);
				break;
			case No:
				(s = 1), (l = i + n[1] - n[0]);
				break;
			default:
				(s = e - 1), (l = t);
			}
		const c = (i - t) * 0.5,
			u = this.valueSize;
		(this._weightPrev = c / (t - o)),
		(this._weightNext = c / (l - i)),
		(this._offsetPrev = a * u),
		(this._offsetNext = s * u);
	}
	interpolate_(e, t, i, n) {
		const a = this.resultBuffer,
			s = this.sampleValues,
			o = this.valueSize,
			l = e * o,
			c = l - o,
			u = this._offsetPrev,
			h = this._offsetNext,
			d = this._weightPrev,
			p = this._weightNext,
			g = (i - t) / (n - t),
			m = g * g,
			f = m * g,
			v = -d * f + 2 * d * m - d * g,
			x = (1 + d) * f + (-1.5 - 2 * d) * m + (-0.5 + d) * g + 1,
			A = (-1 - p) * f + (1.5 + p) * m + 0.5 * g,
			S = p * f - p * m;
		for (let M = 0; M !== o; ++M)
			a[M] = v * s[u + M] + x * s[c + M] + A * s[l + M] + S * s[h + M];
		return a;
	}
}
class gg extends ei {
	constructor(e, t, i, n) {
		super(e, t, i, n);
	}
	interpolate_(e, t, i, n) {
		const a = this.resultBuffer,
			s = this.sampleValues,
			o = this.valueSize,
			l = e * o,
			c = l - o,
			u = (i - t) / (n - t),
			h = 1 - u;
		for (let d = 0; d !== o; ++d) a[d] = s[c + d] * h + s[l + d] * u;
		return a;
	}
}
class FS extends ei {
	constructor(e, t, i, n) {
		super(e, t, i, n);
	}
	interpolate_(e) {
		return this.copySampleValue_(e - 1);
	}
}
class zr {
	constructor(e, t, i, n) {
		if (e === void 0)
			throw new Error('THREE.KeyframeTrack: track name is undefined');
		if (t === void 0 || t.length === 0)
			throw new Error(
				'THREE.KeyframeTrack: no keyframes in track named ' + e
			);
		(this.name = e),
		(this.times = ct.convertArray(t, this.TimeBufferType)),
		(this.values = ct.convertArray(i, this.ValueBufferType)),
		this.setInterpolation(n || this.DefaultInterpolation);
	}
	static toJSON(e) {
		const t = e.constructor;
		let i;
		if (t.toJSON !== this.toJSON) i = t.toJSON(e);
		else {
			i = {
				name: e.name,
				times: ct.convertArray(e.times, Array),
				values: ct.convertArray(e.values, Array)
			};
			const n = e.getInterpolation();
			n !== e.DefaultInterpolation && (i.interpolation = n);
		}
		return (i.type = e.ValueTypeName), i;
	}
	InterpolantFactoryMethodDiscrete(e) {
		return new FS(this.times, this.values, this.getValueSize(), e);
	}
	InterpolantFactoryMethodLinear(e) {
		return new gg(this.times, this.values, this.getValueSize(), e);
	}
	InterpolantFactoryMethodSmooth(e) {
		return new BS(this.times, this.values, this.getValueSize(), e);
	}
	setInterpolation(e) {
		let t;
		switch (e) {
		case fs:
			t = this.InterpolantFactoryMethodDiscrete;
			break;
		case ca:
			t = this.InterpolantFactoryMethodLinear;
			break;
		case kl:
			t = this.InterpolantFactoryMethodSmooth;
			break;
		}
		if (t === void 0) {
			const i =
                'unsupported interpolation for ' +
                this.ValueTypeName +
                ' keyframe track named ' +
                this.name;
			if (this.createInterpolant === void 0)
				if (e !== this.DefaultInterpolation)
					this.setInterpolation(this.DefaultInterpolation);
				else throw new Error(i);
			return console.warn('THREE.KeyframeTrack:', i), this;
		}
		return (this.createInterpolant = t), this;
	}
	getInterpolation() {
		switch (this.createInterpolant) {
		case this.InterpolantFactoryMethodDiscrete:
			return fs;
		case this.InterpolantFactoryMethodLinear:
			return ca;
		case this.InterpolantFactoryMethodSmooth:
			return kl;
		}
	}
	getValueSize() {
		return this.values.length / this.times.length;
	}
	shift(e) {
		if (e !== 0) {
			const t = this.times;
			for (let i = 0, n = t.length; i !== n; ++i) t[i] += e;
		}
		return this;
	}
	scale(e) {
		if (e !== 1) {
			const t = this.times;
			for (let i = 0, n = t.length; i !== n; ++i) t[i] *= e;
		}
		return this;
	}
	trim(e, t) {
		const i = this.times,
			n = i.length;
		let a = 0,
			s = n - 1;
		for (; a !== n && i[a] < e; ) ++a;
		for (; s !== -1 && i[s] > t; ) --s;
		if ((++s, a !== 0 || s !== n)) {
			a >= s && ((s = Math.max(s, 1)), (a = s - 1));
			const o = this.getValueSize();
			(this.times = ct.arraySlice(i, a, s)),
			(this.values = ct.arraySlice(this.values, a * o, s * o));
		}
		return this;
	}
	validate() {
		let e = !0;
		const t = this.getValueSize();
		t - Math.floor(t) !== 0 &&
            (console.error(
            	'THREE.KeyframeTrack: Invalid value size in track.',
            	this
            ),
            (e = !1));
		const i = this.times,
			n = this.values,
			a = i.length;
		a === 0 &&
            (console.error('THREE.KeyframeTrack: Track is empty.', this),
            (e = !1));
		let s = null;
		for (let o = 0; o !== a; o++) {
			const l = i[o];
			if (typeof l == 'number' && isNaN(l)) {
				console.error(
					'THREE.KeyframeTrack: Time is not a valid number.',
					this,
					o,
					l
				),
				(e = !1);
				break;
			}
			if (s !== null && s > l) {
				console.error(
					'THREE.KeyframeTrack: Out of order keys.',
					this,
					o,
					l,
					s
				),
				(e = !1);
				break;
			}
			s = l;
		}
		if (n !== void 0 && ct.isTypedArray(n))
			for (let o = 0, l = n.length; o !== l; ++o) {
				const c = n[o];
				if (isNaN(c)) {
					console.error(
						'THREE.KeyframeTrack: Value is not a valid number.',
						this,
						o,
						c
					),
					(e = !1);
					break;
				}
			}
		return e;
	}
	optimize() {
		const e = ct.arraySlice(this.times),
			t = ct.arraySlice(this.values),
			i = this.getValueSize(),
			n = this.getInterpolation() === kl,
			a = e.length - 1;
		let s = 1;
		for (let o = 1; o < a; ++o) {
			let l = !1;
			const c = e[o],
				u = e[o + 1];
			if (c !== u && (o !== 1 || c !== e[0]))
				if (n) l = !0;
				else {
					const h = o * i,
						d = h - i,
						p = h + i;
					for (let g = 0; g !== i; ++g) {
						const m = t[h + g];
						if (m !== t[d + g] || m !== t[p + g]) {
							l = !0;
							break;
						}
					}
				}
			if (l) {
				if (o !== s) {
					e[s] = e[o];
					const h = o * i,
						d = s * i;
					for (let p = 0; p !== i; ++p) t[d + p] = t[h + p];
				}
				++s;
			}
		}
		if (a > 0) {
			e[s] = e[a];
			for (let o = a * i, l = s * i, c = 0; c !== i; ++c)
				t[l + c] = t[o + c];
			++s;
		}
		return (
			s !== e.length
				? ((this.times = ct.arraySlice(e, 0, s)),
				(this.values = ct.arraySlice(t, 0, s * i)))
				: ((this.times = e), (this.values = t)),
			this
		);
	}
	clone() {
		const e = ct.arraySlice(this.times, 0),
			t = ct.arraySlice(this.values, 0),
			i = this.constructor,
			n = new i(this.name, e, t);
		return (n.createInterpolant = this.createInterpolant), n;
	}
}
zr.prototype.TimeBufferType = Float32Array;
zr.prototype.ValueBufferType = Float32Array;
zr.prototype.DefaultInterpolation = ca;
class Ea extends zr {}
Ea.prototype.ValueTypeName = 'bool';
Ea.prototype.ValueBufferType = Array;
Ea.prototype.DefaultInterpolation = fs;
Ea.prototype.InterpolantFactoryMethodLinear = void 0;
Ea.prototype.InterpolantFactoryMethodSmooth = void 0;
class vg extends zr {}
vg.prototype.ValueTypeName = 'color';
class _s extends zr {}
_s.prototype.ValueTypeName = 'number';
class HS extends ei {
	constructor(e, t, i, n) {
		super(e, t, i, n);
	}
	interpolate_(e, t, i, n) {
		const a = this.resultBuffer,
			s = this.sampleValues,
			o = this.valueSize,
			l = (i - t) / (n - t);
		let c = e * o;
		for (let u = c + o; c !== u; c += 4)
			Ct.slerpFlat(a, 0, s, c - o, s, c, l);
		return a;
	}
}
class on extends zr {
	InterpolantFactoryMethodLinear(e) {
		return new HS(this.times, this.values, this.getValueSize(), e);
	}
}
on.prototype.ValueTypeName = 'quaternion';
on.prototype.DefaultInterpolation = ca;
on.prototype.InterpolantFactoryMethodSmooth = void 0;
class Aa extends zr {}
Aa.prototype.ValueTypeName = 'string';
Aa.prototype.ValueBufferType = Array;
Aa.prototype.DefaultInterpolation = fs;
Aa.prototype.InterpolantFactoryMethodLinear = void 0;
Aa.prototype.InterpolantFactoryMethodSmooth = void 0;
class Ms extends zr {}
Ms.prototype.ValueTypeName = 'vector';
class Jc {
	constructor(e, t = -1, i, n = ku) {
		(this.name = e),
		(this.tracks = i),
		(this.duration = t),
		(this.blendMode = n),
		(this.uuid = ir()),
		this.duration < 0 && this.resetDuration();
	}
	static parse(e) {
		const t = [],
			i = e.tracks,
			n = 1 / (e.fps || 1);
		for (let s = 0, o = i.length; s !== o; ++s) t.push(VS(i[s]).scale(n));
		const a = new this(e.name, e.duration, t, e.blendMode);
		return (a.uuid = e.uuid), a;
	}
	static toJSON(e) {
		const t = [],
			i = e.tracks,
			n = {
				name: e.name,
				duration: e.duration,
				tracks: t,
				uuid: e.uuid,
				blendMode: e.blendMode
			};
		for (let a = 0, s = i.length; a !== s; ++a) t.push(zr.toJSON(i[a]));
		return n;
	}
	static CreateFromMorphTargetSequence(e, t, i, n) {
		const a = t.length,
			s = [];
		for (let o = 0; o < a; o++) {
			let l = [],
				c = [];
			l.push((o + a - 1) % a, o, (o + 1) % a), c.push(0, 1, 0);
			const u = ct.getKeyframeOrder(l);
			(l = ct.sortedArray(l, 1, u)),
			(c = ct.sortedArray(c, 1, u)),
			!n && l[0] === 0 && (l.push(a), c.push(c[0])),
			s.push(
				new _s(
					'.morphTargetInfluences[' + t[o].name + ']',
					l,
					c
				).scale(1 / i)
			);
		}
		return new this(e, -1, s);
	}
	static findByName(e, t) {
		let i = e;
		if (!Array.isArray(e)) {
			const n = e;
			i = (n.geometry && n.geometry.animations) || n.animations;
		}
		for (let n = 0; n < i.length; n++) if (i[n].name === t) return i[n];
		return null;
	}
	static CreateClipsFromMorphTargetSequences(e, t, i) {
		const n = {},
			a = /^([\w-]*?)([\d]+)$/;
		for (let o = 0, l = e.length; o < l; o++) {
			const c = e[o],
				u = c.name.match(a);
			if (u && u.length > 1) {
				const h = u[1];
				let d = n[h];
				d || (n[h] = d = []), d.push(c);
			}
		}
		const s = [];
		for (const o in n)
			s.push(this.CreateFromMorphTargetSequence(o, n[o], t, i));
		return s;
	}
	static parseAnimation(e, t) {
		if (!e)
			return (
				console.error(
					'THREE.AnimationClip: No animation in JSONLoader data.'
				),
				null
			);
		const i = function (u, h, d, p, g) {
				if (d.length !== 0) {
					const m = [],
						f = [];
					ct.flattenJSON(d, m, f, p),
					m.length !== 0 && g.push(new u(h, m, f));
				}
			},
			n = [],
			a = e.name || 'default',
			s = e.fps || 30,
			o = e.blendMode;
		let l = e.length || -1;
		const c = e.hierarchy || [];
		for (let u = 0; u < c.length; u++) {
			const h = c[u].keys;
			if (!(!h || h.length === 0))
				if (h[0].morphTargets) {
					const d = {};
					let p;
					for (p = 0; p < h.length; p++)
						if (h[p].morphTargets)
							for (let g = 0; g < h[p].morphTargets.length; g++)
								d[h[p].morphTargets[g]] = -1;
					for (const g in d) {
						const m = [],
							f = [];
						for (let v = 0; v !== h[p].morphTargets.length; ++v) {
							const x = h[p];
							m.push(x.time), f.push(x.morphTarget === g ? 1 : 0);
						}
						n.push(
							new _s('.morphTargetInfluence[' + g + ']', m, f)
						);
					}
					l = d.length * s;
				} else {
					const d = '.bones[' + t[u].name + ']';
					i(Ms, d + '.position', h, 'pos', n),
					i(on, d + '.quaternion', h, 'rot', n),
					i(Ms, d + '.scale', h, 'scl', n);
				}
		}
		return n.length === 0 ? null : new this(a, l, n, o);
	}
	resetDuration() {
		const e = this.tracks;
		let t = 0;
		for (let i = 0, n = e.length; i !== n; ++i) {
			const a = this.tracks[i];
			t = Math.max(t, a.times[a.times.length - 1]);
		}
		return (this.duration = t), this;
	}
	trim() {
		for (let e = 0; e < this.tracks.length; e++)
			this.tracks[e].trim(0, this.duration);
		return this;
	}
	validate() {
		let e = !0;
		for (let t = 0; t < this.tracks.length; t++)
			e = e && this.tracks[t].validate();
		return e;
	}
	optimize() {
		for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
		return this;
	}
	clone() {
		const e = [];
		for (let t = 0; t < this.tracks.length; t++)
			e.push(this.tracks[t].clone());
		return new this.constructor(
			this.name,
			this.duration,
			e,
			this.blendMode
		);
	}
	toJSON() {
		return this.constructor.toJSON(this);
	}
}
function GS(r) {
	switch (r.toLowerCase()) {
	case 'scalar':
	case 'double':
	case 'float':
	case 'number':
	case 'integer':
		return _s;
	case 'vector':
	case 'vector2':
	case 'vector3':
	case 'vector4':
		return Ms;
	case 'color':
		return vg;
	case 'quaternion':
		return on;
	case 'bool':
	case 'boolean':
		return Ea;
	case 'string':
		return Aa;
	}
	throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + r);
}
function VS(r) {
	if (r.type === void 0)
		throw new Error(
			'THREE.KeyframeTrack: track type undefined, can not parse'
		);
	const e = GS(r.type);
	if (r.times === void 0) {
		const t = [],
			i = [];
		ct.flattenJSON(r.keys, t, i, 'value'), (r.times = t), (r.values = i);
	}
	return e.parse !== void 0
		? e.parse(r)
		: new e(r.name, r.times, r.values, r.interpolation);
}
const pa = {
	enabled: !1,
	files: {},
	add: function (r, e) {
		this.enabled !== !1 && (this.files[r] = e);
	},
	get: function (r) {
		if (this.enabled !== !1) return this.files[r];
	},
	remove: function (r) {
		delete this.files[r];
	},
	clear: function () {
		this.files = {};
	}
};
class WS {
	constructor(e, t, i) {
		const n = this;
		let a = !1,
			s = 0,
			o = 0,
			l;
		const c = [];
		(this.onStart = void 0),
		(this.onLoad = e),
		(this.onProgress = t),
		(this.onError = i),
		(this.itemStart = function (u) {
			o++,
			a === !1 && n.onStart !== void 0 && n.onStart(u, s, o),
			(a = !0);
		}),
		(this.itemEnd = function (u) {
			s++,
			n.onProgress !== void 0 && n.onProgress(u, s, o),
			s === o && ((a = !1), n.onLoad !== void 0 && n.onLoad());
		}),
		(this.itemError = function (u) {
			n.onError !== void 0 && n.onError(u);
		}),
		(this.resolveURL = function (u) {
			return l ? l(u) : u;
		}),
		(this.setURLModifier = function (u) {
			return (l = u), this;
		}),
		(this.addHandler = function (u, h) {
			return c.push(u, h), this;
		}),
		(this.removeHandler = function (u) {
			const h = c.indexOf(u);
			return h !== -1 && c.splice(h, 2), this;
		}),
		(this.getHandler = function (u) {
			for (let h = 0, d = c.length; h < d; h += 2) {
				const p = c[h],
					g = c[h + 1];
				if ((p.global && (p.lastIndex = 0), p.test(u))) return g;
			}
			return null;
		});
	}
}
const jS = new WS();
class ri {
	constructor(e) {
		(this.manager = e !== void 0 ? e : jS),
		(this.crossOrigin = 'anonymous'),
		(this.withCredentials = !1),
		(this.path = ''),
		(this.resourcePath = ''),
		(this.requestHeader = {});
	}
	load() {}
	loadAsync(e, t) {
		const i = this;
		return new Promise(function (n, a) {
			i.load(e, n, t, a);
		});
	}
	parse() {}
	setCrossOrigin(e) {
		return (this.crossOrigin = e), this;
	}
	setWithCredentials(e) {
		return (this.withCredentials = e), this;
	}
	setPath(e) {
		return (this.path = e), this;
	}
	setResourcePath(e) {
		return (this.resourcePath = e), this;
	}
	setRequestHeader(e) {
		return (this.requestHeader = e), this;
	}
}
const Vr = {};
class Yu extends ri {
	constructor(e) {
		super(e);
	}
	load(e, t, i, n) {
		e === void 0 && (e = ''),
		this.path !== void 0 && (e = this.path + e),
		(e = this.manager.resolveURL(e));
		const a = pa.get(e);
		if (a !== void 0)
			return (
				this.manager.itemStart(e),
				setTimeout(() => {
					t && t(a), this.manager.itemEnd(e);
				}, 0),
				a
			);
		if (Vr[e] !== void 0) {
			Vr[e].push({ onLoad: t, onProgress: i, onError: n });
			return;
		}
		(Vr[e] = []), Vr[e].push({ onLoad: t, onProgress: i, onError: n });
		const s = new Request(e, {
				headers: new Headers(this.requestHeader),
				credentials: this.withCredentials ? 'include' : 'same-origin'
			}),
			o = this.mimeType,
			l = this.responseType;
		fetch(s)
			.then((c) => {
				if (c.status === 200 || c.status === 0) {
					if (
						(c.status === 0 &&
                            console.warn(
                            	'THREE.FileLoader: HTTP Status 0 received.'
                            ),
						typeof ReadableStream == 'undefined' ||
                            c.body === void 0 ||
                            c.body.getReader === void 0)
					)
						return c;
					const u = Vr[e],
						h = c.body.getReader(),
						d = c.headers.get('Content-Length'),
						p = d ? parseInt(d) : 0,
						g = p !== 0;
					let m = 0;
					const f = new ReadableStream({
						start(v) {
							x();
							function x() {
								h.read().then(({ done: A, value: S }) => {
									if (A) v.close();
									else {
										m += S.byteLength;
										const M = new ProgressEvent(
											'progress',
											{
												lengthComputable: g,
												loaded: m,
												total: p
											}
										);
										for (
											let I = 0, D = u.length;
											I < D;
											I++
										) {
											const G = u[I];
											G.onProgress && G.onProgress(M);
										}
										v.enqueue(S), x();
									}
								});
							}
						}
					});
					return new Response(f);
				} else
					throw Error(
						`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`
					);
			})
			.then((c) => {
				switch (l) {
				case 'arraybuffer':
					return c.arrayBuffer();
				case 'blob':
					return c.blob();
				case 'document':
					return c
						.text()
						.then((u) => new DOMParser().parseFromString(u, o));
				case 'json':
					return c.json();
				default:
					if (o === void 0) return c.text();
					{
						const u = /charset="?([^;"\s]*)"?/i.exec(o),
							h = u && u[1] ? u[1].toLowerCase() : void 0,
							d = new TextDecoder(h);
						return c.arrayBuffer().then((p) => d.decode(p));
					}
				}
			})
			.then((c) => {
				pa.add(e, c);
				const u = Vr[e];
				delete Vr[e];
				for (let h = 0, d = u.length; h < d; h++) {
					const p = u[h];
					p.onLoad && p.onLoad(c);
				}
			})
			.catch((c) => {
				const u = Vr[e];
				if (u === void 0) throw (this.manager.itemError(e), c);
				delete Vr[e];
				for (let h = 0, d = u.length; h < d; h++) {
					const p = u[h];
					p.onError && p.onError(c);
				}
				this.manager.itemError(e);
			})
			.finally(() => {
				this.manager.itemEnd(e);
			}),
		this.manager.itemStart(e);
	}
	setResponseType(e) {
		return (this.responseType = e), this;
	}
	setMimeType(e) {
		return (this.mimeType = e), this;
	}
}
class yg extends ri {
	constructor(e) {
		super(e);
	}
	load(e, t, i, n) {
		this.path !== void 0 && (e = this.path + e),
		(e = this.manager.resolveURL(e));
		const a = this,
			s = pa.get(e);
		if (s !== void 0)
			return (
				a.manager.itemStart(e),
				setTimeout(function () {
					t && t(s), a.manager.itemEnd(e);
				}, 0),
				s
			);
		const o = ys('img');
		function l() {
			u(), pa.add(e, this), t && t(this), a.manager.itemEnd(e);
		}
		function c(h) {
			u(), n && n(h), a.manager.itemError(e), a.manager.itemEnd(e);
		}
		function u() {
			o.removeEventListener('load', l, !1),
			o.removeEventListener('error', c, !1);
		}
		return (
			o.addEventListener('load', l, !1),
			o.addEventListener('error', c, !1),
			e.slice(0, 5) !== 'data:' &&
                this.crossOrigin !== void 0 &&
                (o.crossOrigin = this.crossOrigin),
			a.manager.itemStart(e),
			(o.src = e),
			o
		);
	}
}
class XS extends ri {
	constructor(e) {
		super(e);
	}
	load(e, t, i, n) {
		const a = new nl(),
			s = new yg(this.manager);
		s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
		let o = 0;
		function l(c) {
			s.load(
				e[c],
				function (u) {
					(a.images[c] = u),
					o++,
					o === 6 && ((a.needsUpdate = !0), t && t(a));
				},
				void 0,
				n
			);
		}
		for (let c = 0; c < e.length; ++c) l(c);
		return a;
	}
}
class xg extends ri {
	constructor(e) {
		super(e);
	}
	load(e, t, i, n) {
		const a = new wt(),
			s = new yg(this.manager);
		return (
			s.setCrossOrigin(this.crossOrigin),
			s.setPath(this.path),
			s.load(
				e,
				function (o) {
					(a.image = o), (a.needsUpdate = !0), t !== void 0 && t(a);
				},
				i,
				n
			),
			a
		);
	}
}
class Nr extends Je {
	constructor(e, t = 1) {
		super(),
		(this.type = 'Light'),
		(this.color = new ke(e)),
		(this.intensity = t);
	}
	dispose() {}
	copy(e) {
		return (
			super.copy(e),
			this.color.copy(e.color),
			(this.intensity = e.intensity),
			this
		);
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return (
			(t.object.color = this.color.getHex()),
			(t.object.intensity = this.intensity),
			this.groundColor !== void 0 &&
                (t.object.groundColor = this.groundColor.getHex()),
			this.distance !== void 0 && (t.object.distance = this.distance),
			this.angle !== void 0 && (t.object.angle = this.angle),
			this.decay !== void 0 && (t.object.decay = this.decay),
			this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
			this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
			t
		);
	}
}
Nr.prototype.isLight = !0;
class qS extends Nr {
	constructor(e, t, i) {
		super(e, i),
		(this.type = 'HemisphereLight'),
		this.position.copy(Je.DefaultUp),
		this.updateMatrix(),
		(this.groundColor = new ke(t));
	}
	copy(e) {
		return (
			Nr.prototype.copy.call(this, e),
			this.groundColor.copy(e.groundColor),
			this
		);
	}
}
qS.prototype.isHemisphereLight = !0;
const Cp = new Pe(),
	Pp = new C(),
	Ip = new C();
class Zu {
	constructor(e) {
		(this.camera = e),
		(this.bias = 0),
		(this.normalBias = 0),
		(this.radius = 1),
		(this.blurSamples = 8),
		(this.mapSize = new me(512, 512)),
		(this.map = null),
		(this.mapPass = null),
		(this.matrix = new Pe()),
		(this.autoUpdate = !0),
		(this.needsUpdate = !1),
		(this._frustum = new al()),
		(this._frameExtents = new me(1, 1)),
		(this._viewportCount = 1),
		(this._viewports = [new it(0, 0, 1, 1)]);
	}
	getViewportCount() {
		return this._viewportCount;
	}
	getFrustum() {
		return this._frustum;
	}
	updateMatrices(e) {
		const t = this.camera,
			i = this.matrix;
		Pp.setFromMatrixPosition(e.matrixWorld),
		t.position.copy(Pp),
		Ip.setFromMatrixPosition(e.target.matrixWorld),
		t.lookAt(Ip),
		t.updateMatrixWorld(),
		Cp.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
		this._frustum.setFromProjectionMatrix(Cp),
		i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
		i.multiply(t.projectionMatrix),
		i.multiply(t.matrixWorldInverse);
	}
	getViewport(e) {
		return this._viewports[e];
	}
	getFrameExtents() {
		return this._frameExtents;
	}
	dispose() {
		this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
	}
	copy(e) {
		return (
			(this.camera = e.camera.clone()),
			(this.bias = e.bias),
			(this.radius = e.radius),
			this.mapSize.copy(e.mapSize),
			this
		);
	}
	clone() {
		return new this.constructor().copy(this);
	}
	toJSON() {
		const e = {};
		return (
			this.bias !== 0 && (e.bias = this.bias),
			this.normalBias !== 0 && (e.normalBias = this.normalBias),
			this.radius !== 1 && (e.radius = this.radius),
			(this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
                (e.mapSize = this.mapSize.toArray()),
			(e.camera = this.camera.toJSON(!1).object),
			delete e.camera.matrix,
			e
		);
	}
}
class bg extends Zu {
	constructor() {
		super(new zt(50, 1, 0.5, 500)), (this.focus = 1);
	}
	updateMatrices(e) {
		const t = this.camera,
			i = vs * 2 * e.angle * this.focus,
			n = this.mapSize.width / this.mapSize.height,
			a = e.distance || t.far;
		(i !== t.fov || n !== t.aspect || a !== t.far) &&
            ((t.fov = i),
            (t.aspect = n),
            (t.far = a),
            t.updateProjectionMatrix()),
		super.updateMatrices(e);
	}
	copy(e) {
		return super.copy(e), (this.focus = e.focus), this;
	}
}
bg.prototype.isSpotLightShadow = !0;
class wg extends Nr {
	constructor(e, t, i = 0, n = Math.PI / 3, a = 0, s = 1) {
		super(e, t),
		(this.type = 'SpotLight'),
		this.position.copy(Je.DefaultUp),
		this.updateMatrix(),
		(this.target = new Je()),
		(this.distance = i),
		(this.angle = n),
		(this.penumbra = a),
		(this.decay = s),
		(this.shadow = new bg());
	}
	get power() {
		return this.intensity * Math.PI;
	}
	set power(e) {
		this.intensity = e / Math.PI;
	}
	dispose() {
		this.shadow.dispose();
	}
	copy(e) {
		return (
			super.copy(e),
			(this.distance = e.distance),
			(this.angle = e.angle),
			(this.penumbra = e.penumbra),
			(this.decay = e.decay),
			(this.target = e.target.clone()),
			(this.shadow = e.shadow.clone()),
			this
		);
	}
}
wg.prototype.isSpotLight = !0;
const Dp = new Pe(),
	Ha = new C(),
	cc = new C();
class _g extends Zu {
	constructor() {
		super(new zt(90, 1, 0.5, 500)),
		(this._frameExtents = new me(4, 2)),
		(this._viewportCount = 6),
		(this._viewports = [
			new it(2, 1, 1, 1),
			new it(0, 1, 1, 1),
			new it(3, 1, 1, 1),
			new it(1, 1, 1, 1),
			new it(3, 0, 1, 1),
			new it(1, 0, 1, 1)
		]),
		(this._cubeDirections = [
			new C(1, 0, 0),
			new C(-1, 0, 0),
			new C(0, 0, 1),
			new C(0, 0, -1),
			new C(0, 1, 0),
			new C(0, -1, 0)
		]),
		(this._cubeUps = [
			new C(0, 1, 0),
			new C(0, 1, 0),
			new C(0, 1, 0),
			new C(0, 1, 0),
			new C(0, 0, 1),
			new C(0, 0, -1)
		]);
	}
	updateMatrices(e, t = 0) {
		const i = this.camera,
			n = this.matrix,
			a = e.distance || i.far;
		a !== i.far && ((i.far = a), i.updateProjectionMatrix()),
		Ha.setFromMatrixPosition(e.matrixWorld),
		i.position.copy(Ha),
		cc.copy(i.position),
		cc.add(this._cubeDirections[t]),
		i.up.copy(this._cubeUps[t]),
		i.lookAt(cc),
		i.updateMatrixWorld(),
		n.makeTranslation(-Ha.x, -Ha.y, -Ha.z),
		Dp.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
		this._frustum.setFromProjectionMatrix(Dp);
	}
}
_g.prototype.isPointLightShadow = !0;
class $u extends Nr {
	constructor(e, t, i = 0, n = 1) {
		super(e, t),
		(this.type = 'PointLight'),
		(this.distance = i),
		(this.decay = n),
		(this.shadow = new _g());
	}
	get power() {
		return this.intensity * 4 * Math.PI;
	}
	set power(e) {
		this.intensity = e / (4 * Math.PI);
	}
	dispose() {
		this.shadow.dispose();
	}
	copy(e) {
		return (
			super.copy(e),
			(this.distance = e.distance),
			(this.decay = e.decay),
			(this.shadow = e.shadow.clone()),
			this
		);
	}
}
$u.prototype.isPointLight = !0;
class Mg extends Zu {
	constructor() {
		super(new sl(-5, 5, 5, -5, 0.5, 500));
	}
}
Mg.prototype.isDirectionalLightShadow = !0;
class Ku extends Nr {
	constructor(e, t) {
		super(e, t),
		(this.type = 'DirectionalLight'),
		this.position.copy(Je.DefaultUp),
		this.updateMatrix(),
		(this.target = new Je()),
		(this.shadow = new Mg());
	}
	dispose() {
		this.shadow.dispose();
	}
	copy(e) {
		return (
			super.copy(e),
			(this.target = e.target.clone()),
			(this.shadow = e.shadow.clone()),
			this
		);
	}
}
Ku.prototype.isDirectionalLight = !0;
class YS extends Nr {
	constructor(e, t) {
		super(e, t), (this.type = 'AmbientLight');
	}
}
YS.prototype.isAmbientLight = !0;
class ZS extends Nr {
	constructor(e, t, i = 10, n = 10) {
		super(e, t),
		(this.type = 'RectAreaLight'),
		(this.width = i),
		(this.height = n);
	}
	get power() {
		return this.intensity * this.width * this.height * Math.PI;
	}
	set power(e) {
		this.intensity = e / (this.width * this.height * Math.PI);
	}
	copy(e) {
		return (
			super.copy(e),
			(this.width = e.width),
			(this.height = e.height),
			this
		);
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return (
			(t.object.width = this.width), (t.object.height = this.height), t
		);
	}
}
ZS.prototype.isRectAreaLight = !0;
class Sg {
	constructor() {
		this.coefficients = [];
		for (let e = 0; e < 9; e++) this.coefficients.push(new C());
	}
	set(e) {
		for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
		return this;
	}
	zero() {
		for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
		return this;
	}
	getAt(e, t) {
		const i = e.x,
			n = e.y,
			a = e.z,
			s = this.coefficients;
		return (
			t.copy(s[0]).multiplyScalar(0.282095),
			t.addScaledVector(s[1], 0.488603 * n),
			t.addScaledVector(s[2], 0.488603 * a),
			t.addScaledVector(s[3], 0.488603 * i),
			t.addScaledVector(s[4], 1.092548 * (i * n)),
			t.addScaledVector(s[5], 1.092548 * (n * a)),
			t.addScaledVector(s[6], 0.315392 * (3 * a * a - 1)),
			t.addScaledVector(s[7], 1.092548 * (i * a)),
			t.addScaledVector(s[8], 0.546274 * (i * i - n * n)),
			t
		);
	}
	getIrradianceAt(e, t) {
		const i = e.x,
			n = e.y,
			a = e.z,
			s = this.coefficients;
		return (
			t.copy(s[0]).multiplyScalar(0.886227),
			t.addScaledVector(s[1], 2 * 0.511664 * n),
			t.addScaledVector(s[2], 2 * 0.511664 * a),
			t.addScaledVector(s[3], 2 * 0.511664 * i),
			t.addScaledVector(s[4], 2 * 0.429043 * i * n),
			t.addScaledVector(s[5], 2 * 0.429043 * n * a),
			t.addScaledVector(s[6], 0.743125 * a * a - 0.247708),
			t.addScaledVector(s[7], 2 * 0.429043 * i * a),
			t.addScaledVector(s[8], 0.429043 * (i * i - n * n)),
			t
		);
	}
	add(e) {
		for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
		return this;
	}
	addScaledSH(e, t) {
		for (let i = 0; i < 9; i++)
			this.coefficients[i].addScaledVector(e.coefficients[i], t);
		return this;
	}
	scale(e) {
		for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
		return this;
	}
	lerp(e, t) {
		for (let i = 0; i < 9; i++)
			this.coefficients[i].lerp(e.coefficients[i], t);
		return this;
	}
	equals(e) {
		for (let t = 0; t < 9; t++)
			if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
		return !0;
	}
	copy(e) {
		return this.set(e.coefficients);
	}
	clone() {
		return new this.constructor().copy(this);
	}
	fromArray(e, t = 0) {
		const i = this.coefficients;
		for (let n = 0; n < 9; n++) i[n].fromArray(e, t + n * 3);
		return this;
	}
	toArray(e = [], t = 0) {
		const i = this.coefficients;
		for (let n = 0; n < 9; n++) i[n].toArray(e, t + n * 3);
		return e;
	}
	static getBasisAt(e, t) {
		const i = e.x,
			n = e.y,
			a = e.z;
		(t[0] = 0.282095),
		(t[1] = 0.488603 * n),
		(t[2] = 0.488603 * a),
		(t[3] = 0.488603 * i),
		(t[4] = 1.092548 * i * n),
		(t[5] = 1.092548 * n * a),
		(t[6] = 0.315392 * (3 * a * a - 1)),
		(t[7] = 1.092548 * i * a),
		(t[8] = 0.546274 * (i * i - n * n));
	}
}
Sg.prototype.isSphericalHarmonics3 = !0;
class Ju extends Nr {
	constructor(e = new Sg(), t = 1) {
		super(void 0, t), (this.sh = e);
	}
	copy(e) {
		return super.copy(e), this.sh.copy(e.sh), this;
	}
	fromJSON(e) {
		return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return (t.object.sh = this.sh.toArray()), t;
	}
}
Ju.prototype.isLightProbe = !0;
class Ri {
	static decodeText(e) {
		if (typeof TextDecoder != 'undefined')
			return new TextDecoder().decode(e);
		let t = '';
		for (let i = 0, n = e.length; i < n; i++)
			t += String.fromCharCode(e[i]);
		try {
			return decodeURIComponent(escape(t));
		} catch {
			return t;
		}
	}
	static extractUrlBase(e) {
		const t = e.lastIndexOf('/');
		return t === -1 ? './' : e.slice(0, t + 1);
	}
	static resolveURL(e, t) {
		return typeof e != 'string' || e === ''
			? ''
			: (/^https?:\/\//i.test(t) &&
                  /^\//.test(e) &&
                  (t = t.replace(/(^https?:\/\/[^\/]+).*/i, '$1')),
			/^(https?:)?\/\//i.test(e) ||
              /^data:.*,.*$/i.test(e) ||
              /^blob:.*$/i.test(e)
				? e
				: t + e);
	}
}
class $S extends ot {
	constructor() {
		super(),
		(this.type = 'InstancedBufferGeometry'),
		(this.instanceCount = 1 / 0);
	}
	copy(e) {
		return super.copy(e), (this.instanceCount = e.instanceCount), this;
	}
	clone() {
		return new this.constructor().copy(this);
	}
	toJSON() {
		const e = super.toJSON(this);
		return (
			(e.instanceCount = this.instanceCount),
			(e.isInstancedBufferGeometry = !0),
			e
		);
	}
}
$S.prototype.isInstancedBufferGeometry = !0;
class Tg extends ri {
	constructor(e) {
		super(e),
		typeof createImageBitmap == 'undefined' &&
                console.warn(
                	'THREE.ImageBitmapLoader: createImageBitmap() not supported.'
                ),
		typeof fetch == 'undefined' &&
                console.warn('THREE.ImageBitmapLoader: fetch() not supported.'),
		(this.options = { premultiplyAlpha: 'none' });
	}
	setOptions(e) {
		return (this.options = e), this;
	}
	load(e, t, i, n) {
		e === void 0 && (e = ''),
		this.path !== void 0 && (e = this.path + e),
		(e = this.manager.resolveURL(e));
		const a = this,
			s = pa.get(e);
		if (s !== void 0)
			return (
				a.manager.itemStart(e),
				setTimeout(function () {
					t && t(s), a.manager.itemEnd(e);
				}, 0),
				s
			);
		const o = {};
		(o.credentials =
            this.crossOrigin === 'anonymous' ? 'same-origin' : 'include'),
		(o.headers = this.requestHeader),
		fetch(e, o)
			.then(function (l) {
				return l.blob();
			})
			.then(function (l) {
				return createImageBitmap(
					l,
					Object.assign(a.options, {
						colorSpaceConversion: 'none'
					})
				);
			})
			.then(function (l) {
				pa.add(e, l), t && t(l), a.manager.itemEnd(e);
			})
			.catch(function (l) {
				n && n(l), a.manager.itemError(e), a.manager.itemEnd(e);
			}),
		a.manager.itemStart(e);
	}
}
Tg.prototype.isImageBitmapLoader = !0;
let go;
const KS = {
	getContext: function () {
		return (
			go === void 0 &&
                (go = new (window.AudioContext || window.webkitAudioContext)()),
			go
		);
	},
	setContext: function (r) {
		go = r;
	}
};
class JS extends ri {
	constructor(e) {
		super(e);
	}
	load(e, t, i, n) {
		const a = this,
			s = new Yu(this.manager);
		s.setResponseType('arraybuffer'),
		s.setPath(this.path),
		s.setRequestHeader(this.requestHeader),
		s.setWithCredentials(this.withCredentials),
		s.load(
			e,
			function (o) {
				try {
					const l = o.slice(0);
					KS.getContext().decodeAudioData(l, function (c) {
						t(c);
					});
				} catch (l) {
					n ? n(l) : console.error(l), a.manager.itemError(e);
				}
			},
			i,
			n
		);
	}
}
class QS extends Ju {
	constructor(e, t, i = 1) {
		super(void 0, i);
		const n = new ke().set(e),
			a = new ke().set(t),
			s = new C(n.r, n.g, n.b),
			o = new C(a.r, a.g, a.b),
			l = Math.sqrt(Math.PI),
			c = l * Math.sqrt(0.75);
		this.sh.coefficients[0].copy(s).add(o).multiplyScalar(l),
		this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(c);
	}
}
QS.prototype.isHemisphereLightProbe = !0;
class e2 extends Ju {
	constructor(e, t = 1) {
		super(void 0, t);
		const i = new ke().set(e);
		this.sh.coefficients[0]
			.set(i.r, i.g, i.b)
			.multiplyScalar(2 * Math.sqrt(Math.PI));
	}
}
e2.prototype.isAmbientLightProbe = !0;
class t2 extends Je {
	constructor(e) {
		super(),
		(this.type = 'Audio'),
		(this.listener = e),
		(this.context = e.context),
		(this.gain = this.context.createGain()),
		this.gain.connect(e.getInput()),
		(this.autoplay = !1),
		(this.buffer = null),
		(this.detune = 0),
		(this.loop = !1),
		(this.loopStart = 0),
		(this.loopEnd = 0),
		(this.offset = 0),
		(this.duration = void 0),
		(this.playbackRate = 1),
		(this.isPlaying = !1),
		(this.hasPlaybackControl = !0),
		(this.source = null),
		(this.sourceType = 'empty'),
		(this._startedAt = 0),
		(this._progress = 0),
		(this._connected = !1),
		(this.filters = []);
	}
	getOutput() {
		return this.gain;
	}
	setNodeSource(e) {
		return (
			(this.hasPlaybackControl = !1),
			(this.sourceType = 'audioNode'),
			(this.source = e),
			this.connect(),
			this
		);
	}
	setMediaElementSource(e) {
		return (
			(this.hasPlaybackControl = !1),
			(this.sourceType = 'mediaNode'),
			(this.source = this.context.createMediaElementSource(e)),
			this.connect(),
			this
		);
	}
	setMediaStreamSource(e) {
		return (
			(this.hasPlaybackControl = !1),
			(this.sourceType = 'mediaStreamNode'),
			(this.source = this.context.createMediaStreamSource(e)),
			this.connect(),
			this
		);
	}
	setBuffer(e) {
		return (
			(this.buffer = e),
			(this.sourceType = 'buffer'),
			this.autoplay && this.play(),
			this
		);
	}
	play(e = 0) {
		if (this.isPlaying === !0) {
			console.warn('THREE.Audio: Audio is already playing.');
			return;
		}
		if (this.hasPlaybackControl === !1) {
			console.warn('THREE.Audio: this Audio has no playback control.');
			return;
		}
		this._startedAt = this.context.currentTime + e;
		const t = this.context.createBufferSource();
		return (
			(t.buffer = this.buffer),
			(t.loop = this.loop),
			(t.loopStart = this.loopStart),
			(t.loopEnd = this.loopEnd),
			(t.onended = this.onEnded.bind(this)),
			t.start(
				this._startedAt,
				this._progress + this.offset,
				this.duration
			),
			(this.isPlaying = !0),
			(this.source = t),
			this.setDetune(this.detune),
			this.setPlaybackRate(this.playbackRate),
			this.connect()
		);
	}
	pause() {
		if (this.hasPlaybackControl === !1) {
			console.warn('THREE.Audio: this Audio has no playback control.');
			return;
		}
		return (
			this.isPlaying === !0 &&
                ((this._progress +=
                    Math.max(this.context.currentTime - this._startedAt, 0) *
                    this.playbackRate),
                this.loop === !0 &&
                    (this._progress =
                        this._progress %
                        (this.duration || this.buffer.duration)),
                this.source.stop(),
                (this.source.onended = null),
                (this.isPlaying = !1)),
			this
		);
	}
	stop() {
		if (this.hasPlaybackControl === !1) {
			console.warn('THREE.Audio: this Audio has no playback control.');
			return;
		}
		return (
			(this._progress = 0),
			this.source.stop(),
			(this.source.onended = null),
			(this.isPlaying = !1),
			this
		);
	}
	connect() {
		if (this.filters.length > 0) {
			this.source.connect(this.filters[0]);
			for (let e = 1, t = this.filters.length; e < t; e++)
				this.filters[e - 1].connect(this.filters[e]);
			this.filters[this.filters.length - 1].connect(this.getOutput());
		} else this.source.connect(this.getOutput());
		return (this._connected = !0), this;
	}
	disconnect() {
		if (this.filters.length > 0) {
			this.source.disconnect(this.filters[0]);
			for (let e = 1, t = this.filters.length; e < t; e++)
				this.filters[e - 1].disconnect(this.filters[e]);
			this.filters[this.filters.length - 1].disconnect(this.getOutput());
		} else this.source.disconnect(this.getOutput());
		return (this._connected = !1), this;
	}
	getFilters() {
		return this.filters;
	}
	setFilters(e) {
		return (
			e || (e = []),
			this._connected === !0
				? (this.disconnect(),
				(this.filters = e.slice()),
				this.connect())
				: (this.filters = e.slice()),
			this
		);
	}
	setDetune(e) {
		if (((this.detune = e), this.source.detune !== void 0))
			return (
				this.isPlaying === !0 &&
                    this.source.detune.setTargetAtTime(
                    	this.detune,
                    	this.context.currentTime,
                    	0.01
                    ),
				this
			);
	}
	getDetune() {
		return this.detune;
	}
	getFilter() {
		return this.getFilters()[0];
	}
	setFilter(e) {
		return this.setFilters(e ? [e] : []);
	}
	setPlaybackRate(e) {
		if (this.hasPlaybackControl === !1) {
			console.warn('THREE.Audio: this Audio has no playback control.');
			return;
		}
		return (
			(this.playbackRate = e),
			this.isPlaying === !0 &&
                this.source.playbackRate.setTargetAtTime(
                	this.playbackRate,
                	this.context.currentTime,
                	0.01
                ),
			this
		);
	}
	getPlaybackRate() {
		return this.playbackRate;
	}
	onEnded() {
		this.isPlaying = !1;
	}
	getLoop() {
		return this.hasPlaybackControl === !1
			? (console.warn('THREE.Audio: this Audio has no playback control.'),
			!1)
			: this.loop;
	}
	setLoop(e) {
		if (this.hasPlaybackControl === !1) {
			console.warn('THREE.Audio: this Audio has no playback control.');
			return;
		}
		return (
			(this.loop = e),
			this.isPlaying === !0 && (this.source.loop = this.loop),
			this
		);
	}
	setLoopStart(e) {
		return (this.loopStart = e), this;
	}
	setLoopEnd(e) {
		return (this.loopEnd = e), this;
	}
	getVolume() {
		return this.gain.gain.value;
	}
	setVolume(e) {
		return (
			this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01),
			this
		);
	}
}
class r2 {
	constructor(e, t, i) {
		(this.binding = e), (this.valueSize = i);
		let n, a, s;
		switch (t) {
		case 'quaternion':
			(n = this._slerp),
			(a = this._slerpAdditive),
			(s = this._setAdditiveIdentityQuaternion),
			(this.buffer = new Float64Array(i * 6)),
			(this._workIndex = 5);
			break;
		case 'string':
		case 'bool':
			(n = this._select),
			(a = this._select),
			(s = this._setAdditiveIdentityOther),
			(this.buffer = new Array(i * 5));
			break;
		default:
			(n = this._lerp),
			(a = this._lerpAdditive),
			(s = this._setAdditiveIdentityNumeric),
			(this.buffer = new Float64Array(i * 5));
		}
		(this._mixBufferRegion = n),
		(this._mixBufferRegionAdditive = a),
		(this._setIdentity = s),
		(this._origIndex = 3),
		(this._addIndex = 4),
		(this.cumulativeWeight = 0),
		(this.cumulativeWeightAdditive = 0),
		(this.useCount = 0),
		(this.referenceCount = 0);
	}
	accumulate(e, t) {
		const i = this.buffer,
			n = this.valueSize,
			a = e * n + n;
		let s = this.cumulativeWeight;
		if (s === 0) {
			for (let o = 0; o !== n; ++o) i[a + o] = i[o];
			s = t;
		} else {
			s += t;
			const o = t / s;
			this._mixBufferRegion(i, a, 0, o, n);
		}
		this.cumulativeWeight = s;
	}
	accumulateAdditive(e) {
		const t = this.buffer,
			i = this.valueSize,
			n = i * this._addIndex;
		this.cumulativeWeightAdditive === 0 && this._setIdentity(),
		this._mixBufferRegionAdditive(t, n, 0, e, i),
		(this.cumulativeWeightAdditive += e);
	}
	apply(e) {
		const t = this.valueSize,
			i = this.buffer,
			n = e * t + t,
			a = this.cumulativeWeight,
			s = this.cumulativeWeightAdditive,
			o = this.binding;
		if (
			((this.cumulativeWeight = 0),
			(this.cumulativeWeightAdditive = 0),
			a < 1)
		) {
			const l = t * this._origIndex;
			this._mixBufferRegion(i, n, l, 1 - a, t);
		}
		s > 0 && this._mixBufferRegionAdditive(i, n, this._addIndex * t, 1, t);
		for (let l = t, c = t + t; l !== c; ++l)
			if (i[l] !== i[l + t]) {
				o.setValue(i, n);
				break;
			}
	}
	saveOriginalState() {
		const e = this.binding,
			t = this.buffer,
			i = this.valueSize,
			n = i * this._origIndex;
		e.getValue(t, n);
		for (let a = i, s = n; a !== s; ++a) t[a] = t[n + (a % i)];
		this._setIdentity(),
		(this.cumulativeWeight = 0),
		(this.cumulativeWeightAdditive = 0);
	}
	restoreOriginalState() {
		const e = this.valueSize * 3;
		this.binding.setValue(this.buffer, e);
	}
	_setAdditiveIdentityNumeric() {
		const e = this._addIndex * this.valueSize,
			t = e + this.valueSize;
		for (let i = e; i < t; i++) this.buffer[i] = 0;
	}
	_setAdditiveIdentityQuaternion() {
		this._setAdditiveIdentityNumeric(),
		(this.buffer[this._addIndex * this.valueSize + 3] = 1);
	}
	_setAdditiveIdentityOther() {
		const e = this._origIndex * this.valueSize,
			t = this._addIndex * this.valueSize;
		for (let i = 0; i < this.valueSize; i++)
			this.buffer[t + i] = this.buffer[e + i];
	}
	_select(e, t, i, n, a) {
		if (n >= 0.5) for (let s = 0; s !== a; ++s) e[t + s] = e[i + s];
	}
	_slerp(e, t, i, n) {
		Ct.slerpFlat(e, t, e, t, e, i, n);
	}
	_slerpAdditive(e, t, i, n, a) {
		const s = this._workIndex * a;
		Ct.multiplyQuaternionsFlat(e, s, e, t, e, i),
		Ct.slerpFlat(e, t, e, t, e, s, n);
	}
	_lerp(e, t, i, n, a) {
		const s = 1 - n;
		for (let o = 0; o !== a; ++o) {
			const l = t + o;
			e[l] = e[l] * s + e[i + o] * n;
		}
	}
	_lerpAdditive(e, t, i, n, a) {
		for (let s = 0; s !== a; ++s) {
			const o = t + s;
			e[o] = e[o] + e[i + s] * n;
		}
	}
}
const Qu = '\\[\\]\\.:\\/',
	i2 = new RegExp('[' + Qu + ']', 'g'),
	eh = '[^' + Qu + ']',
	n2 = '[^' + Qu.replace('\\.', '') + ']',
	a2 = /((?:WC+[\/:])*)/.source.replace('WC', eh),
	s2 = /(WCOD+)?/.source.replace('WCOD', n2),
	o2 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', eh),
	l2 = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', eh),
	c2 = new RegExp('^' + a2 + s2 + o2 + l2 + '$'),
	u2 = ['material', 'materials', 'bones'];
class h2 {
	constructor(e, t, i) {
		const n = i || et.parseTrackName(t);
		(this._targetGroup = e), (this._bindings = e.subscribe_(t, n));
	}
	getValue(e, t) {
		this.bind();
		const i = this._targetGroup.nCachedObjects_,
			n = this._bindings[i];
		n !== void 0 && n.getValue(e, t);
	}
	setValue(e, t) {
		const i = this._bindings;
		for (
			let n = this._targetGroup.nCachedObjects_, a = i.length;
			n !== a;
			++n
		)
			i[n].setValue(e, t);
	}
	bind() {
		const e = this._bindings;
		for (
			let t = this._targetGroup.nCachedObjects_, i = e.length;
			t !== i;
			++t
		)
			e[t].bind();
	}
	unbind() {
		const e = this._bindings;
		for (
			let t = this._targetGroup.nCachedObjects_, i = e.length;
			t !== i;
			++t
		)
			e[t].unbind();
	}
}
class et {
	constructor(e, t, i) {
		(this.path = t),
		(this.parsedPath = i || et.parseTrackName(t)),
		(this.node = et.findNode(e, this.parsedPath.nodeName) || e),
		(this.rootNode = e),
		(this.getValue = this._getValue_unbound),
		(this.setValue = this._setValue_unbound);
	}
	static create(e, t, i) {
		return e && e.isAnimationObjectGroup
			? new et.Composite(e, t, i)
			: new et(e, t, i);
	}
	static sanitizeNodeName(e) {
		return e.replace(/\s/g, '_').replace(i2, '');
	}
	static parseTrackName(e) {
		const t = c2.exec(e);
		if (t === null)
			throw new Error('PropertyBinding: Cannot parse trackName: ' + e);
		const i = {
				nodeName: t[2],
				objectName: t[3],
				objectIndex: t[4],
				propertyName: t[5],
				propertyIndex: t[6]
			},
			n = i.nodeName && i.nodeName.lastIndexOf('.');
		if (n !== void 0 && n !== -1) {
			const a = i.nodeName.substring(n + 1);
			u2.indexOf(a) !== -1 &&
                ((i.nodeName = i.nodeName.substring(0, n)), (i.objectName = a));
		}
		if (i.propertyName === null || i.propertyName.length === 0)
			throw new Error(
				'PropertyBinding: can not parse propertyName from trackName: ' +
                    e
			);
		return i;
	}
	static findNode(e, t) {
		if (
			t === void 0 ||
            t === '' ||
            t === '.' ||
            t === -1 ||
            t === e.name ||
            t === e.uuid
		)
			return e;
		if (e.skeleton) {
			const i = e.skeleton.getBoneByName(t);
			if (i !== void 0) return i;
		}
		if (e.children) {
			const i = function (a) {
					for (let s = 0; s < a.length; s++) {
						const o = a[s];
						if (o.name === t || o.uuid === t) return o;
						const l = i(o.children);
						if (l) return l;
					}
					return null;
				},
				n = i(e.children);
			if (n) return n;
		}
		return null;
	}
	_getValue_unavailable() {}
	_setValue_unavailable() {}
	_getValue_direct(e, t) {
		e[t] = this.targetObject[this.propertyName];
	}
	_getValue_array(e, t) {
		const i = this.resolvedProperty;
		for (let n = 0, a = i.length; n !== a; ++n) e[t++] = i[n];
	}
	_getValue_arrayElement(e, t) {
		e[t] = this.resolvedProperty[this.propertyIndex];
	}
	_getValue_toArray(e, t) {
		this.resolvedProperty.toArray(e, t);
	}
	_setValue_direct(e, t) {
		this.targetObject[this.propertyName] = e[t];
	}
	_setValue_direct_setNeedsUpdate(e, t) {
		(this.targetObject[this.propertyName] = e[t]),
		(this.targetObject.needsUpdate = !0);
	}
	_setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
		(this.targetObject[this.propertyName] = e[t]),
		(this.targetObject.matrixWorldNeedsUpdate = !0);
	}
	_setValue_array(e, t) {
		const i = this.resolvedProperty;
		for (let n = 0, a = i.length; n !== a; ++n) i[n] = e[t++];
	}
	_setValue_array_setNeedsUpdate(e, t) {
		const i = this.resolvedProperty;
		for (let n = 0, a = i.length; n !== a; ++n) i[n] = e[t++];
		this.targetObject.needsUpdate = !0;
	}
	_setValue_array_setMatrixWorldNeedsUpdate(e, t) {
		const i = this.resolvedProperty;
		for (let n = 0, a = i.length; n !== a; ++n) i[n] = e[t++];
		this.targetObject.matrixWorldNeedsUpdate = !0;
	}
	_setValue_arrayElement(e, t) {
		this.resolvedProperty[this.propertyIndex] = e[t];
	}
	_setValue_arrayElement_setNeedsUpdate(e, t) {
		(this.resolvedProperty[this.propertyIndex] = e[t]),
		(this.targetObject.needsUpdate = !0);
	}
	_setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
		(this.resolvedProperty[this.propertyIndex] = e[t]),
		(this.targetObject.matrixWorldNeedsUpdate = !0);
	}
	_setValue_fromArray(e, t) {
		this.resolvedProperty.fromArray(e, t);
	}
	_setValue_fromArray_setNeedsUpdate(e, t) {
		this.resolvedProperty.fromArray(e, t),
		(this.targetObject.needsUpdate = !0);
	}
	_setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
		this.resolvedProperty.fromArray(e, t),
		(this.targetObject.matrixWorldNeedsUpdate = !0);
	}
	_getValue_unbound(e, t) {
		this.bind(), this.getValue(e, t);
	}
	_setValue_unbound(e, t) {
		this.bind(), this.setValue(e, t);
	}
	bind() {
		let e = this.node;
		const t = this.parsedPath,
			i = t.objectName,
			n = t.propertyName;
		let a = t.propertyIndex;
		if (
			(e ||
                ((e = et.findNode(this.rootNode, t.nodeName) || this.rootNode),
                (this.node = e)),
			(this.getValue = this._getValue_unavailable),
			(this.setValue = this._setValue_unavailable),
			!e)
		) {
			console.error(
				'THREE.PropertyBinding: Trying to update node for track: ' +
                    this.path +
                    ' but it wasn\'t found.'
			);
			return;
		}
		if (i) {
			let c = t.objectIndex;
			switch (i) {
			case 'materials':
				if (!e.material) {
					console.error(
						'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
						this
					);
					return;
				}
				if (!e.material.materials) {
					console.error(
						'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',
						this
					);
					return;
				}
				e = e.material.materials;
				break;
			case 'bones':
				if (!e.skeleton) {
					console.error(
						'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',
						this
					);
					return;
				}
				e = e.skeleton.bones;
				for (let u = 0; u < e.length; u++)
					if (e[u].name === c) {
						c = u;
						break;
					}
				break;
			default:
				if (e[i] === void 0) {
					console.error(
						'THREE.PropertyBinding: Can not bind to objectName of node undefined.',
						this
					);
					return;
				}
				e = e[i];
			}
			if (c !== void 0) {
				if (e[c] === void 0) {
					console.error(
						'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',
						this,
						e
					);
					return;
				}
				e = e[c];
			}
		}
		const s = e[n];
		if (s === void 0) {
			const c = t.nodeName;
			console.error(
				'THREE.PropertyBinding: Trying to update property for track: ' +
                    c +
                    '.' +
                    n +
                    ' but it wasn\'t found.',
				e
			);
			return;
		}
		let o = this.Versioning.None;
		(this.targetObject = e),
		e.needsUpdate !== void 0
			? (o = this.Versioning.NeedsUpdate)
			: e.matrixWorldNeedsUpdate !== void 0 &&
                  (o = this.Versioning.MatrixWorldNeedsUpdate);
		let l = this.BindingType.Direct;
		if (a !== void 0) {
			if (n === 'morphTargetInfluences') {
				if (!e.geometry) {
					console.error(
						'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',
						this
					);
					return;
				}
				if (e.geometry.isBufferGeometry) {
					if (!e.geometry.morphAttributes) {
						console.error(
							'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',
							this
						);
						return;
					}
					e.morphTargetDictionary[a] !== void 0 &&
                        (a = e.morphTargetDictionary[a]);
				} else {
					console.error(
						'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.',
						this
					);
					return;
				}
			}
			(l = this.BindingType.ArrayElement),
			(this.resolvedProperty = s),
			(this.propertyIndex = a);
		} else
			s.fromArray !== void 0 && s.toArray !== void 0
				? ((l = this.BindingType.HasFromToArray),
				(this.resolvedProperty = s))
				: Array.isArray(s)
					? ((l = this.BindingType.EntireArray),
					(this.resolvedProperty = s))
					: (this.propertyName = n);
		(this.getValue = this.GetterByBindingType[l]),
		(this.setValue = this.SetterByBindingTypeAndVersioning[l][o]);
	}
	unbind() {
		(this.node = null),
		(this.getValue = this._getValue_unbound),
		(this.setValue = this._setValue_unbound);
	}
}
et.Composite = h2;
et.prototype.BindingType = {
	Direct: 0,
	EntireArray: 1,
	ArrayElement: 2,
	HasFromToArray: 3
};
et.prototype.Versioning = {
	None: 0,
	NeedsUpdate: 1,
	MatrixWorldNeedsUpdate: 2
};
et.prototype.GetterByBindingType = [
	et.prototype._getValue_direct,
	et.prototype._getValue_array,
	et.prototype._getValue_arrayElement,
	et.prototype._getValue_toArray
];
et.prototype.SetterByBindingTypeAndVersioning = [
	[
		et.prototype._setValue_direct,
		et.prototype._setValue_direct_setNeedsUpdate,
		et.prototype._setValue_direct_setMatrixWorldNeedsUpdate
	],
	[
		et.prototype._setValue_array,
		et.prototype._setValue_array_setNeedsUpdate,
		et.prototype._setValue_array_setMatrixWorldNeedsUpdate
	],
	[
		et.prototype._setValue_arrayElement,
		et.prototype._setValue_arrayElement_setNeedsUpdate,
		et.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
	],
	[
		et.prototype._setValue_fromArray,
		et.prototype._setValue_fromArray_setNeedsUpdate,
		et.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
	]
];
class d2 {
	constructor(e, t, i = null, n = t.blendMode) {
		(this._mixer = e),
		(this._clip = t),
		(this._localRoot = i),
		(this.blendMode = n);
		const a = t.tracks,
			s = a.length,
			o = new Array(s),
			l = { endingStart: Xn, endingEnd: Xn };
		for (let c = 0; c !== s; ++c) {
			const u = a[c].createInterpolant(null);
			(o[c] = u), (u.settings = l);
		}
		(this._interpolantSettings = l),
		(this._interpolants = o),
		(this._propertyBindings = new Array(s)),
		(this._cacheIndex = null),
		(this._byClipCacheIndex = null),
		(this._timeScaleInterpolant = null),
		(this._weightInterpolant = null),
		(this.loop = Wx),
		(this._loopCount = -1),
		(this._startTime = null),
		(this.time = 0),
		(this.timeScale = 1),
		(this._effectiveTimeScale = 1),
		(this.weight = 1),
		(this._effectiveWeight = 1),
		(this.repetitions = 1 / 0),
		(this.paused = !1),
		(this.enabled = !0),
		(this.clampWhenFinished = !1),
		(this.zeroSlopeAtStart = !0),
		(this.zeroSlopeAtEnd = !0);
	}
	play() {
		return this._mixer._activateAction(this), this;
	}
	stop() {
		return this._mixer._deactivateAction(this), this.reset();
	}
	reset() {
		return (
			(this.paused = !1),
			(this.enabled = !0),
			(this.time = 0),
			(this._loopCount = -1),
			(this._startTime = null),
			this.stopFading().stopWarping()
		);
	}
	isRunning() {
		return (
			this.enabled &&
            !this.paused &&
            this.timeScale !== 0 &&
            this._startTime === null &&
            this._mixer._isActiveAction(this)
		);
	}
	isScheduled() {
		return this._mixer._isActiveAction(this);
	}
	startAt(e) {
		return (this._startTime = e), this;
	}
	setLoop(e, t) {
		return (this.loop = e), (this.repetitions = t), this;
	}
	setEffectiveWeight(e) {
		return (
			(this.weight = e),
			(this._effectiveWeight = this.enabled ? e : 0),
			this.stopFading()
		);
	}
	getEffectiveWeight() {
		return this._effectiveWeight;
	}
	fadeIn(e) {
		return this._scheduleFading(e, 0, 1);
	}
	fadeOut(e) {
		return this._scheduleFading(e, 1, 0);
	}
	crossFadeFrom(e, t, i) {
		if ((e.fadeOut(t), this.fadeIn(t), i)) {
			const n = this._clip.duration,
				a = e._clip.duration,
				s = a / n,
				o = n / a;
			e.warp(1, s, t), this.warp(o, 1, t);
		}
		return this;
	}
	crossFadeTo(e, t, i) {
		return e.crossFadeFrom(this, t, i);
	}
	stopFading() {
		const e = this._weightInterpolant;
		return (
			e !== null &&
                ((this._weightInterpolant = null),
                this._mixer._takeBackControlInterpolant(e)),
			this
		);
	}
	setEffectiveTimeScale(e) {
		return (
			(this.timeScale = e),
			(this._effectiveTimeScale = this.paused ? 0 : e),
			this.stopWarping()
		);
	}
	getEffectiveTimeScale() {
		return this._effectiveTimeScale;
	}
	setDuration(e) {
		return (this.timeScale = this._clip.duration / e), this.stopWarping();
	}
	syncWith(e) {
		return (
			(this.time = e.time),
			(this.timeScale = e.timeScale),
			this.stopWarping()
		);
	}
	halt(e) {
		return this.warp(this._effectiveTimeScale, 0, e);
	}
	warp(e, t, i) {
		const n = this._mixer,
			a = n.time,
			s = this.timeScale;
		let o = this._timeScaleInterpolant;
		o === null &&
            ((o = n._lendControlInterpolant()),
            (this._timeScaleInterpolant = o));
		const l = o.parameterPositions,
			c = o.sampleValues;
		return (l[0] = a), (l[1] = a + i), (c[0] = e / s), (c[1] = t / s), this;
	}
	stopWarping() {
		const e = this._timeScaleInterpolant;
		return (
			e !== null &&
                ((this._timeScaleInterpolant = null),
                this._mixer._takeBackControlInterpolant(e)),
			this
		);
	}
	getMixer() {
		return this._mixer;
	}
	getClip() {
		return this._clip;
	}
	getRoot() {
		return this._localRoot || this._mixer._root;
	}
	_update(e, t, i, n) {
		if (!this.enabled) {
			this._updateWeight(e);
			return;
		}
		const a = this._startTime;
		if (a !== null) {
			const l = (e - a) * i;
			if (l < 0 || i === 0) return;
			(this._startTime = null), (t = i * l);
		}
		t *= this._updateTimeScale(e);
		const s = this._updateTime(t),
			o = this._updateWeight(e);
		if (o > 0) {
			const l = this._interpolants,
				c = this._propertyBindings;
			switch (this.blendMode) {
			case Rf:
				for (let u = 0, h = l.length; u !== h; ++u)
					l[u].evaluate(s), c[u].accumulateAdditive(o);
				break;
			case ku:
			default:
				for (let u = 0, h = l.length; u !== h; ++u)
					l[u].evaluate(s), c[u].accumulate(n, o);
			}
		}
	}
	_updateWeight(e) {
		let t = 0;
		if (this.enabled) {
			t = this.weight;
			const i = this._weightInterpolant;
			if (i !== null) {
				const n = i.evaluate(e)[0];
				(t *= n),
				e > i.parameterPositions[1] &&
                        (this.stopFading(), n === 0 && (this.enabled = !1));
			}
		}
		return (this._effectiveWeight = t), t;
	}
	_updateTimeScale(e) {
		let t = 0;
		if (!this.paused) {
			t = this.timeScale;
			const i = this._timeScaleInterpolant;
			i !== null &&
                ((t *= i.evaluate(e)[0]),
                e > i.parameterPositions[1] &&
                    (this.stopWarping(),
                    t === 0 ? (this.paused = !0) : (this.timeScale = t)));
		}
		return (this._effectiveTimeScale = t), t;
	}
	_updateTime(e) {
		const t = this._clip.duration,
			i = this.loop;
		let n = this.time + e,
			a = this._loopCount;
		const s = i === jx;
		if (e === 0) return a === -1 ? n : s && (a & 1) === 1 ? t - n : n;
		if (i === Vx) {
			a === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
			e: {
				if (n >= t) n = t;
				else if (n < 0) n = 0;
				else {
					this.time = n;
					break e;
				}
				this.clampWhenFinished
					? (this.paused = !0)
					: (this.enabled = !1),
				(this.time = n),
				this._mixer.dispatchEvent({
					type: 'finished',
					action: this,
					direction: e < 0 ? -1 : 1
				});
			}
		} else {
			if (
				(a === -1 &&
                    (e >= 0
                    	? ((a = 0),
                    	this._setEndings(!0, this.repetitions === 0, s))
                    	: this._setEndings(this.repetitions === 0, !0, s)),
				n >= t || n < 0)
			) {
				const o = Math.floor(n / t);
				(n -= t * o), (a += Math.abs(o));
				const l = this.repetitions - a;
				if (l <= 0)
					this.clampWhenFinished
						? (this.paused = !0)
						: (this.enabled = !1),
					(n = e > 0 ? t : 0),
					(this.time = n),
					this._mixer.dispatchEvent({
						type: 'finished',
						action: this,
						direction: e > 0 ? 1 : -1
					});
				else {
					if (l === 1) {
						const c = e < 0;
						this._setEndings(c, !c, s);
					} else this._setEndings(!1, !1, s);
					(this._loopCount = a),
					(this.time = n),
					this._mixer.dispatchEvent({
						type: 'loop',
						action: this,
						loopDelta: o
					});
				}
			} else this.time = n;
			if (s && (a & 1) === 1) return t - n;
		}
		return n;
	}
	_setEndings(e, t, i) {
		const n = this._interpolantSettings;
		i
			? ((n.endingStart = qn), (n.endingEnd = qn))
			: (e
				? (n.endingStart = this.zeroSlopeAtStart ? qn : Xn)
				: (n.endingStart = No),
			t
				? (n.endingEnd = this.zeroSlopeAtEnd ? qn : Xn)
				: (n.endingEnd = No));
	}
	_scheduleFading(e, t, i) {
		const n = this._mixer,
			a = n.time;
		let s = this._weightInterpolant;
		s === null &&
            ((s = n._lendControlInterpolant()), (this._weightInterpolant = s));
		const o = s.parameterPositions,
			l = s.sampleValues;
		return (o[0] = a), (l[0] = t), (o[1] = a + e), (l[1] = i), this;
	}
}
class p2 extends Di {
	constructor(e) {
		super(),
		(this._root = e),
		this._initMemoryManager(),
		(this._accuIndex = 0),
		(this.time = 0),
		(this.timeScale = 1);
	}
	_bindAction(e, t) {
		const i = e._localRoot || this._root,
			n = e._clip.tracks,
			a = n.length,
			s = e._propertyBindings,
			o = e._interpolants,
			l = i.uuid,
			c = this._bindingsByRootAndName;
		let u = c[l];
		u === void 0 && ((u = {}), (c[l] = u));
		for (let h = 0; h !== a; ++h) {
			const d = n[h],
				p = d.name;
			let g = u[p];
			if (g !== void 0) ++g.referenceCount, (s[h] = g);
			else {
				if (((g = s[h]), g !== void 0)) {
					g._cacheIndex === null &&
                        (++g.referenceCount, this._addInactiveBinding(g, l, p));
					continue;
				}
				const m = t && t._propertyBindings[h].binding.parsedPath;
				(g = new r2(
					et.create(i, p, m),
					d.ValueTypeName,
					d.getValueSize()
				)),
				++g.referenceCount,
				this._addInactiveBinding(g, l, p),
				(s[h] = g);
			}
			o[h].resultBuffer = g.buffer;
		}
	}
	_activateAction(e) {
		if (!this._isActiveAction(e)) {
			if (e._cacheIndex === null) {
				const i = (e._localRoot || this._root).uuid,
					n = e._clip.uuid,
					a = this._actionsByClip[n];
				this._bindAction(e, a && a.knownActions[0]),
				this._addInactiveAction(e, n, i);
			}
			const t = e._propertyBindings;
			for (let i = 0, n = t.length; i !== n; ++i) {
				const a = t[i];
				a.useCount++ === 0 &&
                    (this._lendBinding(a), a.saveOriginalState());
			}
			this._lendAction(e);
		}
	}
	_deactivateAction(e) {
		if (this._isActiveAction(e)) {
			const t = e._propertyBindings;
			for (let i = 0, n = t.length; i !== n; ++i) {
				const a = t[i];
				--a.useCount === 0 &&
                    (a.restoreOriginalState(), this._takeBackBinding(a));
			}
			this._takeBackAction(e);
		}
	}
	_initMemoryManager() {
		(this._actions = []),
		(this._nActiveActions = 0),
		(this._actionsByClip = {}),
		(this._bindings = []),
		(this._nActiveBindings = 0),
		(this._bindingsByRootAndName = {}),
		(this._controlInterpolants = []),
		(this._nActiveControlInterpolants = 0);
		const e = this;
		this.stats = {
			actions: {
				get total() {
					return e._actions.length;
				},
				get inUse() {
					return e._nActiveActions;
				}
			},
			bindings: {
				get total() {
					return e._bindings.length;
				},
				get inUse() {
					return e._nActiveBindings;
				}
			},
			controlInterpolants: {
				get total() {
					return e._controlInterpolants.length;
				},
				get inUse() {
					return e._nActiveControlInterpolants;
				}
			}
		};
	}
	_isActiveAction(e) {
		const t = e._cacheIndex;
		return t !== null && t < this._nActiveActions;
	}
	_addInactiveAction(e, t, i) {
		const n = this._actions,
			a = this._actionsByClip;
		let s = a[t];
		if (s === void 0)
			(s = { knownActions: [e], actionByRoot: {} }),
			(e._byClipCacheIndex = 0),
			(a[t] = s);
		else {
			const o = s.knownActions;
			(e._byClipCacheIndex = o.length), o.push(e);
		}
		(e._cacheIndex = n.length), n.push(e), (s.actionByRoot[i] = e);
	}
	_removeInactiveAction(e) {
		const t = this._actions,
			i = t[t.length - 1],
			n = e._cacheIndex;
		(i._cacheIndex = n), (t[n] = i), t.pop(), (e._cacheIndex = null);
		const a = e._clip.uuid,
			s = this._actionsByClip,
			o = s[a],
			l = o.knownActions,
			c = l[l.length - 1],
			u = e._byClipCacheIndex;
		(c._byClipCacheIndex = u),
		(l[u] = c),
		l.pop(),
		(e._byClipCacheIndex = null);
		const h = o.actionByRoot,
			d = (e._localRoot || this._root).uuid;
		delete h[d],
		l.length === 0 && delete s[a],
		this._removeInactiveBindingsForAction(e);
	}
	_removeInactiveBindingsForAction(e) {
		const t = e._propertyBindings;
		for (let i = 0, n = t.length; i !== n; ++i) {
			const a = t[i];
			--a.referenceCount === 0 && this._removeInactiveBinding(a);
		}
	}
	_lendAction(e) {
		const t = this._actions,
			i = e._cacheIndex,
			n = this._nActiveActions++,
			a = t[n];
		(e._cacheIndex = n), (t[n] = e), (a._cacheIndex = i), (t[i] = a);
	}
	_takeBackAction(e) {
		const t = this._actions,
			i = e._cacheIndex,
			n = --this._nActiveActions,
			a = t[n];
		(e._cacheIndex = n), (t[n] = e), (a._cacheIndex = i), (t[i] = a);
	}
	_addInactiveBinding(e, t, i) {
		const n = this._bindingsByRootAndName,
			a = this._bindings;
		let s = n[t];
		s === void 0 && ((s = {}), (n[t] = s)),
		(s[i] = e),
		(e._cacheIndex = a.length),
		a.push(e);
	}
	_removeInactiveBinding(e) {
		const t = this._bindings,
			i = e.binding,
			n = i.rootNode.uuid,
			a = i.path,
			s = this._bindingsByRootAndName,
			o = s[n],
			l = t[t.length - 1],
			c = e._cacheIndex;
		(l._cacheIndex = c),
		(t[c] = l),
		t.pop(),
		delete o[a],
		Object.keys(o).length === 0 && delete s[n];
	}
	_lendBinding(e) {
		const t = this._bindings,
			i = e._cacheIndex,
			n = this._nActiveBindings++,
			a = t[n];
		(e._cacheIndex = n), (t[n] = e), (a._cacheIndex = i), (t[i] = a);
	}
	_takeBackBinding(e) {
		const t = this._bindings,
			i = e._cacheIndex,
			n = --this._nActiveBindings,
			a = t[n];
		(e._cacheIndex = n), (t[n] = e), (a._cacheIndex = i), (t[i] = a);
	}
	_lendControlInterpolant() {
		const e = this._controlInterpolants,
			t = this._nActiveControlInterpolants++;
		let i = e[t];
		return (
			i === void 0 &&
                ((i = new gg(
                	new Float32Array(2),
                	new Float32Array(2),
                	1,
                	this._controlInterpolantsResultBuffer
                )),
                (i.__cacheIndex = t),
                (e[t] = i)),
			i
		);
	}
	_takeBackControlInterpolant(e) {
		const t = this._controlInterpolants,
			i = e.__cacheIndex,
			n = --this._nActiveControlInterpolants,
			a = t[n];
		(e.__cacheIndex = n), (t[n] = e), (a.__cacheIndex = i), (t[i] = a);
	}
	clipAction(e, t, i) {
		const n = t || this._root,
			a = n.uuid;
		let s = typeof e == 'string' ? Jc.findByName(n, e) : e;
		const o = s !== null ? s.uuid : e,
			l = this._actionsByClip[o];
		let c = null;
		if (
			(i === void 0 && (s !== null ? (i = s.blendMode) : (i = ku)),
			l !== void 0)
		) {
			const h = l.actionByRoot[a];
			if (h !== void 0 && h.blendMode === i) return h;
			(c = l.knownActions[0]), s === null && (s = c._clip);
		}
		if (s === null) return null;
		const u = new d2(this, s, t, i);
		return this._bindAction(u, c), this._addInactiveAction(u, o, a), u;
	}
	existingAction(e, t) {
		const i = t || this._root,
			n = i.uuid,
			a = typeof e == 'string' ? Jc.findByName(i, e) : e,
			s = a ? a.uuid : e,
			o = this._actionsByClip[s];
		return (o !== void 0 && o.actionByRoot[n]) || null;
	}
	stopAllAction() {
		const e = this._actions,
			t = this._nActiveActions;
		for (let i = t - 1; i >= 0; --i) e[i].stop();
		return this;
	}
	update(e) {
		e *= this.timeScale;
		const t = this._actions,
			i = this._nActiveActions,
			n = (this.time += e),
			a = Math.sign(e),
			s = (this._accuIndex ^= 1);
		for (let c = 0; c !== i; ++c) t[c]._update(n, e, a, s);
		const o = this._bindings,
			l = this._nActiveBindings;
		for (let c = 0; c !== l; ++c) o[c].apply(s);
		return this;
	}
	setTime(e) {
		this.time = 0;
		for (let t = 0; t < this._actions.length; t++)
			this._actions[t].time = 0;
		return this.update(e);
	}
	getRoot() {
		return this._root;
	}
	uncacheClip(e) {
		const t = this._actions,
			i = e.uuid,
			n = this._actionsByClip,
			a = n[i];
		if (a !== void 0) {
			const s = a.knownActions;
			for (let o = 0, l = s.length; o !== l; ++o) {
				const c = s[o];
				this._deactivateAction(c);
				const u = c._cacheIndex,
					h = t[t.length - 1];
				(c._cacheIndex = null),
				(c._byClipCacheIndex = null),
				(h._cacheIndex = u),
				(t[u] = h),
				t.pop(),
				this._removeInactiveBindingsForAction(c);
			}
			delete n[i];
		}
	}
	uncacheRoot(e) {
		const t = e.uuid,
			i = this._actionsByClip;
		for (const s in i) {
			const o = i[s].actionByRoot,
				l = o[t];
			l !== void 0 &&
                (this._deactivateAction(l), this._removeInactiveAction(l));
		}
		const n = this._bindingsByRootAndName,
			a = n[t];
		if (a !== void 0)
			for (const s in a) {
				const o = a[s];
				o.restoreOriginalState(), this._removeInactiveBinding(o);
			}
	}
	uncacheAction(e, t) {
		const i = this.existingAction(e, t);
		i !== null &&
            (this._deactivateAction(i), this._removeInactiveAction(i));
	}
}
p2.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
class m2 extends Sa {
	constructor(e, t, i = 1) {
		super(e, t), (this.meshPerAttribute = i);
	}
	copy(e) {
		return (
			super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
		);
	}
	clone(e) {
		const t = super.clone(e);
		return (t.meshPerAttribute = this.meshPerAttribute), t;
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return (
			(t.isInstancedInterleavedBuffer = !0),
			(t.meshPerAttribute = this.meshPerAttribute),
			t
		);
	}
}
m2.prototype.isInstancedInterleavedBuffer = !0;
class Op {
	constructor(e = 1, t = 0, i = 0) {
		return (this.radius = e), (this.phi = t), (this.theta = i), this;
	}
	set(e, t, i) {
		return (this.radius = e), (this.phi = t), (this.theta = i), this;
	}
	copy(e) {
		return (
			(this.radius = e.radius),
			(this.phi = e.phi),
			(this.theta = e.theta),
			this
		);
	}
	makeSafe() {
		return (
			(this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))),
			this
		);
	}
	setFromVector3(e) {
		return this.setFromCartesianCoords(e.x, e.y, e.z);
	}
	setFromCartesianCoords(e, t, i) {
		return (
			(this.radius = Math.sqrt(e * e + t * t + i * i)),
			this.radius === 0
				? ((this.theta = 0), (this.phi = 0))
				: ((this.theta = Math.atan2(e, i)),
				(this.phi = Math.acos(Et(t / this.radius, -1, 1)))),
			this
		);
	}
	clone() {
		return new this.constructor().copy(this);
	}
}
const mi = new C(),
	vo = new Pe(),
	uc = new Pe();
class f2 extends cl {
	constructor(e) {
		const t = Eg(e),
			i = new ot(),
			n = [],
			a = [],
			s = new ke(0, 0, 1),
			o = new ke(0, 1, 0);
		for (let c = 0; c < t.length; c++) {
			const u = t[c];
			u.parent &&
                u.parent.isBone &&
                (n.push(0, 0, 0),
                n.push(0, 0, 0),
                a.push(s.r, s.g, s.b),
                a.push(o.r, o.g, o.b));
		}
		i.setAttribute('position', new yt(n, 3)),
		i.setAttribute('color', new yt(a, 3));
		const l = new Oi({
			vertexColors: !0,
			depthTest: !1,
			depthWrite: !1,
			toneMapped: !1,
			transparent: !0
		});
		super(i, l),
		(this.type = 'SkeletonHelper'),
		(this.isSkeletonHelper = !0),
		(this.root = e),
		(this.bones = t),
		(this.matrix = e.matrixWorld),
		(this.matrixAutoUpdate = !1);
	}
	updateMatrixWorld(e) {
		const t = this.bones,
			i = this.geometry,
			n = i.getAttribute('position');
		uc.copy(this.root.matrixWorld).invert();
		for (let a = 0, s = 0; a < t.length; a++) {
			const o = t[a];
			o.parent &&
                o.parent.isBone &&
                (vo.multiplyMatrices(uc, o.matrixWorld),
                mi.setFromMatrixPosition(vo),
                n.setXYZ(s, mi.x, mi.y, mi.z),
                vo.multiplyMatrices(uc, o.parent.matrixWorld),
                mi.setFromMatrixPosition(vo),
                n.setXYZ(s + 1, mi.x, mi.y, mi.z),
                (s += 2));
		}
		(i.getAttribute('position').needsUpdate = !0),
		super.updateMatrixWorld(e);
	}
}
function Eg(r) {
	const e = [];
	r.isBone === !0 && e.push(r);
	for (let t = 0; t < r.children.length; t++)
		e.push.apply(e, Eg(r.children[t]));
	return e;
}
class Ag extends cl {
	constructor(e = 10, t = 10, i = 4473924, n = 8947848) {
		(i = new ke(i)), (n = new ke(n));
		const a = t / 2,
			s = e / t,
			o = e / 2,
			l = [],
			c = [];
		for (let d = 0, p = 0, g = -o; d <= t; d++, g += s) {
			l.push(-o, 0, g, o, 0, g), l.push(g, 0, -o, g, 0, o);
			const m = d === a ? i : n;
			m.toArray(c, p),
			(p += 3),
			m.toArray(c, p),
			(p += 3),
			m.toArray(c, p),
			(p += 3),
			m.toArray(c, p),
			(p += 3);
		}
		const u = new ot();
		u.setAttribute('position', new yt(l, 3)),
		u.setAttribute('color', new yt(c, 3));
		const h = new Oi({ vertexColors: !0, toneMapped: !1 });
		super(u, h), (this.type = 'GridHelper');
	}
}
const Np = new C(),
	yo = new C(),
	zp = new C();
class g2 extends Je {
	constructor(e, t, i) {
		super(),
		(this.light = e),
		this.light.updateMatrixWorld(),
		(this.matrix = e.matrixWorld),
		(this.matrixAutoUpdate = !1),
		(this.color = i),
		t === void 0 && (t = 1);
		let n = new ot();
		n.setAttribute(
			'position',
			new yt([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)
		);
		const a = new Oi({ fog: !1, toneMapped: !1 });
		(this.lightPlane = new da(n, a)),
		this.add(this.lightPlane),
		(n = new ot()),
		n.setAttribute('position', new yt([0, 0, 0, 0, 0, 1], 3)),
		(this.targetLine = new da(n, a)),
		this.add(this.targetLine),
		this.update();
	}
	dispose() {
		this.lightPlane.geometry.dispose(),
		this.lightPlane.material.dispose(),
		this.targetLine.geometry.dispose(),
		this.targetLine.material.dispose();
	}
	update() {
		Np.setFromMatrixPosition(this.light.matrixWorld),
		yo.setFromMatrixPosition(this.light.target.matrixWorld),
		zp.subVectors(yo, Np),
		this.lightPlane.lookAt(yo),
		this.color !== void 0
			? (this.lightPlane.material.color.set(this.color),
			this.targetLine.material.color.set(this.color))
			: (this.lightPlane.material.color.copy(this.light.color),
			this.targetLine.material.color.copy(this.light.color)),
		this.targetLine.lookAt(yo),
		(this.targetLine.scale.z = zp.length());
	}
}
const Er = new Uint32Array(512),
	Ar = new Uint32Array(512);
for (let r = 0; r < 256; ++r) {
	const e = r - 127;
	e < -27
		? ((Er[r] = 0), (Er[r | 256] = 32768), (Ar[r] = 24), (Ar[r | 256] = 24))
		: e < -14
			? ((Er[r] = 1024 >> (-e - 14)),
			(Er[r | 256] = (1024 >> (-e - 14)) | 32768),
			(Ar[r] = -e - 1),
			(Ar[r | 256] = -e - 1))
			: e <= 15
				? ((Er[r] = (e + 15) << 10),
				(Er[r | 256] = ((e + 15) << 10) | 32768),
				(Ar[r] = 13),
				(Ar[r | 256] = 13))
				: e < 128
					? ((Er[r] = 31744),
					(Er[r | 256] = 64512),
					(Ar[r] = 24),
					(Ar[r | 256] = 24))
					: ((Er[r] = 31744),
					(Er[r | 256] = 64512),
					(Ar[r] = 13),
					(Ar[r | 256] = 13));
}
const Lg = new Uint32Array(2048),
	Rs = new Uint32Array(64),
	v2 = new Uint32Array(64);
for (let r = 1; r < 1024; ++r) {
	let e = r << 13,
		t = 0;
	for (; (e & 8388608) === 0; ) (e <<= 1), (t -= 8388608);
	(e &= -8388609), (t += 947912704), (Lg[r] = e | t);
}
for (let r = 1024; r < 2048; ++r) Lg[r] = 939524096 + ((r - 1024) << 13);
for (let r = 1; r < 31; ++r) Rs[r] = r << 23;
Rs[31] = 1199570944;
Rs[32] = 2147483648;
for (let r = 33; r < 63; ++r) Rs[r] = 2147483648 + ((r - 32) << 23);
Rs[63] = 3347054592;
for (let r = 1; r < 64; ++r) r !== 32 && (v2[r] = 1024);
sr.create = function (r, e) {
	return (
		console.log('THREE.Curve.create() has been deprecated'),
		(r.prototype = Object.create(sr.prototype)),
		(r.prototype.constructor = r),
		(r.prototype.getPoint = e),
		r
	);
};
Zc.prototype.fromPoints = function (r) {
	return (
		console.warn(
			'THREE.Path: .fromPoints() has been renamed to .setFromPoints().'
		),
		this.setFromPoints(r)
	);
};
Ag.prototype.setColors = function () {
	console.error(
		'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.'
	);
};
f2.prototype.update = function () {
	console.error(
		'THREE.SkeletonHelper: update() no longer needs to be called.'
	);
};
ri.prototype.extractUrlBase = function (r) {
	return (
		console.warn(
			'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.'
		),
		Ri.extractUrlBase(r)
	);
};
ri.Handlers = {
	add: function () {
		console.error(
			'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.'
		);
	},
	get: function () {
		console.error(
			'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.'
		);
	}
};
or.prototype.center = function (r) {
	return (
		console.warn('THREE.Box3: .center() has been renamed to .getCenter().'),
		this.getCenter(r)
	);
};
or.prototype.empty = function () {
	return (
		console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().'),
		this.isEmpty()
	);
};
or.prototype.isIntersectionBox = function (r) {
	return (
		console.warn(
			'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().'
		),
		this.intersectsBox(r)
	);
};
or.prototype.isIntersectionSphere = function (r) {
	return (
		console.warn(
			'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().'
		),
		this.intersectsSphere(r)
	);
};
or.prototype.size = function (r) {
	return (
		console.warn('THREE.Box3: .size() has been renamed to .getSize().'),
		this.getSize(r)
	);
};
pn.prototype.toVector3 = function () {
	console.error(
		'THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead'
	);
};
dn.prototype.empty = function () {
	return (
		console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().'),
		this.isEmpty()
	);
};
al.prototype.setFromMatrix = function (r) {
	return (
		console.warn(
			'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().'
		),
		this.setFromProjectionMatrix(r)
	);
};
kt.prototype.flattenToArrayOffset = function (r, e) {
	return (
		console.warn(
			'THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.'
		),
		this.toArray(r, e)
	);
};
kt.prototype.multiplyVector3 = function (r) {
	return (
		console.warn(
			'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.'
		),
		r.applyMatrix3(this)
	);
};
kt.prototype.multiplyVector3Array = function () {
	console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
};
kt.prototype.applyToBufferAttribute = function (r) {
	return (
		console.warn(
			'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.'
		),
		r.applyMatrix3(this)
	);
};
kt.prototype.applyToVector3Array = function () {
	console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
};
kt.prototype.getInverse = function (r) {
	return (
		console.warn(
			'THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.'
		),
		this.copy(r).invert()
	);
};
Pe.prototype.extractPosition = function (r) {
	return (
		console.warn(
			'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().'
		),
		this.copyPosition(r)
	);
};
Pe.prototype.flattenToArrayOffset = function (r, e) {
	return (
		console.warn(
			'THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.'
		),
		this.toArray(r, e)
	);
};
Pe.prototype.getPosition = function () {
	return (
		console.warn(
			'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.'
		),
		new C().setFromMatrixColumn(this, 3)
	);
};
Pe.prototype.setRotationFromQuaternion = function (r) {
	return (
		console.warn(
			'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().'
		),
		this.makeRotationFromQuaternion(r)
	);
};
Pe.prototype.multiplyToArray = function () {
	console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
};
Pe.prototype.multiplyVector3 = function (r) {
	return (
		console.warn(
			'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.'
		),
		r.applyMatrix4(this)
	);
};
Pe.prototype.multiplyVector4 = function (r) {
	return (
		console.warn(
			'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.'
		),
		r.applyMatrix4(this)
	);
};
Pe.prototype.multiplyVector3Array = function () {
	console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
};
Pe.prototype.rotateAxis = function (r) {
	console.warn(
		'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.'
	),
	r.transformDirection(this);
};
Pe.prototype.crossVector = function (r) {
	return (
		console.warn(
			'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.'
		),
		r.applyMatrix4(this)
	);
};
Pe.prototype.translate = function () {
	console.error('THREE.Matrix4: .translate() has been removed.');
};
Pe.prototype.rotateX = function () {
	console.error('THREE.Matrix4: .rotateX() has been removed.');
};
Pe.prototype.rotateY = function () {
	console.error('THREE.Matrix4: .rotateY() has been removed.');
};
Pe.prototype.rotateZ = function () {
	console.error('THREE.Matrix4: .rotateZ() has been removed.');
};
Pe.prototype.rotateByAxis = function () {
	console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
};
Pe.prototype.applyToBufferAttribute = function (r) {
	return (
		console.warn(
			'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.'
		),
		r.applyMatrix4(this)
	);
};
Pe.prototype.applyToVector3Array = function () {
	console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
};
Pe.prototype.makeFrustum = function (r, e, t, i, n, a) {
	return (
		console.warn(
			'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.'
		),
		this.makePerspective(r, e, i, t, n, a)
	);
};
Pe.prototype.getInverse = function (r) {
	return (
		console.warn(
			'THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.'
		),
		this.copy(r).invert()
	);
};
Xr.prototype.isIntersectionLine = function (r) {
	return (
		console.warn(
			'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().'
		),
		this.intersectsLine(r)
	);
};
Ct.prototype.multiplyVector3 = function (r) {
	return (
		console.warn(
			'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.'
		),
		r.applyQuaternion(this)
	);
};
Ct.prototype.inverse = function () {
	return (
		console.warn(
			'THREE.Quaternion: .inverse() has been renamed to invert().'
		),
		this.invert()
	);
};
wa.prototype.isIntersectionBox = function (r) {
	return (
		console.warn(
			'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().'
		),
		this.intersectsBox(r)
	);
};
wa.prototype.isIntersectionPlane = function (r) {
	return (
		console.warn(
			'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().'
		),
		this.intersectsPlane(r)
	);
};
wa.prototype.isIntersectionSphere = function (r) {
	return (
		console.warn(
			'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().'
		),
		this.intersectsSphere(r)
	);
};
vt.prototype.area = function () {
	return (
		console.warn('THREE.Triangle: .area() has been renamed to .getArea().'),
		this.getArea()
	);
};
vt.prototype.barycoordFromPoint = function (r, e) {
	return (
		console.warn(
			'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().'
		),
		this.getBarycoord(r, e)
	);
};
vt.prototype.midpoint = function (r) {
	return (
		console.warn(
			'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().'
		),
		this.getMidpoint(r)
	);
};
vt.prototypenormal = function (r) {
	return (
		console.warn(
			'THREE.Triangle: .normal() has been renamed to .getNormal().'
		),
		this.getNormal(r)
	);
};
vt.prototype.plane = function (r) {
	return (
		console.warn(
			'THREE.Triangle: .plane() has been renamed to .getPlane().'
		),
		this.getPlane(r)
	);
};
vt.barycoordFromPoint = function (r, e, t, i, n) {
	return (
		console.warn(
			'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().'
		),
		vt.getBarycoord(r, e, t, i, n)
	);
};
vt.normal = function (r, e, t, i) {
	return (
		console.warn(
			'THREE.Triangle: .normal() has been renamed to .getNormal().'
		),
		vt.getNormal(r, e, t, i)
	);
};
Ls.prototype.extractAllPoints = function (r) {
	return (
		console.warn(
			'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.'
		),
		this.extractPoints(r)
	);
};
Ls.prototype.extrude = function (r) {
	return (
		console.warn(
			'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.'
		),
		new Ta(this, r)
	);
};
Ls.prototype.makeGeometry = function (r) {
	return (
		console.warn(
			'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.'
		),
		new qu(this, r)
	);
};
me.prototype.fromAttribute = function (r, e, t) {
	return (
		console.warn(
			'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().'
		),
		this.fromBufferAttribute(r, e, t)
	);
};
me.prototype.distanceToManhattan = function (r) {
	return (
		console.warn(
			'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().'
		),
		this.manhattanDistanceTo(r)
	);
};
me.prototype.lengthManhattan = function () {
	return (
		console.warn(
			'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().'
		),
		this.manhattanLength()
	);
};
C.prototype.setEulerFromRotationMatrix = function () {
	console.error(
		'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.'
	);
};
C.prototype.setEulerFromQuaternion = function () {
	console.error(
		'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.'
	);
};
C.prototype.getPositionFromMatrix = function (r) {
	return (
		console.warn(
			'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().'
		),
		this.setFromMatrixPosition(r)
	);
};
C.prototype.getScaleFromMatrix = function (r) {
	return (
		console.warn(
			'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().'
		),
		this.setFromMatrixScale(r)
	);
};
C.prototype.getColumnFromMatrix = function (r, e) {
	return (
		console.warn(
			'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().'
		),
		this.setFromMatrixColumn(e, r)
	);
};
C.prototype.applyProjection = function (r) {
	return (
		console.warn(
			'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.'
		),
		this.applyMatrix4(r)
	);
};
C.prototype.fromAttribute = function (r, e, t) {
	return (
		console.warn(
			'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().'
		),
		this.fromBufferAttribute(r, e, t)
	);
};
C.prototype.distanceToManhattan = function (r) {
	return (
		console.warn(
			'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().'
		),
		this.manhattanDistanceTo(r)
	);
};
C.prototype.lengthManhattan = function () {
	return (
		console.warn(
			'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().'
		),
		this.manhattanLength()
	);
};
it.prototype.fromAttribute = function (r, e, t) {
	return (
		console.warn(
			'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().'
		),
		this.fromBufferAttribute(r, e, t)
	);
};
it.prototype.lengthManhattan = function () {
	return (
		console.warn(
			'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().'
		),
		this.manhattanLength()
	);
};
Je.prototype.getChildByName = function (r) {
	return (
		console.warn(
			'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().'
		),
		this.getObjectByName(r)
	);
};
Je.prototype.renderDepth = function () {
	console.warn(
		'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.'
	);
};
Je.prototype.translate = function (r, e) {
	return (
		console.warn(
			'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.'
		),
		this.translateOnAxis(e, r)
	);
};
Je.prototype.getWorldRotation = function () {
	console.error(
		'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.'
	);
};
Je.prototype.applyMatrix = function (r) {
	return (
		console.warn(
			'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().'
		),
		this.applyMatrix4(r)
	);
};
Object.defineProperties(Je.prototype, {
	eulerOrder: {
		get: function () {
			return (
				console.warn(
					'THREE.Object3D: .eulerOrder is now .rotation.order.'
				),
				this.rotation.order
			);
		},
		set: function (r) {
			console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.'),
			(this.rotation.order = r);
		}
	},
	useQuaternion: {
		get: function () {
			console.warn(
				'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.'
			);
		},
		set: function () {
			console.warn(
				'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.'
			);
		}
	}
});
rt.prototype.setDrawMode = function () {
	console.error(
		'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.'
	);
};
Object.defineProperties(rt.prototype, {
	drawMode: {
		get: function () {
			return (
				console.error(
					'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.'
				),
				Xx
			);
		},
		set: function () {
			console.error(
				'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.'
			);
		}
	}
});
Fu.prototype.initBones = function () {
	console.error('THREE.SkinnedMesh: initBones() has been removed.');
};
zt.prototype.setLens = function (r, e) {
	console.warn(
		'THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.'
	),
	e !== void 0 && (this.filmGauge = e),
	this.setFocalLength(r);
};
Object.defineProperties(Nr.prototype, {
	onlyShadow: {
		set: function () {
			console.warn('THREE.Light: .onlyShadow has been removed.');
		}
	},
	shadowCameraFov: {
		set: function (r) {
			console.warn(
				'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.'
			),
			(this.shadow.camera.fov = r);
		}
	},
	shadowCameraLeft: {
		set: function (r) {
			console.warn(
				'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.'
			),
			(this.shadow.camera.left = r);
		}
	},
	shadowCameraRight: {
		set: function (r) {
			console.warn(
				'THREE.Light: .shadowCameraRight is now .shadow.camera.right.'
			),
			(this.shadow.camera.right = r);
		}
	},
	shadowCameraTop: {
		set: function (r) {
			console.warn(
				'THREE.Light: .shadowCameraTop is now .shadow.camera.top.'
			),
			(this.shadow.camera.top = r);
		}
	},
	shadowCameraBottom: {
		set: function (r) {
			console.warn(
				'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.'
			),
			(this.shadow.camera.bottom = r);
		}
	},
	shadowCameraNear: {
		set: function (r) {
			console.warn(
				'THREE.Light: .shadowCameraNear is now .shadow.camera.near.'
			),
			(this.shadow.camera.near = r);
		}
	},
	shadowCameraFar: {
		set: function (r) {
			console.warn(
				'THREE.Light: .shadowCameraFar is now .shadow.camera.far.'
			),
			(this.shadow.camera.far = r);
		}
	},
	shadowCameraVisible: {
		set: function () {
			console.warn(
				'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.'
			);
		}
	},
	shadowBias: {
		set: function (r) {
			console.warn('THREE.Light: .shadowBias is now .shadow.bias.'),
			(this.shadow.bias = r);
		}
	},
	shadowDarkness: {
		set: function () {
			console.warn('THREE.Light: .shadowDarkness has been removed.');
		}
	},
	shadowMapWidth: {
		set: function (r) {
			console.warn(
				'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.'
			),
			(this.shadow.mapSize.width = r);
		}
	},
	shadowMapHeight: {
		set: function (r) {
			console.warn(
				'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.'
			),
			(this.shadow.mapSize.height = r);
		}
	}
});
Object.defineProperties(mt.prototype, {
	length: {
		get: function () {
			return (
				console.warn(
					'THREE.BufferAttribute: .length has been deprecated. Use .count instead.'
				),
				this.array.length
			);
		}
	},
	dynamic: {
		get: function () {
			return (
				console.warn(
					'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.'
				),
				this.usage === zo
			);
		},
		set: function () {
			console.warn(
				'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.'
			),
			this.setUsage(zo);
		}
	}
});
mt.prototype.setDynamic = function (r) {
	return (
		console.warn(
			'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.'
		),
		this.setUsage(r === !0 ? zo : gs),
		this
	);
};
(mt.prototype.copyIndicesArray = function () {
	console.error(
		'THREE.BufferAttribute: .copyIndicesArray() has been removed.'
	);
}),
(mt.prototype.setArray = function () {
	console.error(
		'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers'
	);
});
ot.prototype.addIndex = function (r) {
	console.warn(
		'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().'
	),
	this.setIndex(r);
};
ot.prototype.addAttribute = function (r, e) {
	return (
		console.warn(
			'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().'
		),
		!(e && e.isBufferAttribute) && !(e && e.isInterleavedBufferAttribute)
			? (console.warn(
				'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).'
			),
			this.setAttribute(r, new mt(arguments[1], arguments[2])))
			: r === 'index'
				? (console.warn(
					'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.'
				),
				this.setIndex(e),
				this)
				: this.setAttribute(r, e)
	);
};
ot.prototype.addDrawCall = function (r, e, t) {
	t !== void 0 &&
        console.warn(
        	'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.'
        ),
	console.warn(
		'THREE.BufferGeometry: .addDrawCall() is now .addGroup().'
	),
	this.addGroup(r, e);
};
ot.prototype.clearDrawCalls = function () {
	console.warn(
		'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().'
	),
	this.clearGroups();
};
ot.prototype.computeOffsets = function () {
	console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
};
ot.prototype.removeAttribute = function (r) {
	return (
		console.warn(
			'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().'
		),
		this.deleteAttribute(r)
	);
};
ot.prototype.applyMatrix = function (r) {
	return (
		console.warn(
			'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().'
		),
		this.applyMatrix4(r)
	);
};
Object.defineProperties(ot.prototype, {
	drawcalls: {
		get: function () {
			return (
				console.error(
					'THREE.BufferGeometry: .drawcalls has been renamed to .groups.'
				),
				this.groups
			);
		}
	},
	offsets: {
		get: function () {
			return (
				console.warn(
					'THREE.BufferGeometry: .offsets has been renamed to .groups.'
				),
				this.groups
			);
		}
	}
});
Sa.prototype.setDynamic = function (r) {
	return (
		console.warn(
			'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.'
		),
		this.setUsage(r === !0 ? zo : gs),
		this
	);
};
Sa.prototype.setArray = function () {
	console.error(
		'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers'
	);
};
Ta.prototype.getArrays = function () {
	console.error('THREE.ExtrudeGeometry: .getArrays() has been removed.');
};
Ta.prototype.addShapeList = function () {
	console.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.');
};
Ta.prototype.addShape = function () {
	console.error('THREE.ExtrudeGeometry: .addShape() has been removed.');
};
ll.prototype.dispose = function () {
	console.error('THREE.Scene: .dispose() has been removed.');
};
Object.defineProperties(dt.prototype, {
	wrapAround: {
		get: function () {
			console.warn('THREE.Material: .wrapAround has been removed.');
		},
		set: function () {
			console.warn('THREE.Material: .wrapAround has been removed.');
		}
	},
	overdraw: {
		get: function () {
			console.warn('THREE.Material: .overdraw has been removed.');
		},
		set: function () {
			console.warn('THREE.Material: .overdraw has been removed.');
		}
	},
	wrapRGB: {
		get: function () {
			return (
				console.warn('THREE.Material: .wrapRGB has been removed.'),
				new ke()
			);
		}
	},
	shading: {
		get: function () {
			console.error(
				'THREE.' +
                    this.type +
                    ': .shading has been removed. Use the boolean .flatShading instead.'
			);
		},
		set: function (r) {
			console.warn(
				'THREE.' +
                    this.type +
                    ': .shading has been removed. Use the boolean .flatShading instead.'
			),
			(this.flatShading = r === Sf);
		}
	},
	stencilMask: {
		get: function () {
			return (
				console.warn(
					'THREE.' +
                        this.type +
                        ': .stencilMask has been removed. Use .stencilFuncMask instead.'
				),
				this.stencilFuncMask
			);
		},
		set: function (r) {
			console.warn(
				'THREE.' +
                    this.type +
                    ': .stencilMask has been removed. Use .stencilFuncMask instead.'
			),
			(this.stencilFuncMask = r);
		}
	},
	vertexTangents: {
		get: function () {
			console.warn(
				'THREE.' + this.type + ': .vertexTangents has been removed.'
			);
		},
		set: function () {
			console.warn(
				'THREE.' + this.type + ': .vertexTangents has been removed.'
			);
		}
	}
});
Object.defineProperties(br.prototype, {
	derivatives: {
		get: function () {
			return (
				console.warn(
					'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.'
				),
				this.extensions.derivatives
			);
		},
		set: function (r) {
			console.warn(
				'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.'
			),
			(this.extensions.derivatives = r);
		}
	}
});
tt.prototype.clearTarget = function (r, e, t, i) {
	console.warn(
		'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.'
	),
	this.setRenderTarget(r),
	this.clear(e, t, i);
};
tt.prototype.animate = function (r) {
	console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().'),
	this.setAnimationLoop(r);
};
tt.prototype.getCurrentRenderTarget = function () {
	return (
		console.warn(
			'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().'
		),
		this.getRenderTarget()
	);
};
tt.prototype.getMaxAnisotropy = function () {
	return (
		console.warn(
			'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().'
		),
		this.capabilities.getMaxAnisotropy()
	);
};
tt.prototype.getPrecision = function () {
	return (
		console.warn(
			'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.'
		),
		this.capabilities.precision
	);
};
tt.prototype.resetGLState = function () {
	return (
		console.warn(
			'THREE.WebGLRenderer: .resetGLState() is now .state.reset().'
		),
		this.state.reset()
	);
};
tt.prototype.supportsFloatTextures = function () {
	return (
		console.warn(
			'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).'
		),
		this.extensions.get('OES_texture_float')
	);
};
tt.prototype.supportsHalfFloatTextures = function () {
	return (
		console.warn(
			'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).'
		),
		this.extensions.get('OES_texture_half_float')
	);
};
tt.prototype.supportsStandardDerivatives = function () {
	return (
		console.warn(
			'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).'
		),
		this.extensions.get('OES_standard_derivatives')
	);
};
tt.prototype.supportsCompressedTextureS3TC = function () {
	return (
		console.warn(
			'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).'
		),
		this.extensions.get('WEBGL_compressed_texture_s3tc')
	);
};
tt.prototype.supportsCompressedTexturePVRTC = function () {
	return (
		console.warn(
			'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).'
		),
		this.extensions.get('WEBGL_compressed_texture_pvrtc')
	);
};
tt.prototype.supportsBlendMinMax = function () {
	return (
		console.warn(
			'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).'
		),
		this.extensions.get('EXT_blend_minmax')
	);
};
tt.prototype.supportsVertexTextures = function () {
	return (
		console.warn(
			'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.'
		),
		this.capabilities.vertexTextures
	);
};
tt.prototype.supportsInstancedArrays = function () {
	return (
		console.warn(
			'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).'
		),
		this.extensions.get('ANGLE_instanced_arrays')
	);
};
tt.prototype.enableScissorTest = function (r) {
	console.warn(
		'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().'
	),
	this.setScissorTest(r);
};
tt.prototype.initMaterial = function () {
	console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
};
tt.prototype.addPrePlugin = function () {
	console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
};
tt.prototype.addPostPlugin = function () {
	console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
};
tt.prototype.updateShadowMap = function () {
	console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
};
tt.prototype.setFaceCulling = function () {
	console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
};
tt.prototype.allocTextureUnit = function () {
	console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');
};
tt.prototype.setTexture = function () {
	console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');
};
tt.prototype.setTexture2D = function () {
	console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');
};
tt.prototype.setTextureCube = function () {
	console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');
};
tt.prototype.getActiveMipMapLevel = function () {
	return (
		console.warn(
			'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().'
		),
		this.getActiveMipmapLevel()
	);
};
Object.defineProperties(tt.prototype, {
	shadowMapEnabled: {
		get: function () {
			return this.shadowMap.enabled;
		},
		set: function (r) {
			console.warn(
				'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.'
			),
			(this.shadowMap.enabled = r);
		}
	},
	shadowMapType: {
		get: function () {
			return this.shadowMap.type;
		},
		set: function (r) {
			console.warn(
				'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.'
			),
			(this.shadowMap.type = r);
		}
	},
	shadowMapCullFace: {
		get: function () {
			console.warn(
				'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.'
			);
		},
		set: function () {
			console.warn(
				'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.'
			);
		}
	},
	context: {
		get: function () {
			return (
				console.warn(
					'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.'
				),
				this.getContext()
			);
		}
	},
	vr: {
		get: function () {
			return (
				console.warn(
					'THREE.WebGLRenderer: .vr has been renamed to .xr'
				),
				this.xr
			);
		}
	},
	gammaInput: {
		get: function () {
			return (
				console.warn(
					'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.'
				),
				!1
			);
		},
		set: function () {
			console.warn(
				'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.'
			);
		}
	},
	gammaOutput: {
		get: function () {
			return (
				console.warn(
					'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.'
				),
				!1
			);
		},
		set: function (r) {
			console.warn(
				'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.'
			),
			(this.outputEncoding = r === !0 ? Ze : Qr);
		}
	},
	toneMappingWhitePoint: {
		get: function () {
			return (
				console.warn(
					'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.'
				),
				1
			);
		},
		set: function () {
			console.warn(
				'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.'
			);
		}
	},
	gammaFactor: {
		get: function () {
			return (
				console.warn(
					'THREE.WebGLRenderer: .gammaFactor has been removed.'
				),
				2
			);
		},
		set: function () {
			console.warn('THREE.WebGLRenderer: .gammaFactor has been removed.');
		}
	}
});
Object.defineProperties(qf.prototype, {
	cullFace: {
		get: function () {
			console.warn(
				'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.'
			);
		},
		set: function () {
			console.warn(
				'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.'
			);
		}
	},
	renderReverseSided: {
		get: function () {
			console.warn(
				'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.'
			);
		},
		set: function () {
			console.warn(
				'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.'
			);
		}
	},
	renderSingleSided: {
		get: function () {
			console.warn(
				'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.'
			);
		},
		set: function () {
			console.warn(
				'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.'
			);
		}
	}
});
Object.defineProperties(Xt.prototype, {
	wrapS: {
		get: function () {
			return (
				console.warn(
					'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.'
				),
				this.texture.wrapS
			);
		},
		set: function (r) {
			console.warn(
				'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.'
			),
			(this.texture.wrapS = r);
		}
	},
	wrapT: {
		get: function () {
			return (
				console.warn(
					'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.'
				),
				this.texture.wrapT
			);
		},
		set: function (r) {
			console.warn(
				'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.'
			),
			(this.texture.wrapT = r);
		}
	},
	magFilter: {
		get: function () {
			return (
				console.warn(
					'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.'
				),
				this.texture.magFilter
			);
		},
		set: function (r) {
			console.warn(
				'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.'
			),
			(this.texture.magFilter = r);
		}
	},
	minFilter: {
		get: function () {
			return (
				console.warn(
					'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.'
				),
				this.texture.minFilter
			);
		},
		set: function (r) {
			console.warn(
				'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.'
			),
			(this.texture.minFilter = r);
		}
	},
	anisotropy: {
		get: function () {
			return (
				console.warn(
					'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.'
				),
				this.texture.anisotropy
			);
		},
		set: function (r) {
			console.warn(
				'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.'
			),
			(this.texture.anisotropy = r);
		}
	},
	offset: {
		get: function () {
			return (
				console.warn(
					'THREE.WebGLRenderTarget: .offset is now .texture.offset.'
				),
				this.texture.offset
			);
		},
		set: function (r) {
			console.warn(
				'THREE.WebGLRenderTarget: .offset is now .texture.offset.'
			),
			(this.texture.offset = r);
		}
	},
	repeat: {
		get: function () {
			return (
				console.warn(
					'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.'
				),
				this.texture.repeat
			);
		},
		set: function (r) {
			console.warn(
				'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.'
			),
			(this.texture.repeat = r);
		}
	},
	format: {
		get: function () {
			return (
				console.warn(
					'THREE.WebGLRenderTarget: .format is now .texture.format.'
				),
				this.texture.format
			);
		},
		set: function (r) {
			console.warn(
				'THREE.WebGLRenderTarget: .format is now .texture.format.'
			),
			(this.texture.format = r);
		}
	},
	type: {
		get: function () {
			return (
				console.warn(
					'THREE.WebGLRenderTarget: .type is now .texture.type.'
				),
				this.texture.type
			);
		},
		set: function (r) {
			console.warn(
				'THREE.WebGLRenderTarget: .type is now .texture.type.'
			),
			(this.texture.type = r);
		}
	},
	generateMipmaps: {
		get: function () {
			return (
				console.warn(
					'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.'
				),
				this.texture.generateMipmaps
			);
		},
		set: function (r) {
			console.warn(
				'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.'
			),
			(this.texture.generateMipmaps = r);
		}
	}
});
t2.prototype.load = function (r) {
	console.warn(
		'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.'
	);
	const e = this;
	return (
		new JS().load(r, function (t) {
			e.setBuffer(t);
		}),
		this
	);
};
Du.prototype.updateCubeMap = function (r, e) {
	return (
		console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().'),
		this.update(r, e)
	);
};
Du.prototype.clear = function (r, e, t, i) {
	return (
		console.warn(
			'THREE.CubeCamera: .clear() is now .renderTarget.clear().'
		),
		this.renderTarget.clear(r, e, t, i)
	);
};
hn.crossOrigin = void 0;
hn.loadTexture = function (r, e, t, i) {
	console.warn(
		'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.'
	);
	const n = new xg();
	n.setCrossOrigin(this.crossOrigin);
	const a = n.load(r, t, void 0, i);
	return e && (a.mapping = e), a;
};
hn.loadTextureCube = function (r, e, t, i) {
	console.warn(
		'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.'
	);
	const n = new XS();
	n.setCrossOrigin(this.crossOrigin);
	const a = n.load(r, t, void 0, i);
	return e && (a.mapping = e), a;
};
hn.loadCompressedTexture = function () {
	console.error(
		'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.'
	);
};
hn.loadCompressedTextureCube = function () {
	console.error(
		'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.'
	);
};
typeof __THREE_DEVTOOLS__ != 'undefined' &&
    __THREE_DEVTOOLS__.dispatchEvent(
    	new CustomEvent('register', { detail: { revision: Ru } })
    );
typeof window != 'undefined' &&
    (window.__THREE__
    	? console.warn(
    		'WARNING: Multiple instances of Three.js being imported.'
    	)
    	: (window.__THREE__ = Ru));
const Up = { type: 'change' },
	hc = { type: 'start' },
	Bp = { type: 'end' };
class y2 extends Di {
	constructor(e, t) {
		super(),
		t === void 0 &&
                console.warn(
                	'THREE.OrbitControls: The second parameter "domElement" is now mandatory.'
                ),
		t === document &&
                console.error(
                	'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
                ),
		(this.object = e),
		(this.domElement = t),
		(this.domElement.style.touchAction = 'none'),
		(this.enabled = !0),
		(this.target = new C()),
		(this.minDistance = 0),
		(this.maxDistance = 1 / 0),
		(this.minZoom = 0),
		(this.maxZoom = 1 / 0),
		(this.minPolarAngle = 0),
		(this.maxPolarAngle = Math.PI),
		(this.minAzimuthAngle = -1 / 0),
		(this.maxAzimuthAngle = 1 / 0),
		(this.enableDamping = !1),
		(this.dampingFactor = 0.05),
		(this.enableZoom = !0),
		(this.zoomSpeed = 1),
		(this.enableRotate = !0),
		(this.rotateSpeed = 1),
		(this.enablePan = !0),
		(this.panSpeed = 1),
		(this.screenSpacePanning = !0),
		(this.keyPanSpeed = 7),
		(this.autoRotate = !1),
		(this.autoRotateSpeed = 2),
		(this.keys = {
			LEFT: 'ArrowLeft',
			UP: 'ArrowUp',
			RIGHT: 'ArrowRight',
			BOTTOM: 'ArrowDown'
		}),
		(this.mouseButtons = {
			LEFT: yn.ROTATE,
			MIDDLE: yn.DOLLY,
			RIGHT: yn.PAN
		}),
		(this.touches = { ONE: xn.ROTATE, TWO: xn.DOLLY_PAN }),
		(this.target0 = this.target.clone()),
		(this.position0 = this.object.position.clone()),
		(this.zoom0 = this.object.zoom),
		(this._domElementKeyEvents = null),
		(this.getPolarAngle = function () {
			return o.phi;
		}),
		(this.getAzimuthalAngle = function () {
			return o.theta;
		}),
		(this.getDistance = function () {
			return this.object.position.distanceTo(this.target);
		}),
		(this.listenToKeyEvents = function (T) {
			T.addEventListener('keydown', ge),
			(this._domElementKeyEvents = T);
		}),
		(this.saveState = function () {
			i.target0.copy(i.target),
			i.position0.copy(i.object.position),
			(i.zoom0 = i.object.zoom);
		}),
		(this.reset = function () {
			i.target.copy(i.target0),
			i.object.position.copy(i.position0),
			(i.object.zoom = i.zoom0),
			i.object.updateProjectionMatrix(),
			i.dispatchEvent(Up),
			i.update(),
			(a = n.NONE);
		}),
		(this.update = (function () {
			const T = new C(),
				se = new Ct().setFromUnitVectors(e.up, new C(0, 1, 0)),
				Re = se.clone().invert(),
				_e = new C(),
				O = new Ct(),
				ye = 2 * Math.PI;
			return function () {
				const we = i.object.position;
				T.copy(we).sub(i.target),
				T.applyQuaternion(se),
				o.setFromVector3(T),
				i.autoRotate && a === n.NONE && re(D()),
				i.enableDamping
					? ((o.theta += l.theta * i.dampingFactor),
					(o.phi += l.phi * i.dampingFactor))
					: ((o.theta += l.theta), (o.phi += l.phi));
				let Le = i.minAzimuthAngle,
					be = i.maxAzimuthAngle;
				return (
					isFinite(Le) &&
                            isFinite(be) &&
                            (Le < -Math.PI
                            	? (Le += ye)
                            	: Le > Math.PI && (Le -= ye),
                            be < -Math.PI
                            	? (be += ye)
                            	: be > Math.PI && (be -= ye),
                            Le <= be
                            	? (o.theta = Math.max(
                            		Le,
                            		Math.min(be, o.theta)
                            	))
                            	: (o.theta =
                                      o.theta > (Le + be) / 2
                                      	? Math.max(Le, o.theta)
                                      	: Math.min(be, o.theta))),
					(o.phi = Math.max(
						i.minPolarAngle,
						Math.min(i.maxPolarAngle, o.phi)
					)),
					o.makeSafe(),
					(o.radius *= c),
					(o.radius = Math.max(
						i.minDistance,
						Math.min(i.maxDistance, o.radius)
					)),
					i.enableDamping === !0
						? i.target.addScaledVector(u, i.dampingFactor)
						: i.target.add(u),
					T.setFromSpherical(o),
					T.applyQuaternion(Re),
					we.copy(i.target).add(T),
					i.object.lookAt(i.target),
					i.enableDamping === !0
						? ((l.theta *= 1 - i.dampingFactor),
						(l.phi *= 1 - i.dampingFactor),
						u.multiplyScalar(1 - i.dampingFactor))
						: (l.set(0, 0, 0), u.set(0, 0, 0)),
					(c = 1),
					h ||
                        _e.distanceToSquared(i.object.position) > s ||
                        8 * (1 - O.dot(i.object.quaternion)) > s
						? (i.dispatchEvent(Up),
						_e.copy(i.object.position),
						O.copy(i.object.quaternion),
						(h = !1),
						!0)
						: !1
				);
			};
		})()),
		(this.dispose = function () {
			i.domElement.removeEventListener('contextmenu', F),
			i.domElement.removeEventListener('pointerdown', R),
			i.domElement.removeEventListener('pointercancel', $),
			i.domElement.removeEventListener('wheel', he),
			i.domElement.removeEventListener('pointermove', N),
			i.domElement.removeEventListener('pointerup', q),
			i._domElementKeyEvents !== null &&
                        i._domElementKeyEvents.removeEventListener(
                        	'keydown',
                        	ge
                        );
		});
		const i = this,
			n = {
				NONE: -1,
				ROTATE: 0,
				DOLLY: 1,
				PAN: 2,
				TOUCH_ROTATE: 3,
				TOUCH_PAN: 4,
				TOUCH_DOLLY_PAN: 5,
				TOUCH_DOLLY_ROTATE: 6
			};
		let a = n.NONE;
		const s = 1e-6,
			o = new Op(),
			l = new Op();
		let c = 1;
		const u = new C();
		let h = !1;
		const d = new me(),
			p = new me(),
			g = new me(),
			m = new me(),
			f = new me(),
			v = new me(),
			x = new me(),
			A = new me(),
			S = new me(),
			M = [],
			I = {};
		function D() {
			return ((2 * Math.PI) / 60 / 60) * i.autoRotateSpeed;
		}
		function G() {
			return Math.pow(0.95, i.zoomSpeed);
		}
		function re(T) {
			l.theta -= T;
		}
		function B(T) {
			l.phi -= T;
		}
		const b = (function () {
				const T = new C();
				return function (se, Re) {
					T.setFromMatrixColumn(Re, 0),
					T.multiplyScalar(-se),
					u.add(T);
				};
			})(),
			E = (function () {
				const T = new C();
				return function (se, Re) {
					i.screenSpacePanning === !0
						? T.setFromMatrixColumn(Re, 1)
						: (T.setFromMatrixColumn(Re, 0),
						T.crossVectors(i.object.up, T)),
					T.multiplyScalar(se),
					u.add(T);
				};
			})(),
			j = (function () {
				const T = new C();
				return function (se, Re) {
					const _e = i.domElement;
					if (i.object.isPerspectiveCamera) {
						const O = i.object.position;
						T.copy(O).sub(i.target);
						let ye = T.length();
						(ye *= Math.tan(((i.object.fov / 2) * Math.PI) / 180)),
						b((2 * se * ye) / _e.clientHeight, i.object.matrix),
						E((2 * Re * ye) / _e.clientHeight, i.object.matrix);
					} else
						i.object.isOrthographicCamera
							? (b(
								(se * (i.object.right - i.object.left)) /
                                      i.object.zoom /
                                      _e.clientWidth,
								i.object.matrix
							),
							E(
								(Re * (i.object.top - i.object.bottom)) /
                                      i.object.zoom /
                                      _e.clientHeight,
								i.object.matrix
							))
							: (console.warn(
								'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.'
							),
							(i.enablePan = !1));
				};
			})();
		function z(T) {
			i.object.isPerspectiveCamera
				? (c /= T)
				: i.object.isOrthographicCamera
					? ((i.object.zoom = Math.max(
						i.minZoom,
						Math.min(i.maxZoom, i.object.zoom * T)
					)),
					i.object.updateProjectionMatrix(),
					(h = !0))
					: (console.warn(
						'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.'
					),
					(i.enableZoom = !1));
		}
		function V(T) {
			i.object.isPerspectiveCamera
				? (c *= T)
				: i.object.isOrthographicCamera
					? ((i.object.zoom = Math.max(
						i.minZoom,
						Math.min(i.maxZoom, i.object.zoom / T)
					)),
					i.object.updateProjectionMatrix(),
					(h = !0))
					: (console.warn(
						'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.'
					),
					(i.enableZoom = !1));
		}
		function H(T) {
			d.set(T.clientX, T.clientY);
		}
		function k(T) {
			x.set(T.clientX, T.clientY);
		}
		function P(T) {
			m.set(T.clientX, T.clientY);
		}
		function Z(T) {
			p.set(T.clientX, T.clientY),
			g.subVectors(p, d).multiplyScalar(i.rotateSpeed);
			const se = i.domElement;
			re((2 * Math.PI * g.x) / se.clientHeight),
			B((2 * Math.PI * g.y) / se.clientHeight),
			d.copy(p),
			i.update();
		}
		function J(T) {
			A.set(T.clientX, T.clientY),
			S.subVectors(A, x),
			S.y > 0 ? z(G()) : S.y < 0 && V(G()),
			x.copy(A),
			i.update();
		}
		function fe(T) {
			f.set(T.clientX, T.clientY),
			v.subVectors(f, m).multiplyScalar(i.panSpeed),
			j(v.x, v.y),
			m.copy(f),
			i.update();
		}
		function ce(T) {
			T.deltaY < 0 ? V(G()) : T.deltaY > 0 && z(G()), i.update();
		}
		function xe(T) {
			let se = !1;
			switch (T.code) {
			case i.keys.UP:
				j(0, i.keyPanSpeed), (se = !0);
				break;
			case i.keys.BOTTOM:
				j(0, -i.keyPanSpeed), (se = !0);
				break;
			case i.keys.LEFT:
				j(i.keyPanSpeed, 0), (se = !0);
				break;
			case i.keys.RIGHT:
				j(-i.keyPanSpeed, 0), (se = !0);
				break;
			}
			se && (T.preventDefault(), i.update());
		}
		function W() {
			if (M.length === 1) d.set(M[0].pageX, M[0].pageY);
			else {
				const T = 0.5 * (M[0].pageX + M[1].pageX),
					se = 0.5 * (M[0].pageY + M[1].pageY);
				d.set(T, se);
			}
		}
		function ue() {
			if (M.length === 1) m.set(M[0].pageX, M[0].pageY);
			else {
				const T = 0.5 * (M[0].pageX + M[1].pageX),
					se = 0.5 * (M[0].pageY + M[1].pageY);
				m.set(T, se);
			}
		}
		function U() {
			const T = M[0].pageX - M[1].pageX,
				se = M[0].pageY - M[1].pageY,
				Re = Math.sqrt(T * T + se * se);
			x.set(0, Re);
		}
		function ve() {
			i.enableZoom && U(), i.enablePan && ue();
		}
		function Ae() {
			i.enableZoom && U(), i.enableRotate && W();
		}
		function Te(T) {
			if (M.length == 1) p.set(T.pageX, T.pageY);
			else {
				const Re = Me(T),
					_e = 0.5 * (T.pageX + Re.x),
					O = 0.5 * (T.pageY + Re.y);
				p.set(_e, O);
			}
			g.subVectors(p, d).multiplyScalar(i.rotateSpeed);
			const se = i.domElement;
			re((2 * Math.PI * g.x) / se.clientHeight),
			B((2 * Math.PI * g.y) / se.clientHeight),
			d.copy(p);
		}
		function ae(T) {
			if (M.length === 1) f.set(T.pageX, T.pageY);
			else {
				const se = Me(T),
					Re = 0.5 * (T.pageX + se.x),
					_e = 0.5 * (T.pageY + se.y);
				f.set(Re, _e);
			}
			v.subVectors(f, m).multiplyScalar(i.panSpeed),
			j(v.x, v.y),
			m.copy(f);
		}
		function K(T) {
			const se = Me(T),
				Re = T.pageX - se.x,
				_e = T.pageY - se.y,
				O = Math.sqrt(Re * Re + _e * _e);
			A.set(0, O),
			S.set(0, Math.pow(A.y / x.y, i.zoomSpeed)),
			z(S.y),
			x.copy(A);
		}
		function te(T) {
			i.enableZoom && K(T), i.enablePan && ae(T);
		}
		function w(T) {
			i.enableZoom && K(T), i.enableRotate && Te(T);
		}
		function R(T) {
			i.enabled !== !1 &&
                (M.length === 0 &&
                    (i.domElement.setPointerCapture(T.pointerId),
                    i.domElement.addEventListener('pointermove', N),
                    i.domElement.addEventListener('pointerup', q)),
                Y(T),
                T.pointerType === 'touch' ? _(T) : ne(T));
		}
		function N(T) {
			i.enabled !== !1 && (T.pointerType === 'touch' ? y(T) : le(T));
		}
		function q(T) {
			oe(T),
			M.length === 0 &&
                    (i.domElement.releasePointerCapture(T.pointerId),
                    i.domElement.removeEventListener('pointermove', N),
                    i.domElement.removeEventListener('pointerup', q)),
			i.dispatchEvent(Bp),
			(a = n.NONE);
		}
		function $(T) {
			oe(T);
		}
		function ne(T) {
			let se;
			switch (T.button) {
			case 0:
				se = i.mouseButtons.LEFT;
				break;
			case 1:
				se = i.mouseButtons.MIDDLE;
				break;
			case 2:
				se = i.mouseButtons.RIGHT;
				break;
			default:
				se = -1;
			}
			switch (se) {
			case yn.DOLLY:
				if (i.enableZoom === !1) return;
				k(T), (a = n.DOLLY);
				break;
			case yn.ROTATE:
				if (T.ctrlKey || T.metaKey || T.shiftKey) {
					if (i.enablePan === !1) return;
					P(T), (a = n.PAN);
				} else {
					if (i.enableRotate === !1) return;
					H(T), (a = n.ROTATE);
				}
				break;
			case yn.PAN:
				if (T.ctrlKey || T.metaKey || T.shiftKey) {
					if (i.enableRotate === !1) return;
					H(T), (a = n.ROTATE);
				} else {
					if (i.enablePan === !1) return;
					P(T), (a = n.PAN);
				}
				break;
			default:
				a = n.NONE;
			}
			a !== n.NONE && i.dispatchEvent(hc);
		}
		function le(T) {
			if (i.enabled !== !1)
				switch (a) {
				case n.ROTATE:
					if (i.enableRotate === !1) return;
					Z(T);
					break;
				case n.DOLLY:
					if (i.enableZoom === !1) return;
					J(T);
					break;
				case n.PAN:
					if (i.enablePan === !1) return;
					fe(T);
					break;
				}
		}
		function he(T) {
			i.enabled === !1 ||
                i.enableZoom === !1 ||
                a !== n.NONE ||
                (T.preventDefault(),
                i.dispatchEvent(hc),
                ce(T),
                i.dispatchEvent(Bp));
		}
		function ge(T) {
			i.enabled === !1 || i.enablePan === !1 || xe(T);
		}
		function _(T) {
			switch ((pe(T), M.length)) {
			case 1:
				switch (i.touches.ONE) {
				case xn.ROTATE:
					if (i.enableRotate === !1) return;
					W(), (a = n.TOUCH_ROTATE);
					break;
				case xn.PAN:
					if (i.enablePan === !1) return;
					ue(), (a = n.TOUCH_PAN);
					break;
				default:
					a = n.NONE;
				}
				break;
			case 2:
				switch (i.touches.TWO) {
				case xn.DOLLY_PAN:
					if (i.enableZoom === !1 && i.enablePan === !1)
						return;
					ve(), (a = n.TOUCH_DOLLY_PAN);
					break;
				case xn.DOLLY_ROTATE:
					if (i.enableZoom === !1 && i.enableRotate === !1)
						return;
					Ae(), (a = n.TOUCH_DOLLY_ROTATE);
					break;
				default:
					a = n.NONE;
				}
				break;
			default:
				a = n.NONE;
			}
			a !== n.NONE && i.dispatchEvent(hc);
		}
		function y(T) {
			switch ((pe(T), a)) {
			case n.TOUCH_ROTATE:
				if (i.enableRotate === !1) return;
				Te(T), i.update();
				break;
			case n.TOUCH_PAN:
				if (i.enablePan === !1) return;
				ae(T), i.update();
				break;
			case n.TOUCH_DOLLY_PAN:
				if (i.enableZoom === !1 && i.enablePan === !1) return;
				te(T), i.update();
				break;
			case n.TOUCH_DOLLY_ROTATE:
				if (i.enableZoom === !1 && i.enableRotate === !1) return;
				w(T), i.update();
				break;
			default:
				a = n.NONE;
			}
		}
		function F(T) {
			i.enabled !== !1 && T.preventDefault();
		}
		function Y(T) {
			M.push(T);
		}
		function oe(T) {
			delete I[T.pointerId];
			for (let se = 0; se < M.length; se++)
				if (M[se].pointerId == T.pointerId) {
					M.splice(se, 1);
					return;
				}
		}
		function pe(T) {
			let se = I[T.pointerId];
			se === void 0 && ((se = new me()), (I[T.pointerId] = se)),
			se.set(T.pageX, T.pageY);
		}
		function Me(T) {
			const se = T.pointerId === M[0].pointerId ? M[1] : M[0];
			return I[se.pointerId];
		}
		i.domElement.addEventListener('contextmenu', F),
		i.domElement.addEventListener('pointerdown', R),
		i.domElement.addEventListener('pointercancel', $),
		i.domElement.addEventListener('wheel', he, { passive: !1 }),
		this.update();
	}
}
class x2 extends ri {
	constructor(e) {
		super(e),
		(this.dracoLoader = null),
		(this.ktx2Loader = null),
		(this.meshoptDecoder = null),
		(this.pluginCallbacks = []),
		this.register(function (t) {
			return new M2(t);
		}),
		this.register(function (t) {
			return new R2(t);
		}),
		this.register(function (t) {
			return new k2(t);
		}),
		this.register(function (t) {
			return new S2(t);
		}),
		this.register(function (t) {
			return new T2(t);
		}),
		this.register(function (t) {
			return new E2(t);
		}),
		this.register(function (t) {
			return new A2(t);
		}),
		this.register(function (t) {
			return new L2(t);
		}),
		this.register(function (t) {
			return new w2(t);
		}),
		this.register(function (t) {
			return new C2(t);
		});
	}
	load(e, t, i, n) {
		const a = this;
		let s;
		this.resourcePath !== ''
			? (s = this.resourcePath)
			: this.path !== ''
				? (s = this.path)
				: (s = Ri.extractUrlBase(e)),
		this.manager.itemStart(e);
		const o = function (c) {
				n ? n(c) : console.error(c),
				a.manager.itemError(e),
				a.manager.itemEnd(e);
			},
			l = new Yu(this.manager);
		l.setPath(this.path),
		l.setResponseType('arraybuffer'),
		l.setRequestHeader(this.requestHeader),
		l.setWithCredentials(this.withCredentials),
		l.load(
			e,
			function (c) {
				try {
					a.parse(
						c,
						s,
						function (u) {
							t(u), a.manager.itemEnd(e);
						},
						o
					);
				} catch (u) {
					o(u);
				}
			},
			i,
			o
		);
	}
	setDRACOLoader(e) {
		return (this.dracoLoader = e), this;
	}
	setDDSLoader() {
		throw new Error(
			'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
		);
	}
	setKTX2Loader(e) {
		return (this.ktx2Loader = e), this;
	}
	setMeshoptDecoder(e) {
		return (this.meshoptDecoder = e), this;
	}
	register(e) {
		return (
			this.pluginCallbacks.indexOf(e) === -1 &&
                this.pluginCallbacks.push(e),
			this
		);
	}
	unregister(e) {
		return (
			this.pluginCallbacks.indexOf(e) !== -1 &&
                this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
			this
		);
	}
	parse(e, t, i, n) {
		let a;
		const s = {},
			o = {};
		if (typeof e == 'string') a = e;
		else if (Ri.decodeText(new Uint8Array(e, 0, 4)) === Rg) {
			try {
				s[We.KHR_BINARY_GLTF] = new P2(e);
			} catch (u) {
				n && n(u);
				return;
			}
			a = s[We.KHR_BINARY_GLTF].content;
		} else a = Ri.decodeText(new Uint8Array(e));
		const l = JSON.parse(a);
		if (l.asset === void 0 || l.asset.version[0] < 2) {
			n &&
                n(
                	new Error(
                		'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'
                	)
                );
			return;
		}
		const c = new j2(l, {
			path: t || this.resourcePath || '',
			crossOrigin: this.crossOrigin,
			requestHeader: this.requestHeader,
			manager: this.manager,
			ktx2Loader: this.ktx2Loader,
			meshoptDecoder: this.meshoptDecoder
		});
		c.fileLoader.setRequestHeader(this.requestHeader);
		for (let u = 0; u < this.pluginCallbacks.length; u++) {
			const h = this.pluginCallbacks[u](c);
			(o[h.name] = h), (s[h.name] = !0);
		}
		if (l.extensionsUsed)
			for (let u = 0; u < l.extensionsUsed.length; ++u) {
				const h = l.extensionsUsed[u],
					d = l.extensionsRequired || [];
				switch (h) {
				case We.KHR_MATERIALS_UNLIT:
					s[h] = new _2();
					break;
				case We.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
					s[h] = new O2();
					break;
				case We.KHR_DRACO_MESH_COMPRESSION:
					s[h] = new I2(l, this.dracoLoader);
					break;
				case We.KHR_TEXTURE_TRANSFORM:
					s[h] = new D2();
					break;
				case We.KHR_MESH_QUANTIZATION:
					s[h] = new N2();
					break;
				default:
					d.indexOf(h) >= 0 &&
                            o[h] === void 0 &&
                            console.warn(
                            	'THREE.GLTFLoader: Unknown extension "' +
                                    h +
                                    '".'
                            );
				}
			}
		c.setExtensions(s), c.setPlugins(o), c.parse(i, n);
	}
	parseAsync(e, t) {
		const i = this;
		return new Promise(function (n, a) {
			i.parse(e, t, n, a);
		});
	}
}
function b2() {
	let r = {};
	return {
		get: function (e) {
			return r[e];
		},
		add: function (e, t) {
			r[e] = t;
		},
		remove: function (e) {
			delete r[e];
		},
		removeAll: function () {
			r = {};
		}
	};
}
const We = {
	KHR_BINARY_GLTF: 'KHR_binary_glTF',
	KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
	KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
	KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
	KHR_MATERIALS_IOR: 'KHR_materials_ior',
	KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
        'KHR_materials_pbrSpecularGlossiness',
	KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
	KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
	KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
	KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
	KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
	KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
	KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
	KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
	EXT_TEXTURE_WEBP: 'EXT_texture_webp',
	EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'
};
class w2 {
	constructor(e) {
		(this.parser = e),
		(this.name = We.KHR_LIGHTS_PUNCTUAL),
		(this.cache = { refs: {}, uses: {} });
	}
	_markDefs() {
		const e = this.parser,
			t = this.parser.json.nodes || [];
		for (let i = 0, n = t.length; i < n; i++) {
			const a = t[i];
			a.extensions &&
                a.extensions[this.name] &&
                a.extensions[this.name].light !== void 0 &&
                e._addNodeRef(this.cache, a.extensions[this.name].light);
		}
	}
	_loadLight(e) {
		const t = this.parser,
			i = 'light:' + e;
		let n = t.cache.get(i);
		if (n) return n;
		const a = t.json,
			s = (((a.extensions && a.extensions[this.name]) || {}).lights ||
                [])[e];
		let o;
		const l = new ke(16777215);
		s.color !== void 0 && l.fromArray(s.color);
		const c = s.range !== void 0 ? s.range : 0;
		switch (s.type) {
		case 'directional':
			(o = new Ku(l)),
			o.target.position.set(0, 0, -1),
			o.add(o.target);
			break;
		case 'point':
			(o = new $u(l)), (o.distance = c);
			break;
		case 'spot':
			(o = new wg(l)),
			(o.distance = c),
			(s.spot = s.spot || {}),
			(s.spot.innerConeAngle =
                        s.spot.innerConeAngle !== void 0
                        	? s.spot.innerConeAngle
                        	: 0),
			(s.spot.outerConeAngle =
                        s.spot.outerConeAngle !== void 0
                        	? s.spot.outerConeAngle
                        	: Math.PI / 4),
			(o.angle = s.spot.outerConeAngle),
			(o.penumbra =
                        1 - s.spot.innerConeAngle / s.spot.outerConeAngle),
			o.target.position.set(0, 0, -1),
			o.add(o.target);
			break;
		default:
			throw new Error(
				'THREE.GLTFLoader: Unexpected light type: ' + s.type
			);
		}
		return (
			o.position.set(0, 0, 0),
			(o.decay = 2),
			s.intensity !== void 0 && (o.intensity = s.intensity),
			(o.name = t.createUniqueName(s.name || 'light_' + e)),
			(n = Promise.resolve(o)),
			t.cache.add(i, n),
			n
		);
	}
	createNodeAttachment(e) {
		const t = this,
			i = this.parser,
			n = i.json.nodes[e],
			a = ((n.extensions && n.extensions[this.name]) || {}).light;
		return a === void 0
			? null
			: this._loadLight(a).then(function (s) {
				return i._getNodeRef(t.cache, a, s);
			});
	}
}
class _2 {
	constructor() {
		this.name = We.KHR_MATERIALS_UNLIT;
	}
	getMaterialType() {
		return Cr;
	}
	extendParams(e, t, i) {
		const n = [];
		(e.color = new ke(1, 1, 1)), (e.opacity = 1);
		const a = t.pbrMetallicRoughness;
		if (a) {
			if (Array.isArray(a.baseColorFactor)) {
				const s = a.baseColorFactor;
				e.color.fromArray(s), (e.opacity = s[3]);
			}
			a.baseColorTexture !== void 0 &&
                n.push(i.assignTexture(e, 'map', a.baseColorTexture, Ze));
		}
		return Promise.all(n);
	}
}
class M2 {
	constructor(e) {
		(this.parser = e), (this.name = We.KHR_MATERIALS_CLEARCOAT);
	}
	getMaterialType(e) {
		const t = this.parser.json.materials[e];
		return !t.extensions || !t.extensions[this.name] ? null : Ni;
	}
	extendMaterialParams(e, t) {
		const i = this.parser,
			n = i.json.materials[e];
		if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
		const a = [],
			s = n.extensions[this.name];
		if (
			(s.clearcoatFactor !== void 0 && (t.clearcoat = s.clearcoatFactor),
			s.clearcoatTexture !== void 0 &&
                a.push(i.assignTexture(t, 'clearcoatMap', s.clearcoatTexture)),
			s.clearcoatRoughnessFactor !== void 0 &&
                (t.clearcoatRoughness = s.clearcoatRoughnessFactor),
			s.clearcoatRoughnessTexture !== void 0 &&
                a.push(
                	i.assignTexture(
                		t,
                		'clearcoatRoughnessMap',
                		s.clearcoatRoughnessTexture
                	)
                ),
			s.clearcoatNormalTexture !== void 0 &&
                (a.push(
                	i.assignTexture(
                		t,
                		'clearcoatNormalMap',
                		s.clearcoatNormalTexture
                	)
                ),
                s.clearcoatNormalTexture.scale !== void 0))
		) {
			const o = s.clearcoatNormalTexture.scale;
			t.clearcoatNormalScale = new me(o, o);
		}
		return Promise.all(a);
	}
}
class S2 {
	constructor(e) {
		(this.parser = e), (this.name = We.KHR_MATERIALS_SHEEN);
	}
	getMaterialType(e) {
		const t = this.parser.json.materials[e];
		return !t.extensions || !t.extensions[this.name] ? null : Ni;
	}
	extendMaterialParams(e, t) {
		const i = this.parser,
			n = i.json.materials[e];
		if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
		const a = [];
		(t.sheenColor = new ke(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
		const s = n.extensions[this.name];
		return (
			s.sheenColorFactor !== void 0 &&
                t.sheenColor.fromArray(s.sheenColorFactor),
			s.sheenRoughnessFactor !== void 0 &&
                (t.sheenRoughness = s.sheenRoughnessFactor),
			s.sheenColorTexture !== void 0 &&
                a.push(
                	i.assignTexture(t, 'sheenColorMap', s.sheenColorTexture, Ze)
                ),
			s.sheenRoughnessTexture !== void 0 &&
                a.push(
                	i.assignTexture(
                		t,
                		'sheenRoughnessMap',
                		s.sheenRoughnessTexture
                	)
                ),
			Promise.all(a)
		);
	}
}
class T2 {
	constructor(e) {
		(this.parser = e), (this.name = We.KHR_MATERIALS_TRANSMISSION);
	}
	getMaterialType(e) {
		const t = this.parser.json.materials[e];
		return !t.extensions || !t.extensions[this.name] ? null : Ni;
	}
	extendMaterialParams(e, t) {
		const i = this.parser,
			n = i.json.materials[e];
		if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
		const a = [],
			s = n.extensions[this.name];
		return (
			s.transmissionFactor !== void 0 &&
                (t.transmission = s.transmissionFactor),
			s.transmissionTexture !== void 0 &&
                a.push(
                	i.assignTexture(t, 'transmissionMap', s.transmissionTexture)
                ),
			Promise.all(a)
		);
	}
}
class E2 {
	constructor(e) {
		(this.parser = e), (this.name = We.KHR_MATERIALS_VOLUME);
	}
	getMaterialType(e) {
		const t = this.parser.json.materials[e];
		return !t.extensions || !t.extensions[this.name] ? null : Ni;
	}
	extendMaterialParams(e, t) {
		const i = this.parser,
			n = i.json.materials[e];
		if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
		const a = [],
			s = n.extensions[this.name];
		(t.thickness = s.thicknessFactor !== void 0 ? s.thicknessFactor : 0),
		s.thicknessTexture !== void 0 &&
                a.push(i.assignTexture(t, 'thicknessMap', s.thicknessTexture)),
		(t.attenuationDistance = s.attenuationDistance || 0);
		const o = s.attenuationColor || [1, 1, 1];
		return (t.attenuationColor = new ke(o[0], o[1], o[2])), Promise.all(a);
	}
}
class A2 {
	constructor(e) {
		(this.parser = e), (this.name = We.KHR_MATERIALS_IOR);
	}
	getMaterialType(e) {
		const t = this.parser.json.materials[e];
		return !t.extensions || !t.extensions[this.name] ? null : Ni;
	}
	extendMaterialParams(e, t) {
		const i = this.parser.json.materials[e];
		if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
		const n = i.extensions[this.name];
		return (t.ior = n.ior !== void 0 ? n.ior : 1.5), Promise.resolve();
	}
}
class L2 {
	constructor(e) {
		(this.parser = e), (this.name = We.KHR_MATERIALS_SPECULAR);
	}
	getMaterialType(e) {
		const t = this.parser.json.materials[e];
		return !t.extensions || !t.extensions[this.name] ? null : Ni;
	}
	extendMaterialParams(e, t) {
		const i = this.parser,
			n = i.json.materials[e];
		if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
		const a = [],
			s = n.extensions[this.name];
		(t.specularIntensity =
            s.specularFactor !== void 0 ? s.specularFactor : 1),
		s.specularTexture !== void 0 &&
                a.push(
                	i.assignTexture(
                		t,
                		'specularIntensityMap',
                		s.specularTexture
                	)
                );
		const o = s.specularColorFactor || [1, 1, 1];
		return (
			(t.specularColor = new ke(o[0], o[1], o[2])),
			s.specularColorTexture !== void 0 &&
                a.push(
                	i.assignTexture(
                		t,
                		'specularColorMap',
                		s.specularColorTexture,
                		Ze
                	)
                ),
			Promise.all(a)
		);
	}
}
class R2 {
	constructor(e) {
		(this.parser = e), (this.name = We.KHR_TEXTURE_BASISU);
	}
	loadTexture(e) {
		const t = this.parser,
			i = t.json,
			n = i.textures[e];
		if (!n.extensions || !n.extensions[this.name]) return null;
		const a = n.extensions[this.name],
			s = t.options.ktx2Loader;
		if (!s) {
			if (
				i.extensionsRequired &&
                i.extensionsRequired.indexOf(this.name) >= 0
			)
				throw new Error(
					'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures'
				);
			return null;
		}
		return t.loadTextureImage(e, a.source, s);
	}
}
class k2 {
	constructor(e) {
		(this.parser = e),
		(this.name = We.EXT_TEXTURE_WEBP),
		(this.isSupported = null);
	}
	loadTexture(e) {
		const t = this.name,
			i = this.parser,
			n = i.json,
			a = n.textures[e];
		if (!a.extensions || !a.extensions[t]) return null;
		const s = a.extensions[t],
			o = n.images[s.source];
		let l = i.textureLoader;
		if (o.uri) {
			const c = i.options.manager.getHandler(o.uri);
			c !== null && (l = c);
		}
		return this.detectSupport().then(function (c) {
			if (c) return i.loadTextureImage(e, s.source, l);
			if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
				throw new Error(
					'THREE.GLTFLoader: WebP required by asset but unsupported.'
				);
			return i.loadTexture(e);
		});
	}
	detectSupport() {
		return (
			this.isSupported ||
                (this.isSupported = new Promise(function (e) {
                	const t = new Image();
                	(t.src =
                        'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'),
                	(t.onload = t.onerror =
                            function () {
                            	e(t.height === 1);
                            });
                })),
			this.isSupported
		);
	}
}
class C2 {
	constructor(e) {
		(this.name = We.EXT_MESHOPT_COMPRESSION), (this.parser = e);
	}
	loadBufferView(e) {
		const t = this.parser.json,
			i = t.bufferViews[e];
		if (i.extensions && i.extensions[this.name]) {
			const n = i.extensions[this.name],
				a = this.parser.getDependency('buffer', n.buffer),
				s = this.parser.options.meshoptDecoder;
			if (!s || !s.supported) {
				if (
					t.extensionsRequired &&
                    t.extensionsRequired.indexOf(this.name) >= 0
				)
					throw new Error(
						'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files'
					);
				return null;
			}
			return Promise.all([a, s.ready]).then(function (o) {
				const l = n.byteOffset || 0,
					c = n.byteLength || 0,
					u = n.count,
					h = n.byteStride,
					d = new ArrayBuffer(u * h),
					p = new Uint8Array(o[0], l, c);
				return (
					s.decodeGltfBuffer(
						new Uint8Array(d),
						u,
						h,
						p,
						n.mode,
						n.filter
					),
					d
				);
			});
		} else return null;
	}
}
const Rg = 'glTF',
	Ga = 12,
	Fp = { JSON: 1313821514, BIN: 5130562 };
class P2 {
	constructor(e) {
		(this.name = We.KHR_BINARY_GLTF),
		(this.content = null),
		(this.body = null);
		const t = new DataView(e, 0, Ga);
		if (
			((this.header = {
				magic: Ri.decodeText(new Uint8Array(e.slice(0, 4))),
				version: t.getUint32(4, !0),
				length: t.getUint32(8, !0)
			}),
			this.header.magic !== Rg)
		)
			throw new Error(
				'THREE.GLTFLoader: Unsupported glTF-Binary header.'
			);
		if (this.header.version < 2)
			throw new Error('THREE.GLTFLoader: Legacy binary file detected.');
		const i = this.header.length - Ga,
			n = new DataView(e, Ga);
		let a = 0;
		for (; a < i; ) {
			const s = n.getUint32(a, !0);
			a += 4;
			const o = n.getUint32(a, !0);
			if (((a += 4), o === Fp.JSON)) {
				const l = new Uint8Array(e, Ga + a, s);
				this.content = Ri.decodeText(l);
			} else if (o === Fp.BIN) {
				const l = Ga + a;
				this.body = e.slice(l, l + s);
			}
			a += s;
		}
		if (this.content === null)
			throw new Error('THREE.GLTFLoader: JSON content not found.');
	}
}
class I2 {
	constructor(e, t) {
		if (!t)
			throw new Error(
				'THREE.GLTFLoader: No DRACOLoader instance provided.'
			);
		(this.name = We.KHR_DRACO_MESH_COMPRESSION),
		(this.json = e),
		(this.dracoLoader = t),
		this.dracoLoader.preload();
	}
	decodePrimitive(e, t) {
		const i = this.json,
			n = this.dracoLoader,
			a = e.extensions[this.name].bufferView,
			s = e.extensions[this.name].attributes,
			o = {},
			l = {},
			c = {};
		for (const u in s) {
			const h = eu[u] || u.toLowerCase();
			o[h] = s[u];
		}
		for (const u in e.attributes) {
			const h = eu[u] || u.toLowerCase();
			if (s[u] !== void 0) {
				const d = i.accessors[e.attributes[u]],
					p = Ss[d.componentType];
				(c[h] = p), (l[h] = d.normalized === !0);
			}
		}
		return t.getDependency('bufferView', a).then(function (u) {
			return new Promise(function (h) {
				n.decodeDracoFile(
					u,
					function (d) {
						for (const p in d.attributes) {
							const g = d.attributes[p],
								m = l[p];
							m !== void 0 && (g.normalized = m);
						}
						h(d);
					},
					o,
					c
				);
			});
		});
	}
}
class D2 {
	constructor() {
		this.name = We.KHR_TEXTURE_TRANSFORM;
	}
	extendTexture(e, t) {
		return (
			t.texCoord !== void 0 &&
                console.warn(
                	'THREE.GLTFLoader: Custom UV sets in "' +
                        this.name +
                        '" extension not yet supported.'
                ),
			(t.offset === void 0 &&
                t.rotation === void 0 &&
                t.scale === void 0) ||
                ((e = e.clone()),
                t.offset !== void 0 && e.offset.fromArray(t.offset),
                t.rotation !== void 0 && (e.rotation = t.rotation),
                t.scale !== void 0 && e.repeat.fromArray(t.scale),
                (e.needsUpdate = !0)),
			e
		);
	}
}
class Qc extends Ii {
	constructor(e) {
		super(), (this.isGLTFSpecularGlossinessMaterial = !0);
		const t = [
				'#ifdef USE_SPECULARMAP',
				'	uniform sampler2D specularMap;',
				'#endif'
			].join(`
`),
			i = [
				'#ifdef USE_GLOSSINESSMAP',
				'	uniform sampler2D glossinessMap;',
				'#endif'
			].join(`
`),
			n = [
				'vec3 specularFactor = specular;',
				'#ifdef USE_SPECULARMAP',
				'	vec4 texelSpecular = texture2D( specularMap, vUv );',
				'	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
				'	specularFactor *= texelSpecular.rgb;',
				'#endif'
			].join(`
`),
			a = [
				'float glossinessFactor = glossiness;',
				'#ifdef USE_GLOSSINESSMAP',
				'	vec4 texelGlossiness = texture2D( glossinessMap, vUv );',
				'	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
				'	glossinessFactor *= texelGlossiness.a;',
				'#endif'
			].join(`
`),
			s = [
				'PhysicalMaterial material;',
				'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',
				'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',
				'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',
				'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',
				'material.roughness += geometryRoughness;',
				'material.roughness = min( material.roughness, 1.0 );',
				'material.specularColor = specularFactor;'
			].join(`
`),
			o = {
				specular: { value: new ke().setHex(16777215) },
				glossiness: { value: 1 },
				specularMap: { value: null },
				glossinessMap: { value: null }
			};
		(this._extraUniforms = o),
		(this.onBeforeCompile = function (l) {
			for (const c in o) l.uniforms[c] = o[c];
			l.fragmentShader = l.fragmentShader
				.replace(
					'uniform float roughness;',
					'uniform vec3 specular;'
				)
				.replace(
					'uniform float metalness;',
					'uniform float glossiness;'
				)
				.replace('#include <roughnessmap_pars_fragment>', t)
				.replace('#include <metalnessmap_pars_fragment>', i)
				.replace('#include <roughnessmap_fragment>', n)
				.replace('#include <metalnessmap_fragment>', a)
				.replace('#include <lights_physical_fragment>', s);
		}),
		Object.defineProperties(this, {
			specular: {
				get: function () {
					return o.specular.value;
				},
				set: function (l) {
					o.specular.value = l;
				}
			},
			specularMap: {
				get: function () {
					return o.specularMap.value;
				},
				set: function (l) {
					(o.specularMap.value = l),
					l
						? (this.defines.USE_SPECULARMAP = '')
						: delete this.defines.USE_SPECULARMAP;
				}
			},
			glossiness: {
				get: function () {
					return o.glossiness.value;
				},
				set: function (l) {
					o.glossiness.value = l;
				}
			},
			glossinessMap: {
				get: function () {
					return o.glossinessMap.value;
				},
				set: function (l) {
					(o.glossinessMap.value = l),
					l
						? ((this.defines.USE_GLOSSINESSMAP = ''),
						(this.defines.USE_UV = ''))
						: (delete this.defines.USE_GLOSSINESSMAP,
						delete this.defines.USE_UV);
				}
			}
		}),
		delete this.metalness,
		delete this.roughness,
		delete this.metalnessMap,
		delete this.roughnessMap,
		this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			(this.specularMap = e.specularMap),
			this.specular.copy(e.specular),
			(this.glossinessMap = e.glossinessMap),
			(this.glossiness = e.glossiness),
			delete this.metalness,
			delete this.roughness,
			delete this.metalnessMap,
			delete this.roughnessMap,
			this
		);
	}
}
class O2 {
	constructor() {
		(this.name = We.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS),
		(this.specularGlossinessParams = [
			'color',
			'map',
			'lightMap',
			'lightMapIntensity',
			'aoMap',
			'aoMapIntensity',
			'emissive',
			'emissiveIntensity',
			'emissiveMap',
			'bumpMap',
			'bumpScale',
			'normalMap',
			'normalMapType',
			'displacementMap',
			'displacementScale',
			'displacementBias',
			'specularMap',
			'specular',
			'glossinessMap',
			'glossiness',
			'alphaMap',
			'envMap',
			'envMapIntensity'
		]);
	}
	getMaterialType() {
		return Qc;
	}
	extendParams(e, t, i) {
		const n = t.extensions[this.name];
		(e.color = new ke(1, 1, 1)), (e.opacity = 1);
		const a = [];
		if (Array.isArray(n.diffuseFactor)) {
			const s = n.diffuseFactor;
			e.color.fromArray(s), (e.opacity = s[3]);
		}
		if (
			(n.diffuseTexture !== void 0 &&
                a.push(i.assignTexture(e, 'map', n.diffuseTexture, Ze)),
			(e.emissive = new ke(0, 0, 0)),
			(e.glossiness =
                n.glossinessFactor !== void 0 ? n.glossinessFactor : 1),
			(e.specular = new ke(1, 1, 1)),
			Array.isArray(n.specularFactor) &&
                e.specular.fromArray(n.specularFactor),
			n.specularGlossinessTexture !== void 0)
		) {
			const s = n.specularGlossinessTexture;
			a.push(i.assignTexture(e, 'glossinessMap', s)),
			a.push(i.assignTexture(e, 'specularMap', s, Ze));
		}
		return Promise.all(a);
	}
	createMaterial(e) {
		const t = new Qc(e);
		return (
			(t.fog = !0),
			(t.color = e.color),
			(t.map = e.map === void 0 ? null : e.map),
			(t.lightMap = null),
			(t.lightMapIntensity = 1),
			(t.aoMap = e.aoMap === void 0 ? null : e.aoMap),
			(t.aoMapIntensity = 1),
			(t.emissive = e.emissive),
			(t.emissiveIntensity = 1),
			(t.emissiveMap = e.emissiveMap === void 0 ? null : e.emissiveMap),
			(t.bumpMap = e.bumpMap === void 0 ? null : e.bumpMap),
			(t.bumpScale = 1),
			(t.normalMap = e.normalMap === void 0 ? null : e.normalMap),
			(t.normalMapType = un),
			e.normalScale && (t.normalScale = e.normalScale),
			(t.displacementMap = null),
			(t.displacementScale = 1),
			(t.displacementBias = 0),
			(t.specularMap = e.specularMap === void 0 ? null : e.specularMap),
			(t.specular = e.specular),
			(t.glossinessMap =
                e.glossinessMap === void 0 ? null : e.glossinessMap),
			(t.glossiness = e.glossiness),
			(t.alphaMap = null),
			(t.envMap = e.envMap === void 0 ? null : e.envMap),
			(t.envMapIntensity = 1),
			t
		);
	}
}
class N2 {
	constructor() {
		this.name = We.KHR_MESH_QUANTIZATION;
	}
}
class ln extends ei {
	constructor(e, t, i, n) {
		super(e, t, i, n);
	}
	copySampleValue_(e) {
		const t = this.resultBuffer,
			i = this.sampleValues,
			n = this.valueSize,
			a = e * n * 3 + n;
		for (let s = 0; s !== n; s++) t[s] = i[a + s];
		return t;
	}
}
ln.prototype.beforeStart_ = ln.prototype.copySampleValue_;
ln.prototype.afterEnd_ = ln.prototype.copySampleValue_;
ln.prototype.interpolate_ = function (r, e, t, i) {
	const n = this.resultBuffer,
		a = this.sampleValues,
		s = this.valueSize,
		o = s * 2,
		l = s * 3,
		c = i - e,
		u = (t - e) / c,
		h = u * u,
		d = h * u,
		p = r * l,
		g = p - l,
		m = -2 * d + 3 * h,
		f = d - h,
		v = 1 - m,
		x = f - h + u;
	for (let A = 0; A !== s; A++) {
		const S = a[g + A + s],
			M = a[g + A + o] * c,
			I = a[p + A + s],
			D = a[p + A] * c;
		n[A] = v * S + x * M + m * I + f * D;
	}
	return n;
};
const z2 = new Ct();
class U2 extends ln {
	interpolate_(e, t, i, n) {
		const a = super.interpolate_(e, t, i, n);
		return z2.fromArray(a).normalize().toArray(a), a;
	}
}
const Wr = {
		FLOAT: 5126,
		FLOAT_MAT3: 35675,
		FLOAT_MAT4: 35676,
		FLOAT_VEC2: 35664,
		FLOAT_VEC3: 35665,
		FLOAT_VEC4: 35666,
		LINEAR: 9729,
		REPEAT: 10497,
		SAMPLER_2D: 35678,
		POINTS: 0,
		LINES: 1,
		LINE_LOOP: 2,
		LINE_STRIP: 3,
		TRIANGLES: 4,
		TRIANGLE_STRIP: 5,
		TRIANGLE_FAN: 6,
		UNSIGNED_BYTE: 5121,
		UNSIGNED_SHORT: 5123
	},
	Ss = {
		5120: Int8Array,
		5121: Uint8Array,
		5122: Int16Array,
		5123: Uint16Array,
		5125: Uint32Array,
		5126: Float32Array
	},
	Hp = { 9728: Mt, 9729: Nt, 9984: Hc, 9985: Lf, 9986: Gc, 9987: ba },
	Gp = { 33071: Kt, 33648: Oo, 10497: oa },
	Vp = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
	eu = {
		POSITION: 'position',
		NORMAL: 'normal',
		TANGENT: 'tangent',
		TEXCOORD_0: 'uv',
		TEXCOORD_1: 'uv2',
		COLOR_0: 'color',
		WEIGHTS_0: 'skinWeight',
		JOINTS_0: 'skinIndex'
	},
	fi = {
		scale: 'scale',
		translation: 'position',
		rotation: 'quaternion',
		weights: 'morphTargetInfluences'
	},
	B2 = { CUBICSPLINE: void 0, LINEAR: ca, STEP: fs },
	dc = { OPAQUE: 'OPAQUE', MASK: 'MASK', BLEND: 'BLEND' };
function F2(r) {
	return (
		r.DefaultMaterial === void 0 &&
            (r.DefaultMaterial = new Ii({
            	color: 16777215,
            	emissive: 0,
            	metalness: 1,
            	roughness: 1,
            	transparent: !1,
            	depthTest: !0,
            	side: na
            })),
		r.DefaultMaterial
	);
}
function Va(r, e, t) {
	for (const i in t.extensions)
		r[i] === void 0 &&
            ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
            (e.userData.gltfExtensions[i] = t.extensions[i]));
}
function qi(r, e) {
	e.extras !== void 0 &&
        (typeof e.extras == 'object'
        	? Object.assign(r.userData, e.extras)
        	: console.warn(
        		'THREE.GLTFLoader: Ignoring primitive type .extras, ' +
                      e.extras
        	));
}
function H2(r, e, t) {
	let i = !1,
		n = !1,
		a = !1;
	for (let c = 0, u = e.length; c < u; c++) {
		const h = e[c];
		if (
			(h.POSITION !== void 0 && (i = !0),
			h.NORMAL !== void 0 && (n = !0),
			h.COLOR_0 !== void 0 && (a = !0),
			i && n && a)
		)
			break;
	}
	if (!i && !n && !a) return Promise.resolve(r);
	const s = [],
		o = [],
		l = [];
	for (let c = 0, u = e.length; c < u; c++) {
		const h = e[c];
		if (i) {
			const d =
                h.POSITION !== void 0
                	? t.getDependency('accessor', h.POSITION)
                	: r.attributes.position;
			s.push(d);
		}
		if (n) {
			const d =
                h.NORMAL !== void 0
                	? t.getDependency('accessor', h.NORMAL)
                	: r.attributes.normal;
			o.push(d);
		}
		if (a) {
			const d =
                h.COLOR_0 !== void 0
                	? t.getDependency('accessor', h.COLOR_0)
                	: r.attributes.color;
			l.push(d);
		}
	}
	return Promise.all([Promise.all(s), Promise.all(o), Promise.all(l)]).then(
		function (c) {
			const u = c[0],
				h = c[1],
				d = c[2];
			return (
				i && (r.morphAttributes.position = u),
				n && (r.morphAttributes.normal = h),
				a && (r.morphAttributes.color = d),
				(r.morphTargetsRelative = !0),
				r
			);
		}
	);
}
function G2(r, e) {
	if ((r.updateMorphTargets(), e.weights !== void 0))
		for (let t = 0, i = e.weights.length; t < i; t++)
			r.morphTargetInfluences[t] = e.weights[t];
	if (e.extras && Array.isArray(e.extras.targetNames)) {
		const t = e.extras.targetNames;
		if (r.morphTargetInfluences.length === t.length) {
			r.morphTargetDictionary = {};
			for (let i = 0, n = t.length; i < n; i++)
				r.morphTargetDictionary[t[i]] = i;
		} else
			console.warn(
				'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.'
			);
	}
}
function V2(r) {
	const e = r.extensions && r.extensions[We.KHR_DRACO_MESH_COMPRESSION];
	let t;
	return (
		e
			? (t =
                  'draco:' +
                  e.bufferView +
                  ':' +
                  e.indices +
                  ':' +
                  Wp(e.attributes))
			: (t = r.indices + ':' + Wp(r.attributes) + ':' + r.mode),
		t
	);
}
function Wp(r) {
	let e = '';
	const t = Object.keys(r).sort();
	for (let i = 0, n = t.length; i < n; i++) e += t[i] + ':' + r[t[i]] + ';';
	return e;
}
function tu(r) {
	switch (r) {
	case Int8Array:
		return 1 / 127;
	case Uint8Array:
		return 1 / 255;
	case Int16Array:
		return 1 / 32767;
	case Uint16Array:
		return 1 / 65535;
	default:
		throw new Error(
			'THREE.GLTFLoader: Unsupported normalized accessor component type.'
		);
	}
}
function W2(r) {
	return r.search(/\.jpe?g($|\?)/i) > 0 ||
        r.search(/^data\:image\/jpeg/) === 0
		? 'image/jpeg'
		: r.search(/\.webp($|\?)/i) > 0 || r.search(/^data\:image\/webp/) === 0
			? 'image/webp'
			: 'image/png';
}
class j2 {
	constructor(e = {}, t = {}) {
		(this.json = e),
		(this.extensions = {}),
		(this.plugins = {}),
		(this.options = t),
		(this.cache = new b2()),
		(this.associations = new Map()),
		(this.primitiveCache = {}),
		(this.meshCache = { refs: {}, uses: {} }),
		(this.cameraCache = { refs: {}, uses: {} }),
		(this.lightCache = { refs: {}, uses: {} }),
		(this.sourceCache = {}),
		(this.textureCache = {}),
		(this.nodeNamesUsed = {}),
		typeof createImageBitmap != 'undefined' &&
            /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !1
			? (this.textureLoader = new Tg(this.options.manager))
			: (this.textureLoader = new xg(this.options.manager)),
		this.textureLoader.setCrossOrigin(this.options.crossOrigin),
		this.textureLoader.setRequestHeader(this.options.requestHeader),
		(this.fileLoader = new Yu(this.options.manager)),
		this.fileLoader.setResponseType('arraybuffer'),
		this.options.crossOrigin === 'use-credentials' &&
                this.fileLoader.setWithCredentials(!0);
	}
	setExtensions(e) {
		this.extensions = e;
	}
	setPlugins(e) {
		this.plugins = e;
	}
	parse(e, t) {
		const i = this,
			n = this.json,
			a = this.extensions;
		this.cache.removeAll(),
		this._invokeAll(function (s) {
			return s._markDefs && s._markDefs();
		}),
		Promise.all(
			this._invokeAll(function (s) {
				return s.beforeRoot && s.beforeRoot();
			})
		)
			.then(function () {
				return Promise.all([
					i.getDependencies('scene'),
					i.getDependencies('animation'),
					i.getDependencies('camera')
				]);
			})
			.then(function (s) {
				const o = {
					scene: s[0][n.scene || 0],
					scenes: s[0],
					animations: s[1],
					cameras: s[2],
					asset: n.asset,
					parser: i,
					userData: {}
				};
				Va(a, o, n),
				qi(o, n),
				Promise.all(
					i._invokeAll(function (l) {
						return l.afterRoot && l.afterRoot(o);
					})
				).then(function () {
					e(o);
				});
			})
			.catch(t);
	}
	_markDefs() {
		const e = this.json.nodes || [],
			t = this.json.skins || [],
			i = this.json.meshes || [];
		for (let n = 0, a = t.length; n < a; n++) {
			const s = t[n].joints;
			for (let o = 0, l = s.length; o < l; o++) e[s[o]].isBone = !0;
		}
		for (let n = 0, a = e.length; n < a; n++) {
			const s = e[n];
			s.mesh !== void 0 &&
                (this._addNodeRef(this.meshCache, s.mesh),
                s.skin !== void 0 && (i[s.mesh].isSkinnedMesh = !0)),
			s.camera !== void 0 &&
                    this._addNodeRef(this.cameraCache, s.camera);
		}
	}
	_addNodeRef(e, t) {
		t !== void 0 &&
            (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
	}
	_getNodeRef(e, t, i) {
		if (e.refs[t] <= 1) return i;
		const n = i.clone(),
			a = (s, o) => {
				const l = this.associations.get(s);
				l != null && this.associations.set(o, l);
				for (const [c, u] of s.children.entries()) a(u, o.children[c]);
			};
		return a(i, n), (n.name += '_instance_' + e.uses[t]++), n;
	}
	_invokeOne(e) {
		const t = Object.values(this.plugins);
		t.push(this);
		for (let i = 0; i < t.length; i++) {
			const n = e(t[i]);
			if (n) return n;
		}
		return null;
	}
	_invokeAll(e) {
		const t = Object.values(this.plugins);
		t.unshift(this);
		const i = [];
		for (let n = 0; n < t.length; n++) {
			const a = e(t[n]);
			a && i.push(a);
		}
		return i;
	}
	getDependency(e, t) {
		const i = e + ':' + t;
		let n = this.cache.get(i);
		if (!n) {
			switch (e) {
			case 'scene':
				n = this.loadScene(t);
				break;
			case 'node':
				n = this.loadNode(t);
				break;
			case 'mesh':
				n = this._invokeOne(function (a) {
					return a.loadMesh && a.loadMesh(t);
				});
				break;
			case 'accessor':
				n = this.loadAccessor(t);
				break;
			case 'bufferView':
				n = this._invokeOne(function (a) {
					return a.loadBufferView && a.loadBufferView(t);
				});
				break;
			case 'buffer':
				n = this.loadBuffer(t);
				break;
			case 'material':
				n = this._invokeOne(function (a) {
					return a.loadMaterial && a.loadMaterial(t);
				});
				break;
			case 'texture':
				n = this._invokeOne(function (a) {
					return a.loadTexture && a.loadTexture(t);
				});
				break;
			case 'skin':
				n = this.loadSkin(t);
				break;
			case 'animation':
				n = this.loadAnimation(t);
				break;
			case 'camera':
				n = this.loadCamera(t);
				break;
			default:
				throw new Error('Unknown type: ' + e);
			}
			this.cache.add(i, n);
		}
		return n;
	}
	getDependencies(e) {
		let t = this.cache.get(e);
		if (!t) {
			const i = this,
				n = this.json[e + (e === 'mesh' ? 'es' : 's')] || [];
			(t = Promise.all(
				n.map(function (a, s) {
					return i.getDependency(e, s);
				})
			)),
			this.cache.add(e, t);
		}
		return t;
	}
	loadBuffer(e) {
		const t = this.json.buffers[e],
			i = this.fileLoader;
		if (t.type && t.type !== 'arraybuffer')
			throw new Error(
				'THREE.GLTFLoader: ' + t.type + ' buffer type is not supported.'
			);
		if (t.uri === void 0 && e === 0)
			return Promise.resolve(this.extensions[We.KHR_BINARY_GLTF].body);
		const n = this.options;
		return new Promise(function (a, s) {
			i.load(Ri.resolveURL(t.uri, n.path), a, void 0, function () {
				s(
					new Error(
						'THREE.GLTFLoader: Failed to load buffer "' +
                            t.uri +
                            '".'
					)
				);
			});
		});
	}
	loadBufferView(e) {
		const t = this.json.bufferViews[e];
		return this.getDependency('buffer', t.buffer).then(function (i) {
			const n = t.byteLength || 0,
				a = t.byteOffset || 0;
			return i.slice(a, a + n);
		});
	}
	loadAccessor(e) {
		const t = this,
			i = this.json,
			n = this.json.accessors[e];
		if (n.bufferView === void 0 && n.sparse === void 0)
			return Promise.resolve(null);
		const a = [];
		return (
			n.bufferView !== void 0
				? a.push(this.getDependency('bufferView', n.bufferView))
				: a.push(null),
			n.sparse !== void 0 &&
                (a.push(
                	this.getDependency(
                		'bufferView',
                		n.sparse.indices.bufferView
                	)
                ),
                a.push(
                	this.getDependency('bufferView', n.sparse.values.bufferView)
                )),
			Promise.all(a).then(function (s) {
				const o = s[0],
					l = Vp[n.type],
					c = Ss[n.componentType],
					u = c.BYTES_PER_ELEMENT,
					h = u * l,
					d = n.byteOffset || 0,
					p =
                        n.bufferView !== void 0
                        	? i.bufferViews[n.bufferView].byteStride
                        	: void 0,
					g = n.normalized === !0;
				let m, f;
				if (p && p !== h) {
					const v = Math.floor(d / p),
						x =
                            'InterleavedBuffer:' +
                            n.bufferView +
                            ':' +
                            n.componentType +
                            ':' +
                            v +
                            ':' +
                            n.count;
					let A = t.cache.get(x);
					A ||
                        ((m = new c(o, v * p, (n.count * p) / u)),
                        (A = new Sa(m, p / u)),
                        t.cache.add(x, A)),
					(f = new ha(A, l, (d % p) / u, g));
				} else o === null ? (m = new c(n.count * l)) : (m = new c(o, d, n.count * l)), (f = new mt(m, l, g));
				if (n.sparse !== void 0) {
					const v = Vp.SCALAR,
						x = Ss[n.sparse.indices.componentType],
						A = n.sparse.indices.byteOffset || 0,
						S = n.sparse.values.byteOffset || 0,
						M = new x(s[1], A, n.sparse.count * v),
						I = new c(s[2], S, n.sparse.count * l);
					o !== null &&
                        (f = new mt(f.array.slice(), f.itemSize, f.normalized));
					for (let D = 0, G = M.length; D < G; D++) {
						const re = M[D];
						if (
							(f.setX(re, I[D * l]),
							l >= 2 && f.setY(re, I[D * l + 1]),
							l >= 3 && f.setZ(re, I[D * l + 2]),
							l >= 4 && f.setW(re, I[D * l + 3]),
							l >= 5)
						)
							throw new Error(
								'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.'
							);
					}
				}
				return f;
			})
		);
	}
	loadTexture(e) {
		const t = this.json,
			i = this.options,
			n = t.textures[e].source,
			a = t.images[n];
		let s = this.textureLoader;
		if (a.uri) {
			const o = i.manager.getHandler(a.uri);
			o !== null && (s = o);
		}
		return this.loadTextureImage(e, n, s);
	}
	loadTextureImage(e, t, i) {
		const n = this,
			a = this.json,
			s = a.textures[e],
			o = a.images[t],
			l = (o.uri || o.bufferView) + ':' + s.sampler;
		if (this.textureCache[l]) return this.textureCache[l];
		const c = this.loadImageSource(t, i)
			.then(function (u) {
				(u.flipY = !1), s.name && (u.name = s.name);
				const h = (a.samplers || {})[s.sampler] || {};
				return (
					(u.magFilter = Hp[h.magFilter] || Nt),
					(u.minFilter = Hp[h.minFilter] || ba),
					(u.wrapS = Gp[h.wrapS] || oa),
					(u.wrapT = Gp[h.wrapT] || oa),
					n.associations.set(u, { textures: e }),
					u
				);
			})
			.catch(function () {
				return null;
			});
		return (this.textureCache[l] = c), c;
	}
	loadImageSource(e, t) {
		const i = this,
			n = this.json,
			a = this.options;
		if (this.sourceCache[e] !== void 0)
			return this.sourceCache[e].then((h) => h.clone());
		const s = n.images[e],
			o = self.URL || self.webkitURL;
		let l = s.uri || '',
			c = !1;
		if (s.bufferView !== void 0)
			l = i.getDependency('bufferView', s.bufferView).then(function (h) {
				c = !0;
				const d = new Blob([h], { type: s.mimeType });
				return (l = o.createObjectURL(d)), l;
			});
		else if (s.uri === void 0)
			throw new Error(
				'THREE.GLTFLoader: Image ' +
                    e +
                    ' is missing URI and bufferView'
			);
		const u = Promise.resolve(l)
			.then(function (h) {
				return new Promise(function (d, p) {
					let g = d;
					t.isImageBitmapLoader === !0 &&
                        (g = function (m) {
                        	const f = new wt(m);
                        	(f.needsUpdate = !0), d(f);
                        }),
					t.load(Ri.resolveURL(h, a.path), g, void 0, p);
				});
			})
			.then(function (h) {
				return (
					c === !0 && o.revokeObjectURL(l),
					(h.userData.mimeType = s.mimeType || W2(s.uri)),
					h
				);
			})
			.catch(function (h) {
				throw (
					(console.error(
						'THREE.GLTFLoader: Couldn\'t load texture',
						l
					),
					h)
				);
			});
		return (this.sourceCache[e] = u), u;
	}
	assignTexture(e, t, i, n) {
		const a = this;
		return this.getDependency('texture', i.index).then(function (s) {
			if (
				(i.texCoord !== void 0 &&
                    i.texCoord != 0 &&
                    !(t === 'aoMap' && i.texCoord == 1) &&
                    console.warn(
                    	'THREE.GLTFLoader: Custom UV set ' +
                            i.texCoord +
                            ' for texture ' +
                            t +
                            ' not yet supported.'
                    ),
				a.extensions[We.KHR_TEXTURE_TRANSFORM])
			) {
				const o =
                    i.extensions !== void 0
                    	? i.extensions[We.KHR_TEXTURE_TRANSFORM]
                    	: void 0;
				if (o) {
					const l = a.associations.get(s);
					(s = a.extensions[We.KHR_TEXTURE_TRANSFORM].extendTexture(
						s,
						o
					)),
					a.associations.set(s, l);
				}
			}
			return n !== void 0 && (s.encoding = n), (e[t] = s), s;
		});
	}
	assignFinalMaterial(e) {
		const t = e.geometry;
		let i = e.material;
		const n = t.attributes.tangent === void 0,
			a = t.attributes.color !== void 0,
			s = t.attributes.normal === void 0;
		if (e.isPoints) {
			const o = 'PointsMaterial:' + i.uuid;
			let l = this.cache.get(o);
			l ||
                ((l = new ul()),
                dt.prototype.copy.call(l, i),
                l.color.copy(i.color),
                (l.map = i.map),
                (l.sizeAttenuation = !1),
                this.cache.add(o, l)),
			(i = l);
		} else if (e.isLine) {
			const o = 'LineBasicMaterial:' + i.uuid;
			let l = this.cache.get(o);
			l ||
                ((l = new Oi()),
                dt.prototype.copy.call(l, i),
                l.color.copy(i.color),
                this.cache.add(o, l)),
			(i = l);
		}
		if (n || a || s) {
			let o = 'ClonedMaterial:' + i.uuid + ':';
			i.isGLTFSpecularGlossinessMaterial && (o += 'specular-glossiness:'),
			n && (o += 'derivative-tangents:'),
			a && (o += 'vertex-colors:'),
			s && (o += 'flat-shading:');
			let l = this.cache.get(o);
			l ||
                ((l = i.clone()),
                a && (l.vertexColors = !0),
                s && (l.flatShading = !0),
                n &&
                    (l.normalScale && (l.normalScale.y *= -1),
                    l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
                this.cache.add(o, l),
                this.associations.set(l, this.associations.get(i))),
			(i = l);
		}
		i.aoMap &&
            t.attributes.uv2 === void 0 &&
            t.attributes.uv !== void 0 &&
            t.setAttribute('uv2', t.attributes.uv),
		(e.material = i);
	}
	getMaterialType() {
		return Ii;
	}
	loadMaterial(e) {
		const t = this,
			i = this.json,
			n = this.extensions,
			a = i.materials[e];
		let s;
		const o = {},
			l = a.extensions || {},
			c = [];
		if (l[We.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
			const h = n[We.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
			(s = h.getMaterialType()), c.push(h.extendParams(o, a, t));
		} else if (l[We.KHR_MATERIALS_UNLIT]) {
			const h = n[We.KHR_MATERIALS_UNLIT];
			(s = h.getMaterialType()), c.push(h.extendParams(o, a, t));
		} else {
			const h = a.pbrMetallicRoughness || {};
			if (
				((o.color = new ke(1, 1, 1)),
				(o.opacity = 1),
				Array.isArray(h.baseColorFactor))
			) {
				const d = h.baseColorFactor;
				o.color.fromArray(d), (o.opacity = d[3]);
			}
			h.baseColorTexture !== void 0 &&
                c.push(t.assignTexture(o, 'map', h.baseColorTexture, Ze)),
			(o.metalness =
                    h.metallicFactor !== void 0 ? h.metallicFactor : 1),
			(o.roughness =
                    h.roughnessFactor !== void 0 ? h.roughnessFactor : 1),
			h.metallicRoughnessTexture !== void 0 &&
                    (c.push(
                    	t.assignTexture(
                    		o,
                    		'metalnessMap',
                    		h.metallicRoughnessTexture
                    	)
                    ),
                    c.push(
                    	t.assignTexture(
                    		o,
                    		'roughnessMap',
                    		h.metallicRoughnessTexture
                    	)
                    )),
			(s = this._invokeOne(function (d) {
				return d.getMaterialType && d.getMaterialType(e);
			})),
			c.push(
				Promise.all(
					this._invokeAll(function (d) {
						return (
							d.extendMaterialParams &&
                                d.extendMaterialParams(e, o)
						);
					})
				)
			);
		}
		a.doubleSided === !0 && (o.side = an);
		const u = a.alphaMode || dc.OPAQUE;
		if (
			(u === dc.BLEND
				? ((o.transparent = !0), (o.depthWrite = !1))
				: ((o.transparent = !1),
				u === dc.MASK &&
                      (o.alphaTest =
                          a.alphaCutoff !== void 0 ? a.alphaCutoff : 0.5)),
			a.normalTexture !== void 0 &&
                s !== Cr &&
                (c.push(t.assignTexture(o, 'normalMap', a.normalTexture)),
                (o.normalScale = new me(1, 1)),
                a.normalTexture.scale !== void 0))
		) {
			const h = a.normalTexture.scale;
			o.normalScale.set(h, h);
		}
		return (
			a.occlusionTexture !== void 0 &&
                s !== Cr &&
                (c.push(t.assignTexture(o, 'aoMap', a.occlusionTexture)),
                a.occlusionTexture.strength !== void 0 &&
                    (o.aoMapIntensity = a.occlusionTexture.strength)),
			a.emissiveFactor !== void 0 &&
                s !== Cr &&
                (o.emissive = new ke().fromArray(a.emissiveFactor)),
			a.emissiveTexture !== void 0 &&
                s !== Cr &&
                c.push(
                	t.assignTexture(o, 'emissiveMap', a.emissiveTexture, Ze)
                ),
			Promise.all(c).then(function () {
				let h;
				return (
					s === Qc
						? (h =
                              n[
                              	We.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS
                              ].createMaterial(o))
						: (h = new s(o)),
					a.name && (h.name = a.name),
					qi(h, a),
					t.associations.set(h, { materials: e }),
					a.extensions && Va(n, h, a),
					h
				);
			})
		);
	}
	createUniqueName(e) {
		const t = et.sanitizeNodeName(e || '');
		let i = t;
		for (let n = 1; this.nodeNamesUsed[i]; ++n) i = t + '_' + n;
		return (this.nodeNamesUsed[i] = !0), i;
	}
	loadGeometries(e) {
		const t = this,
			i = this.extensions,
			n = this.primitiveCache;
		function a(o) {
			return i[We.KHR_DRACO_MESH_COMPRESSION]
				.decodePrimitive(o, t)
				.then(function (l) {
					return jp(l, o, t);
				});
		}
		const s = [];
		for (let o = 0, l = e.length; o < l; o++) {
			const c = e[o],
				u = V2(c),
				h = n[u];
			if (h) s.push(h.promise);
			else {
				let d;
				c.extensions && c.extensions[We.KHR_DRACO_MESH_COMPRESSION]
					? (d = a(c))
					: (d = jp(new ot(), c, t)),
				(n[u] = { primitive: c, promise: d }),
				s.push(d);
			}
		}
		return Promise.all(s);
	}
	loadMesh(e) {
		const t = this,
			i = this.json,
			n = this.extensions,
			a = i.meshes[e],
			s = a.primitives,
			o = [];
		for (let l = 0, c = s.length; l < c; l++) {
			const u =
                s[l].material === void 0
                	? F2(this.cache)
                	: this.getDependency('material', s[l].material);
			o.push(u);
		}
		return (
			o.push(t.loadGeometries(s)),
			Promise.all(o).then(function (l) {
				const c = l.slice(0, l.length - 1),
					u = l[l.length - 1],
					h = [];
				for (let p = 0, g = u.length; p < g; p++) {
					const m = u[p],
						f = s[p];
					let v;
					const x = c[p];
					if (
						f.mode === Wr.TRIANGLES ||
                        f.mode === Wr.TRIANGLE_STRIP ||
                        f.mode === Wr.TRIANGLE_FAN ||
                        f.mode === void 0
					)
						(v =
                            a.isSkinnedMesh === !0
                            	? new Fu(m, x)
                            	: new rt(m, x)),
						v.isSkinnedMesh === !0 &&
                                !v.geometry.attributes.skinWeight.normalized &&
                                v.normalizeSkinWeights(),
						f.mode === Wr.TRIANGLE_STRIP
							? (v.geometry = Xp(v.geometry, qx))
							: f.mode === Wr.TRIANGLE_FAN &&
                                  (v.geometry = Xp(v.geometry, kf));
					else if (f.mode === Wr.LINES) v = new cl(m, x);
					else if (f.mode === Wr.LINE_STRIP) v = new da(m, x);
					else if (f.mode === Wr.LINE_LOOP) v = new Jf(m, x);
					else if (f.mode === Wr.POINTS) v = new Qf(m, x);
					else
						throw new Error(
							'THREE.GLTFLoader: Primitive mode unsupported: ' +
                                f.mode
						);
					Object.keys(v.geometry.morphAttributes).length > 0 &&
                        G2(v, a),
					(v.name = t.createUniqueName(a.name || 'mesh_' + e)),
					qi(v, a),
					f.extensions && Va(n, v, f),
					t.assignFinalMaterial(v),
					h.push(v);
				}
				for (let p = 0, g = h.length; p < g; p++)
					t.associations.set(h[p], { meshes: e, primitives: p });
				if (h.length === 1) return h[0];
				const d = new _i();
				t.associations.set(d, { meshes: e });
				for (let p = 0, g = h.length; p < g; p++) d.add(h[p]);
				return d;
			})
		);
	}
	loadCamera(e) {
		let t;
		const i = this.json.cameras[e],
			n = i[i.type];
		if (!n) {
			console.warn('THREE.GLTFLoader: Missing camera parameters.');
			return;
		}
		return (
			i.type === 'perspective'
				? (t = new zt(
					pb.radToDeg(n.yfov),
					n.aspectRatio || 1,
					n.znear || 1,
					n.zfar || 2e6
				))
				: i.type === 'orthographic' &&
                  (t = new sl(
                  	-n.xmag,
                  	n.xmag,
                  	n.ymag,
                  	-n.ymag,
                  	n.znear,
                  	n.zfar
                  )),
			i.name && (t.name = this.createUniqueName(i.name)),
			qi(t, i),
			Promise.resolve(t)
		);
	}
	loadSkin(e) {
		const t = this.json.skins[e],
			i = { joints: t.joints };
		return t.inverseBindMatrices === void 0
			? Promise.resolve(i)
			: this.getDependency('accessor', t.inverseBindMatrices).then(
				function (n) {
					return (i.inverseBindMatrices = n), i;
				}
			);
	}
	loadAnimation(e) {
		const t = this.json.animations[e],
			i = [],
			n = [],
			a = [],
			s = [],
			o = [];
		for (let l = 0, c = t.channels.length; l < c; l++) {
			const u = t.channels[l],
				h = t.samplers[u.sampler],
				d = u.target,
				p = d.node !== void 0 ? d.node : d.id,
				g = t.parameters !== void 0 ? t.parameters[h.input] : h.input,
				m = t.parameters !== void 0 ? t.parameters[h.output] : h.output;
			i.push(this.getDependency('node', p)),
			n.push(this.getDependency('accessor', g)),
			a.push(this.getDependency('accessor', m)),
			s.push(h),
			o.push(d);
		}
		return Promise.all([
			Promise.all(i),
			Promise.all(n),
			Promise.all(a),
			Promise.all(s),
			Promise.all(o)
		]).then(function (l) {
			const c = l[0],
				u = l[1],
				h = l[2],
				d = l[3],
				p = l[4],
				g = [];
			for (let f = 0, v = c.length; f < v; f++) {
				const x = c[f],
					A = u[f],
					S = h[f],
					M = d[f],
					I = p[f];
				if (x === void 0) continue;
				x.updateMatrix(), (x.matrixAutoUpdate = !0);
				let D;
				switch (fi[I.path]) {
				case fi.weights:
					D = _s;
					break;
				case fi.rotation:
					D = on;
					break;
				case fi.position:
				case fi.scale:
				default:
					D = Ms;
					break;
				}
				const G = x.name ? x.name : x.uuid,
					re = M.interpolation !== void 0 ? B2[M.interpolation] : ca,
					B = [];
				fi[I.path] === fi.weights
					? x.traverse(function (E) {
						E.morphTargetInfluences &&
                              B.push(E.name ? E.name : E.uuid);
					})
					: B.push(G);
				let b = S.array;
				if (S.normalized) {
					const E = tu(b.constructor),
						j = new Float32Array(b.length);
					for (let z = 0, V = b.length; z < V; z++) j[z] = b[z] * E;
					b = j;
				}
				for (let E = 0, j = B.length; E < j; E++) {
					const z = new D(B[E] + '.' + fi[I.path], A.array, b, re);
					M.interpolation === 'CUBICSPLINE' &&
                        ((z.createInterpolant = function (V) {
                        	const H = this instanceof on ? U2 : ln;
                        	return new H(
                        		this.times,
                        		this.values,
                        		this.getValueSize() / 3,
                        		V
                        	);
                        }),
                        (z.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
                            !0)),
					g.push(z);
				}
			}
			const m = t.name ? t.name : 'animation_' + e;
			return new Jc(m, void 0, g);
		});
	}
	createNodeMesh(e) {
		const t = this.json,
			i = this,
			n = t.nodes[e];
		return n.mesh === void 0
			? null
			: i.getDependency('mesh', n.mesh).then(function (a) {
				const s = i._getNodeRef(i.meshCache, n.mesh, a);
				return (
					n.weights !== void 0 &&
                          s.traverse(function (o) {
                          	if (o.isMesh)
                          		for (
                          			let l = 0, c = n.weights.length;
                          			l < c;
                          			l++
                          		)
                          			o.morphTargetInfluences[l] = n.weights[l];
                          }),
					s
				);
			});
	}
	loadNode(e) {
		const t = this.json,
			i = this.extensions,
			n = this,
			a = t.nodes[e],
			s = a.name ? n.createUniqueName(a.name) : '';
		return (function () {
			const o = [],
				l = n._invokeOne(function (c) {
					return c.createNodeMesh && c.createNodeMesh(e);
				});
			return (
				l && o.push(l),
				a.camera !== void 0 &&
                    o.push(
                    	n.getDependency('camera', a.camera).then(function (c) {
                    		return n._getNodeRef(n.cameraCache, a.camera, c);
                    	})
                    ),
				n
					._invokeAll(function (c) {
						return (
							c.createNodeAttachment && c.createNodeAttachment(e)
						);
					})
					.forEach(function (c) {
						o.push(c);
					}),
				Promise.all(o)
			);
		})().then(function (o) {
			let l;
			if (
				(a.isBone === !0
					? (l = new Hu())
					: o.length > 1
						? (l = new _i())
						: o.length === 1
							? (l = o[0])
							: (l = new Je()),
				l !== o[0])
			)
				for (let c = 0, u = o.length; c < u; c++) l.add(o[c]);
			if (
				(a.name && ((l.userData.name = a.name), (l.name = s)),
				qi(l, a),
				a.extensions && Va(i, l, a),
				a.matrix !== void 0)
			) {
				const c = new Pe();
				c.fromArray(a.matrix), l.applyMatrix4(c);
			} else a.translation !== void 0 && l.position.fromArray(a.translation), a.rotation !== void 0 && l.quaternion.fromArray(a.rotation), a.scale !== void 0 && l.scale.fromArray(a.scale);
			return (
				n.associations.has(l) || n.associations.set(l, {}),
				(n.associations.get(l).nodes = e),
				l
			);
		});
	}
	loadScene(e) {
		const t = this.json,
			i = this.extensions,
			n = this.json.scenes[e],
			a = this,
			s = new _i();
		n.name && (s.name = a.createUniqueName(n.name)),
		qi(s, n),
		n.extensions && Va(i, s, n);
		const o = n.nodes || [],
			l = [];
		for (let c = 0, u = o.length; c < u; c++) l.push(kg(o[c], s, t, a));
		return Promise.all(l).then(function () {
			const c = (u) => {
				const h = new Map();
				for (const [d, p] of a.associations)
					(d instanceof dt || d instanceof wt) && h.set(d, p);
				return (
					u.traverse((d) => {
						const p = a.associations.get(d);
						p != null && h.set(d, p);
					}),
					h
				);
			};
			return (a.associations = c(s)), s;
		});
	}
}
function kg(r, e, t, i) {
	const n = t.nodes[r];
	return i
		.getDependency('node', r)
		.then(function (a) {
			if (n.skin === void 0) return a;
			let s;
			return i
				.getDependency('skin', n.skin)
				.then(function (o) {
					s = o;
					const l = [];
					for (let c = 0, u = s.joints.length; c < u; c++)
						l.push(i.getDependency('node', s.joints[c]));
					return Promise.all(l);
				})
				.then(function (o) {
					return (
						a.traverse(function (l) {
							if (!l.isMesh) return;
							const c = [],
								u = [];
							for (let h = 0, d = o.length; h < d; h++) {
								const p = o[h];
								if (p) {
									c.push(p);
									const g = new Pe();
									s.inverseBindMatrices !== void 0 &&
                                        g.fromArray(
                                        	s.inverseBindMatrices.array,
                                        	h * 16
                                        ),
									u.push(g);
								} else
									console.warn(
										'THREE.GLTFLoader: Joint "%s" could not be found.',
										s.joints[h]
									);
							}
							l.bind(new Gu(c, u), l.matrixWorld);
						}),
						a
					);
				});
		})
		.then(function (a) {
			e.add(a);
			const s = [];
			if (n.children) {
				const o = n.children;
				for (let l = 0, c = o.length; l < c; l++) {
					const u = o[l];
					s.push(kg(u, a, t, i));
				}
			}
			return Promise.all(s);
		});
}
function X2(r, e, t) {
	const i = e.attributes,
		n = new or();
	if (i.POSITION !== void 0) {
		const o = t.json.accessors[i.POSITION],
			l = o.min,
			c = o.max;
		if (l !== void 0 && c !== void 0) {
			if (
				(n.set(new C(l[0], l[1], l[2]), new C(c[0], c[1], c[2])),
				o.normalized)
			) {
				const u = tu(Ss[o.componentType]);
				n.min.multiplyScalar(u), n.max.multiplyScalar(u);
			}
		} else {
			console.warn(
				'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.'
			);
			return;
		}
	} else return;
	const a = e.targets;
	if (a !== void 0) {
		const o = new C(),
			l = new C();
		for (let c = 0, u = a.length; c < u; c++) {
			const h = a[c];
			if (h.POSITION !== void 0) {
				const d = t.json.accessors[h.POSITION],
					p = d.min,
					g = d.max;
				if (p !== void 0 && g !== void 0) {
					if (
						(l.setX(Math.max(Math.abs(p[0]), Math.abs(g[0]))),
						l.setY(Math.max(Math.abs(p[1]), Math.abs(g[1]))),
						l.setZ(Math.max(Math.abs(p[2]), Math.abs(g[2]))),
						d.normalized)
					) {
						const m = tu(Ss[d.componentType]);
						l.multiplyScalar(m);
					}
					o.max(l);
				} else
					console.warn(
						'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.'
					);
			}
		}
		n.expandByVector(o);
	}
	r.boundingBox = n;
	const s = new dn();
	n.getCenter(s.center),
	(s.radius = n.min.distanceTo(n.max) / 2),
	(r.boundingSphere = s);
}
function jp(r, e, t) {
	const i = e.attributes,
		n = [];
	function a(s, o) {
		return t.getDependency('accessor', s).then(function (l) {
			r.setAttribute(o, l);
		});
	}
	for (const s in i) {
		const o = eu[s] || s.toLowerCase();
		o in r.attributes || n.push(a(i[s], o));
	}
	if (e.indices !== void 0 && !r.index) {
		const s = t.getDependency('accessor', e.indices).then(function (o) {
			r.setIndex(o);
		});
		n.push(s);
	}
	return (
		qi(r, e),
		X2(r, e, t),
		Promise.all(n).then(function () {
			return e.targets !== void 0 ? H2(r, e.targets, t) : r;
		})
	);
}
function Xp(r, e) {
	let t = r.getIndex();
	if (t === null) {
		const s = [],
			o = r.getAttribute('position');
		if (o !== void 0) {
			for (let l = 0; l < o.count; l++) s.push(l);
			r.setIndex(s), (t = r.getIndex());
		} else
			return (
				console.error(
					'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.'
				),
				r
			);
	}
	const i = t.count - 2,
		n = [];
	if (e === kf)
		for (let s = 1; s <= i; s++)
			n.push(t.getX(0)), n.push(t.getX(s)), n.push(t.getX(s + 1));
	else
		for (let s = 0; s < i; s++)
			s % 2 === 0
				? (n.push(t.getX(s)),
				n.push(t.getX(s + 1)),
				n.push(t.getX(s + 2)))
				: (n.push(t.getX(s + 2)),
				n.push(t.getX(s + 1)),
				n.push(t.getX(s)));
	n.length / 3 !== i &&
        console.error(
        	'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.'
        );
	const a = r.clone();
	return a.setIndex(n), a;
}
class q2 extends ll {
	constructor() {
		super();
		const e = new _a();
		e.deleteAttribute('uv');
		const t = new Ii({ side: rr }),
			i = new Ii(),
			n = new $u(16777215, 5, 28, 2);
		n.position.set(0.418, 16.199, 0.3), this.add(n);
		const a = new rt(e, t);
		a.position.set(-0.757, 13.219, 0.717),
		a.scale.set(31.713, 28.305, 28.591),
		this.add(a);
		const s = new rt(e, i);
		s.position.set(-10.906, 2.009, 1.846),
		s.rotation.set(0, -0.195, 0),
		s.scale.set(2.328, 7.905, 4.651),
		this.add(s);
		const o = new rt(e, i);
		o.position.set(-5.607, -0.754, -0.758),
		o.rotation.set(0, 0.994, 0),
		o.scale.set(1.97, 1.534, 3.955),
		this.add(o);
		const l = new rt(e, i);
		l.position.set(6.167, 0.857, 7.803),
		l.rotation.set(0, 0.561, 0),
		l.scale.set(3.927, 6.285, 3.687),
		this.add(l);
		const c = new rt(e, i);
		c.position.set(-2.017, 0.018, 6.124),
		c.rotation.set(0, 0.333, 0),
		c.scale.set(2.002, 4.566, 2.064),
		this.add(c);
		const u = new rt(e, i);
		u.position.set(2.291, -0.756, -2.621),
		u.rotation.set(0, -0.286, 0),
		u.scale.set(1.546, 1.552, 1.496),
		this.add(u);
		const h = new rt(e, i);
		h.position.set(-2.193, -0.369, -5.547),
		h.rotation.set(0, 0.516, 0),
		h.scale.set(3.875, 3.487, 2.986),
		this.add(h);
		const d = new rt(e, Un(50));
		d.position.set(-16.116, 14.37, 8.208),
		d.scale.set(0.1, 2.428, 2.739),
		this.add(d);
		const p = new rt(e, Un(50));
		p.position.set(-16.109, 18.021, -8.207),
		p.scale.set(0.1, 2.425, 2.751),
		this.add(p);
		const g = new rt(e, Un(17));
		g.position.set(14.904, 12.198, -1.832),
		g.scale.set(0.15, 4.265, 6.331),
		this.add(g);
		const m = new rt(e, Un(43));
		m.position.set(-0.462, 8.89, 14.52),
		m.scale.set(4.38, 5.441, 0.088),
		this.add(m);
		const f = new rt(e, Un(20));
		f.position.set(3.235, 11.486, -12.541),
		f.scale.set(2.5, 2, 0.1),
		this.add(f);
		const v = new rt(e, Un(100));
		v.position.set(0, 20, 0), v.scale.set(1, 0.1, 1), this.add(v);
	}
}
function Un(r) {
	const e = new Cr();
	return e.color.setScalar(r), e;
}
var Yt = (r, e) => {
	const t = r.__vccOpts || r;
	for (const [i, n] of e) t[i] = n;
	return t;
};
const Y2 = {
		props: { paddingValue: { type: Number, default: 0 } },
		data() {
			return { hasUnintendedBehaviors: !1 };
		},
		mounted() {
			let r = window.innerWidth > 1148;
			const e = (u) => (u ? 5 : 3),
				t = new zt(75, 2, 0.1, 1e3);
			(t.position.x = 30),
			(t.position.y = 20),
			(t.position.z = 30),
			new x2().load(
				' ./web/source/laptop.glb',
				function (u) {
					const h = u.scene;
					h.position.set(0, 0, 6),
					h.scale.set(e(r), e(r), e(r)),
					(h.castShadow = !0),
					s.add(h);
				},
				void 0,
				function (u) {
					this.$router.push('notfound');
				}
			);
			const i = document.getElementById('threejs-container'),
				n = new tt({ antialias: !0 });
			n.setPixelRatio(window.devicePixelRatio),
			(n.outputEncoding = Ze),
			n.setSize(450, 450 / 2),
			(n.shadowMap.enabled = !0),
			(n.shadowMap.type = Mf),
			i.appendChild(n.domElement),
			n.setClearColor(0, 0);
			const a = new jc(n),
				s = new ll();
			s.environment = a.fromScene(new q2(), 1).texture;
			const o = new Ku(4210752, 1);
			o.position.set(15, 20, 0),
			o.target.position.set(0, 0, 0),
			(o.castShadow = !0),
			(o.shadow.mapSize.width = 512),
			(o.shadow.mapSize.height = 512),
			s.add(o),
			s.add(o.target);
			const l = new y2(t, n.domElement);
			(l.enableDamping = !0),
			(l.maxPolarAngle = Math.PI / 2 - 0.3),
			(l.minDistance = 10),
			(l.maxDistance = 50),
			(l.enableRotate = !0),
			(l.rotateSpeed = 0.3),
			(l.autoRotate = !0),
			(l.autoRotateSpeed = 1.5),
			new Ag(200, 50),
			new g2(o, 5);
			const c = () => {
				requestAnimationFrame(c);
				const u = window.innerWidth / 2,
					h = window.innerHeight / 2;
				(t.aspect = window.innerWidth / window.innerHeight),
				t.updateProjectionMatrix(),
				n.setSize(u, h),
				l.update(),
				n.render(s, t);
			};
			c();
		}
	},
	Z2 = { class: 'divCenter pt-20' };
function $2(r, e, t, i, n, a) {
	return (
		Ce(),
		Oe('div', Z2, [
			ee(
				'div',
				{
					id: 'threejs-container',
					class: '',
					style: cn(
						r.windowWidth < 1280
							? null
							: {
								'padding-left': t.paddingValue - 50 + 'px',
								'padding-right': t.paddingValue - 50 + 'px'
							}
					)
				},
				null,
				4
			)
		])
	);
}
var K2 = Yt(Y2, [
		['render', $2],
		['__scopeId', 'data-v-36c9c18d']
	]),
	Cg = {
		update: null,
		begin: null,
		loopBegin: null,
		changeBegin: null,
		change: null,
		changeComplete: null,
		loopComplete: null,
		complete: null,
		loop: 1,
		direction: 'normal',
		autoplay: !0,
		timelineOffset: 0
	},
	th = {
		duration: 1e3,
		delay: 0,
		endDelay: 0,
		easing: 'easeOutElastic(1, .5)',
		round: 0
	},
	J2 = [
		'translateX',
		'translateY',
		'translateZ',
		'rotate',
		'rotateX',
		'rotateY',
		'rotateZ',
		'scale',
		'scaleX',
		'scaleY',
		'scaleZ',
		'skew',
		'skewX',
		'skewY',
		'perspective',
		'matrix',
		'matrix3d'
	],
	Bo = { CSS: {}, springs: {} };
function Pr(r, e, t) {
	return Math.min(Math.max(r, e), t);
}
function ns(r, e) {
	return r.indexOf(e) > -1;
}
function pc(r, e) {
	return r.apply(null, e);
}
var Ie = {
	arr: function (r) {
		return Array.isArray(r);
	},
	obj: function (r) {
		return ns(Object.prototype.toString.call(r), 'Object');
	},
	pth: function (r) {
		return Ie.obj(r) && r.hasOwnProperty('totalLength');
	},
	svg: function (r) {
		return r instanceof SVGElement;
	},
	inp: function (r) {
		return r instanceof HTMLInputElement;
	},
	dom: function (r) {
		return r.nodeType || Ie.svg(r);
	},
	str: function (r) {
		return typeof r == 'string';
	},
	fnc: function (r) {
		return typeof r == 'function';
	},
	und: function (r) {
		return typeof r == 'undefined';
	},
	nil: function (r) {
		return Ie.und(r) || r === null;
	},
	hex: function (r) {
		return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(r);
	},
	rgb: function (r) {
		return /^rgb/.test(r);
	},
	hsl: function (r) {
		return /^hsl/.test(r);
	},
	col: function (r) {
		return Ie.hex(r) || Ie.rgb(r) || Ie.hsl(r);
	},
	key: function (r) {
		return (
			!Cg.hasOwnProperty(r) &&
            !th.hasOwnProperty(r) &&
            r !== 'targets' &&
            r !== 'keyframes'
		);
	}
};
function Pg(r) {
	var e = /\(([^)]+)\)/.exec(r);
	return e
		? e[1].split(',').map(function (t) {
			return parseFloat(t);
		})
		: [];
}
function Ig(r, e) {
	var t = Pg(r),
		i = Pr(Ie.und(t[0]) ? 1 : t[0], 0.1, 100),
		n = Pr(Ie.und(t[1]) ? 100 : t[1], 0.1, 100),
		a = Pr(Ie.und(t[2]) ? 10 : t[2], 0.1, 100),
		s = Pr(Ie.und(t[3]) ? 0 : t[3], 0.1, 100),
		o = Math.sqrt(n / i),
		l = a / (2 * Math.sqrt(n * i)),
		c = l < 1 ? o * Math.sqrt(1 - l * l) : 0,
		u = 1,
		h = l < 1 ? (l * o + -s) / c : -s + o;
	function d(g) {
		var m = e ? (e * g) / 1e3 : g;
		return (
			l < 1
				? (m =
                      Math.exp(-m * l * o) *
                      (u * Math.cos(c * m) + h * Math.sin(c * m)))
				: (m = (u + h * m) * Math.exp(-m * o)),
			g === 0 || g === 1 ? g : 1 - m
		);
	}
	function p() {
		var g = Bo.springs[r];
		if (g) return g;
		for (var m = 1 / 6, f = 0, v = 0; ; )
			if (((f += m), d(f) === 1)) {
				if ((v++, v >= 16)) break;
			} else v = 0;
		var x = f * m * 1e3;
		return (Bo.springs[r] = x), x;
	}
	return e ? d : p;
}
function Q2(r) {
	return (
		r === void 0 && (r = 10),
		function (e) {
			return Math.ceil(Pr(e, 1e-6, 1) * r) * (1 / r);
		}
	);
}
var e3 = (function () {
		var r = 11,
			e = 1 / (r - 1);
		function t(u, h) {
			return 1 - 3 * h + 3 * u;
		}
		function i(u, h) {
			return 3 * h - 6 * u;
		}
		function n(u) {
			return 3 * u;
		}
		function a(u, h, d) {
			return ((t(h, d) * u + i(h, d)) * u + n(h)) * u;
		}
		function s(u, h, d) {
			return 3 * t(h, d) * u * u + 2 * i(h, d) * u + n(h);
		}
		function o(u, h, d, p, g) {
			var m,
				f,
				v = 0;
			do
				(f = h + (d - h) / 2),
				(m = a(f, p, g) - u),
				m > 0 ? (d = f) : (h = f);
			while (Math.abs(m) > 1e-7 && ++v < 10);
			return f;
		}
		function l(u, h, d, p) {
			for (var g = 0; g < 4; ++g) {
				var m = s(h, d, p);
				if (m === 0) return h;
				var f = a(h, d, p) - u;
				h -= f / m;
			}
			return h;
		}
		function c(u, h, d, p) {
			if (!(0 <= u && u <= 1 && 0 <= d && d <= 1)) return;
			var g = new Float32Array(r);
			if (u !== h || d !== p)
				for (var m = 0; m < r; ++m) g[m] = a(m * e, u, d);
			function f(v) {
				for (var x = 0, A = 1, S = r - 1; A !== S && g[A] <= v; ++A)
					x += e;
				--A;
				var M = (v - g[A]) / (g[A + 1] - g[A]),
					I = x + M * e,
					D = s(I, u, d);
				return D >= 0.001
					? l(v, I, u, d)
					: D === 0
						? I
						: o(v, x, x + e, u, d);
			}
			return function (v) {
				return (u === h && d === p) || v === 0 || v === 1
					? v
					: a(f(v), h, p);
			};
		}
		return c;
	})(),
	Dg = (function () {
		var r = {
				linear: function () {
					return function (i) {
						return i;
					};
				}
			},
			e = {
				Sine: function () {
					return function (i) {
						return 1 - Math.cos((i * Math.PI) / 2);
					};
				},
				Circ: function () {
					return function (i) {
						return 1 - Math.sqrt(1 - i * i);
					};
				},
				Back: function () {
					return function (i) {
						return i * i * (3 * i - 2);
					};
				},
				Bounce: function () {
					return function (i) {
						for (
							var n, a = 4;
							i < ((n = Math.pow(2, --a)) - 1) / 11;

						);
						return (
							1 / Math.pow(4, 3 - a) -
                            7.5625 * Math.pow((n * 3 - 2) / 22 - i, 2)
						);
					};
				},
				Elastic: function (i, n) {
					i === void 0 && (i = 1), n === void 0 && (n = 0.5);
					var a = Pr(i, 1, 10),
						s = Pr(n, 0.1, 2);
					return function (o) {
						return o === 0 || o === 1
							? o
							: -a *
                                  Math.pow(2, 10 * (o - 1)) *
                                  Math.sin(
                                  	((o -
                                          1 -
                                          (s / (Math.PI * 2)) *
                                              Math.asin(1 / a)) *
                                          (Math.PI * 2)) /
                                          s
                                  );
					};
				}
			},
			t = ['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'];
		return (
			t.forEach(function (i, n) {
				e[i] = function () {
					return function (a) {
						return Math.pow(a, n + 2);
					};
				};
			}),
			Object.keys(e).forEach(function (i) {
				var n = e[i];
				(r['easeIn' + i] = n),
				(r['easeOut' + i] = function (a, s) {
					return function (o) {
						return 1 - n(a, s)(1 - o);
					};
				}),
				(r['easeInOut' + i] = function (a, s) {
					return function (o) {
						return o < 0.5
							? n(a, s)(o * 2) / 2
							: 1 - n(a, s)(o * -2 + 2) / 2;
					};
				}),
				(r['easeOutIn' + i] = function (a, s) {
					return function (o) {
						return o < 0.5
							? (1 - n(a, s)(1 - o * 2)) / 2
							: (n(a, s)(o * 2 - 1) + 1) / 2;
					};
				});
			}),
			r
		);
	})();
function rh(r, e) {
	if (Ie.fnc(r)) return r;
	var t = r.split('(')[0],
		i = Dg[t],
		n = Pg(r);
	switch (t) {
	case 'spring':
		return Ig(r, e);
	case 'cubicBezier':
		return pc(e3, n);
	case 'steps':
		return pc(Q2, n);
	default:
		return pc(i, n);
	}
}
function Og(r) {
	try {
		var e = document.querySelectorAll(r);
		return e;
	} catch {
		return;
	}
}
function ml(r, e) {
	for (
		var t = r.length,
			i = arguments.length >= 2 ? arguments[1] : void 0,
			n = [],
			a = 0;
		a < t;
		a++
	)
		if (a in r) {
			var s = r[a];
			e.call(i, s, a, r) && n.push(s);
		}
	return n;
}
function fl(r) {
	return r.reduce(function (e, t) {
		return e.concat(Ie.arr(t) ? fl(t) : t);
	}, []);
}
function qp(r) {
	return Ie.arr(r)
		? r
		: (Ie.str(r) && (r = Og(r) || r),
		r instanceof NodeList || r instanceof HTMLCollection
			? [].slice.call(r)
			: [r]);
}
function ih(r, e) {
	return r.some(function (t) {
		return t === e;
	});
}
function nh(r) {
	var e = {};
	for (var t in r) e[t] = r[t];
	return e;
}
function ru(r, e) {
	var t = nh(r);
	for (var i in r) t[i] = e.hasOwnProperty(i) ? e[i] : r[i];
	return t;
}
function gl(r, e) {
	var t = nh(r);
	for (var i in e) t[i] = Ie.und(r[i]) ? e[i] : r[i];
	return t;
}
function t3(r) {
	var e = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(r);
	return e ? 'rgba(' + e[1] + ',1)' : r;
}
function r3(r) {
	var e = /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
		t = r.replace(e, function (o, l, c, u) {
			return l + l + c + c + u + u;
		}),
		i = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t),
		n = parseInt(i[1], 16),
		a = parseInt(i[2], 16),
		s = parseInt(i[3], 16);
	return 'rgba(' + n + ',' + a + ',' + s + ',1)';
}
function i3(r) {
	var e =
            /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(r) ||
            /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(r),
		t = parseInt(e[1], 10) / 360,
		i = parseInt(e[2], 10) / 100,
		n = parseInt(e[3], 10) / 100,
		a = e[4] || 1;
	function s(d, p, g) {
		return (
			g < 0 && (g += 1),
			g > 1 && (g -= 1),
			g < 1 / 6
				? d + (p - d) * 6 * g
				: g < 1 / 2
					? p
					: g < 2 / 3
						? d + (p - d) * (2 / 3 - g) * 6
						: d
		);
	}
	var o, l, c;
	if (i == 0) o = l = c = n;
	else {
		var u = n < 0.5 ? n * (1 + i) : n + i - n * i,
			h = 2 * n - u;
		(o = s(h, u, t + 1 / 3)), (l = s(h, u, t)), (c = s(h, u, t - 1 / 3));
	}
	return 'rgba(' + o * 255 + ',' + l * 255 + ',' + c * 255 + ',' + a + ')';
}
function n3(r) {
	if (Ie.rgb(r)) return t3(r);
	if (Ie.hex(r)) return r3(r);
	if (Ie.hsl(r)) return i3(r);
}
function Kr(r) {
	var e =
        /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(
        	r
        );
	if (e) return e[1];
}
function a3(r) {
	if (ns(r, 'translate') || r === 'perspective') return 'px';
	if (ns(r, 'rotate') || ns(r, 'skew')) return 'deg';
}
function iu(r, e) {
	return Ie.fnc(r) ? r(e.target, e.id, e.total) : r;
}
function Ir(r, e) {
	return r.getAttribute(e);
}
function ah(r, e, t) {
	var i = Kr(e);
	if (ih([t, 'deg', 'rad', 'turn'], i)) return e;
	var n = Bo.CSS[e + t];
	if (!Ie.und(n)) return n;
	var a = 100,
		s = document.createElement(r.tagName),
		o =
            r.parentNode && r.parentNode !== document
            	? r.parentNode
            	: document.body;
	o.appendChild(s), (s.style.position = 'absolute'), (s.style.width = a + t);
	var l = a / s.offsetWidth;
	o.removeChild(s);
	var c = l * parseFloat(e);
	return (Bo.CSS[e + t] = c), c;
}
function Ng(r, e, t) {
	if (e in r.style) {
		var i = e.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase(),
			n = r.style[e] || getComputedStyle(r).getPropertyValue(i) || '0';
		return t ? ah(r, n, t) : n;
	}
}
function sh(r, e) {
	if (Ie.dom(r) && !Ie.inp(r) && (!Ie.nil(Ir(r, e)) || (Ie.svg(r) && r[e])))
		return 'attribute';
	if (Ie.dom(r) && ih(J2, e)) return 'transform';
	if (Ie.dom(r) && e !== 'transform' && Ng(r, e)) return 'css';
	if (r[e] != null) return 'object';
}
function zg(r) {
	if (Ie.dom(r)) {
		for (
			var e = r.style.transform || '',
				t = /(\w+)\(([^)]*)\)/g,
				i = new Map(),
				n;
			(n = t.exec(e));

		)
			i.set(n[1], n[2]);
		return i;
	}
}
function s3(r, e, t, i) {
	var n = ns(e, 'scale') ? 1 : 0 + a3(e),
		a = zg(r).get(e) || n;
	return (
		t && (t.transforms.list.set(e, a), (t.transforms.last = e)),
		i ? ah(r, a, i) : a
	);
}
function oh(r, e, t, i) {
	switch (sh(r, e)) {
	case 'transform':
		return s3(r, e, i, t);
	case 'css':
		return Ng(r, e, t);
	case 'attribute':
		return Ir(r, e);
	default:
		return r[e] || 0;
	}
}
function lh(r, e) {
	var t = /^(\*=|\+=|-=)/.exec(r);
	if (!t) return r;
	var i = Kr(r) || 0,
		n = parseFloat(e),
		a = parseFloat(r.replace(t[0], ''));
	switch (t[0][0]) {
	case '+':
		return n + a + i;
	case '-':
		return n - a + i;
	case '*':
		return n * a + i;
	}
}
function Ug(r, e) {
	if (Ie.col(r)) return n3(r);
	if (/\s/g.test(r)) return r;
	var t = Kr(r),
		i = t ? r.substr(0, r.length - t.length) : r;
	return e ? i + e : i;
}
function ch(r, e) {
	return Math.sqrt(Math.pow(e.x - r.x, 2) + Math.pow(e.y - r.y, 2));
}
function o3(r) {
	return Math.PI * 2 * Ir(r, 'r');
}
function l3(r) {
	return Ir(r, 'width') * 2 + Ir(r, 'height') * 2;
}
function c3(r) {
	return ch(
		{ x: Ir(r, 'x1'), y: Ir(r, 'y1') },
		{ x: Ir(r, 'x2'), y: Ir(r, 'y2') }
	);
}
function Bg(r) {
	for (var e = r.points, t = 0, i, n = 0; n < e.numberOfItems; n++) {
		var a = e.getItem(n);
		n > 0 && (t += ch(i, a)), (i = a);
	}
	return t;
}
function u3(r) {
	var e = r.points;
	return Bg(r) + ch(e.getItem(e.numberOfItems - 1), e.getItem(0));
}
function Fg(r) {
	if (r.getTotalLength) return r.getTotalLength();
	switch (r.tagName.toLowerCase()) {
	case 'circle':
		return o3(r);
	case 'rect':
		return l3(r);
	case 'line':
		return c3(r);
	case 'polyline':
		return Bg(r);
	case 'polygon':
		return u3(r);
	}
}
function h3(r) {
	var e = Fg(r);
	return r.setAttribute('stroke-dasharray', e), e;
}
function d3(r) {
	for (var e = r.parentNode; Ie.svg(e) && Ie.svg(e.parentNode); )
		e = e.parentNode;
	return e;
}
function Hg(r, e) {
	var t = e || {},
		i = t.el || d3(r),
		n = i.getBoundingClientRect(),
		a = Ir(i, 'viewBox'),
		s = n.width,
		o = n.height,
		l = t.viewBox || (a ? a.split(' ') : [0, 0, s, o]);
	return {
		el: i,
		viewBox: l,
		x: l[0] / 1,
		y: l[1] / 1,
		w: s,
		h: o,
		vW: l[2],
		vH: l[3]
	};
}
function p3(r, e) {
	var t = Ie.str(r) ? Og(r)[0] : r,
		i = e || 100;
	return function (n) {
		return {
			property: n,
			el: t,
			svg: Hg(t),
			totalLength: Fg(t) * (i / 100)
		};
	};
}
function m3(r, e, t) {
	function i(u) {
		u === void 0 && (u = 0);
		var h = e + u >= 1 ? e + u : 0;
		return r.el.getPointAtLength(h);
	}
	var n = Hg(r.el, r.svg),
		a = i(),
		s = i(-1),
		o = i(1),
		l = t ? 1 : n.w / n.vW,
		c = t ? 1 : n.h / n.vH;
	switch (r.property) {
	case 'x':
		return (a.x - n.x) * l;
	case 'y':
		return (a.y - n.y) * c;
	case 'angle':
		return (Math.atan2(o.y - s.y, o.x - s.x) * 180) / Math.PI;
	}
}
function Yp(r, e) {
	var t = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g,
		i = Ug(Ie.pth(r) ? r.totalLength : r, e) + '';
	return {
		original: i,
		numbers: i.match(t) ? i.match(t).map(Number) : [0],
		strings: Ie.str(r) || e ? i.split(t) : []
	};
}
function uh(r) {
	var e = r ? fl(Ie.arr(r) ? r.map(qp) : qp(r)) : [];
	return ml(e, function (t, i, n) {
		return n.indexOf(t) === i;
	});
}
function Gg(r) {
	var e = uh(r);
	return e.map(function (t, i) {
		return {
			target: t,
			id: i,
			total: e.length,
			transforms: { list: zg(t) }
		};
	});
}
function f3(r, e) {
	var t = nh(e);
	if ((/^spring/.test(t.easing) && (t.duration = Ig(t.easing)), Ie.arr(r))) {
		var i = r.length,
			n = i === 2 && !Ie.obj(r[0]);
		n
			? (r = { value: r })
			: Ie.fnc(e.duration) || (t.duration = e.duration / i);
	}
	var a = Ie.arr(r) ? r : [r];
	return a
		.map(function (s, o) {
			var l = Ie.obj(s) && !Ie.pth(s) ? s : { value: s };
			return (
				Ie.und(l.delay) && (l.delay = o ? 0 : e.delay),
				Ie.und(l.endDelay) &&
                    (l.endDelay = o === a.length - 1 ? e.endDelay : 0),
				l
			);
		})
		.map(function (s) {
			return gl(s, t);
		});
}
function g3(r) {
	for (
		var e = ml(
				fl(
					r.map(function (a) {
						return Object.keys(a);
					})
				),
				function (a) {
					return Ie.key(a);
				}
			).reduce(function (a, s) {
				return a.indexOf(s) < 0 && a.push(s), a;
			}, []),
			t = {},
			i = function (a) {
				var s = e[a];
				t[s] = r.map(function (o) {
					var l = {};
					for (var c in o)
						Ie.key(c) ? c == s && (l.value = o[c]) : (l[c] = o[c]);
					return l;
				});
			},
			n = 0;
		n < e.length;
		n++
	)
		i(n);
	return t;
}
function v3(r, e) {
	var t = [],
		i = e.keyframes;
	i && (e = gl(g3(i), e));
	for (var n in e) Ie.key(n) && t.push({ name: n, tweens: f3(e[n], r) });
	return t;
}
function y3(r, e) {
	var t = {};
	for (var i in r) {
		var n = iu(r[i], e);
		Ie.arr(n) &&
            ((n = n.map(function (a) {
            	return iu(a, e);
            })),
            n.length === 1 && (n = n[0])),
		(t[i] = n);
	}
	return (
		(t.duration = parseFloat(t.duration)),
		(t.delay = parseFloat(t.delay)),
		t
	);
}
function x3(r, e) {
	var t;
	return r.tweens.map(function (i) {
		var n = y3(i, e),
			a = n.value,
			s = Ie.arr(a) ? a[1] : a,
			o = Kr(s),
			l = oh(e.target, r.name, o, e),
			c = t ? t.to.original : l,
			u = Ie.arr(a) ? a[0] : c,
			h = Kr(u) || Kr(l),
			d = o || h;
		return (
			Ie.und(s) && (s = c),
			(n.from = Yp(u, d)),
			(n.to = Yp(lh(s, u), d)),
			(n.start = t ? t.end : 0),
			(n.end = n.start + n.delay + n.duration + n.endDelay),
			(n.easing = rh(n.easing, n.duration)),
			(n.isPath = Ie.pth(a)),
			(n.isPathTargetInsideSVG = n.isPath && Ie.svg(e.target)),
			(n.isColor = Ie.col(n.from.original)),
			n.isColor && (n.round = 1),
			(t = n),
			n
		);
	});
}
var Vg = {
	css: function (r, e, t) {
		return (r.style[e] = t);
	},
	attribute: function (r, e, t) {
		return r.setAttribute(e, t);
	},
	object: function (r, e, t) {
		return (r[e] = t);
	},
	transform: function (r, e, t, i, n) {
		if ((i.list.set(e, t), e === i.last || n)) {
			var a = '';
			i.list.forEach(function (s, o) {
				a += o + '(' + s + ') ';
			}),
			(r.style.transform = a);
		}
	}
};
function Wg(r, e) {
	var t = Gg(r);
	t.forEach(function (i) {
		for (var n in e) {
			var a = iu(e[n], i),
				s = i.target,
				o = Kr(a),
				l = oh(s, n, o, i),
				c = o || Kr(l),
				u = lh(Ug(a, c), l),
				h = sh(s, n);
			Vg[h](s, n, u, i.transforms, !0);
		}
	});
}
function b3(r, e) {
	var t = sh(r.target, e.name);
	if (t) {
		var i = x3(e, r),
			n = i[i.length - 1];
		return {
			type: t,
			property: e.name,
			animatable: r,
			tweens: i,
			duration: n.end,
			delay: i[0].delay,
			endDelay: n.endDelay
		};
	}
}
function w3(r, e) {
	return ml(
		fl(
			r.map(function (t) {
				return e.map(function (i) {
					return b3(t, i);
				});
			})
		),
		function (t) {
			return !Ie.und(t);
		}
	);
}
function jg(r, e) {
	var t = r.length,
		i = function (a) {
			return a.timelineOffset ? a.timelineOffset : 0;
		},
		n = {};
	return (
		(n.duration = t
			? Math.max.apply(
				Math,
				r.map(function (a) {
					return i(a) + a.duration;
				})
			)
			: e.duration),
		(n.delay = t
			? Math.min.apply(
				Math,
				r.map(function (a) {
					return i(a) + a.delay;
				})
			)
			: e.delay),
		(n.endDelay = t
			? n.duration -
              Math.max.apply(
              	Math,
              	r.map(function (a) {
              		return i(a) + a.duration - a.endDelay;
              	})
              )
			: e.endDelay),
		n
	);
}
var Zp = 0;
function _3(r) {
	var e = ru(Cg, r),
		t = ru(th, r),
		i = v3(t, r),
		n = Gg(r.targets),
		a = w3(n, i),
		s = jg(a, t),
		o = Zp;
	return (
		Zp++,
		gl(e, {
			id: o,
			children: [],
			animatables: n,
			animations: a,
			duration: s.duration,
			delay: s.delay,
			endDelay: s.endDelay
		})
	);
}
var fr = [],
	Xg = (function () {
		var r;
		function e() {
			!r &&
                (!$p() || !pt.suspendWhenDocumentHidden) &&
                fr.length > 0 &&
                (r = requestAnimationFrame(t));
		}
		function t(n) {
			for (var a = fr.length, s = 0; s < a; ) {
				var o = fr[s];
				o.paused ? (fr.splice(s, 1), a--) : (o.tick(n), s++);
			}
			r = s > 0 ? requestAnimationFrame(t) : void 0;
		}
		function i() {
			!pt.suspendWhenDocumentHidden ||
                ($p()
                	? (r = cancelAnimationFrame(r))
                	: (fr.forEach(function (n) {
                		return n._onDocumentVisibility();
                	}),
                	Xg()));
		}
		return (
			typeof document != 'undefined' &&
                document.addEventListener('visibilitychange', i),
			e
		);
	})();
function $p() {
	return !!document && document.hidden;
}
function pt(r) {
	r === void 0 && (r = {});
	var e = 0,
		t = 0,
		i = 0,
		n,
		a = 0,
		s = null;
	function o(x) {
		var A =
            window.Promise &&
            new Promise(function (S) {
            	return (s = S);
            });
		return (x.finished = A), A;
	}
	var l = _3(r);
	o(l);
	function c() {
		var x = l.direction;
		x !== 'alternate' &&
            (l.direction = x !== 'normal' ? 'normal' : 'reverse'),
		(l.reversed = !l.reversed),
		n.forEach(function (A) {
			return (A.reversed = l.reversed);
		});
	}
	function u(x) {
		return l.reversed ? l.duration - x : x;
	}
	function h() {
		(e = 0), (t = u(l.currentTime) * (1 / pt.speed));
	}
	function d(x, A) {
		A && A.seek(x - A.timelineOffset);
	}
	function p(x) {
		if (l.reversePlayback) for (var A = a; A--; ) d(x, n[A]);
		else for (var S = 0; S < a; S++) d(x, n[S]);
	}
	function g(x) {
		for (var A = 0, S = l.animations, M = S.length; A < M; ) {
			var I = S[A],
				D = I.animatable,
				G = I.tweens,
				re = G.length - 1,
				B = G[re];
			re &&
                (B =
                    ml(G, function (U) {
                    	return x < U.end;
                    })[0] || B);
			for (
				var b = Pr(x - B.start - B.delay, 0, B.duration) / B.duration,
					E = isNaN(b) ? 1 : B.easing(b),
					j = B.to.strings,
					z = B.round,
					V = [],
					H = B.to.numbers.length,
					k = void 0,
					P = 0;
				P < H;
				P++
			) {
				var Z = void 0,
					J = B.to.numbers[P],
					fe = B.from.numbers[P] || 0;
				B.isPath
					? (Z = m3(B.value, E * J, B.isPathTargetInsideSVG))
					: (Z = fe + E * (J - fe)),
				z && ((B.isColor && P > 2) || (Z = Math.round(Z * z) / z)),
				V.push(Z);
			}
			var ce = j.length;
			if (!ce) k = V[0];
			else {
				k = j[0];
				for (var xe = 0; xe < ce; xe++) {
					j[xe];
					var W = j[xe + 1],
						ue = V[xe];
					isNaN(ue) || (W ? (k += ue + W) : (k += ue + ' '));
				}
			}
			Vg[I.type](D.target, I.property, k, D.transforms),
			(I.currentValue = k),
			A++;
		}
	}
	function m(x) {
		l[x] && !l.passThrough && l[x](l);
	}
	function f() {
		l.remaining && l.remaining !== !0 && l.remaining--;
	}
	function v(x) {
		var A = l.duration,
			S = l.delay,
			M = A - l.endDelay,
			I = u(x);
		(l.progress = Pr((I / A) * 100, 0, 100)),
		(l.reversePlayback = I < l.currentTime),
		n && p(I),
		!l.began && l.currentTime > 0 && ((l.began = !0), m('begin')),
		!l.loopBegan &&
                l.currentTime > 0 &&
                ((l.loopBegan = !0), m('loopBegin')),
		I <= S && l.currentTime !== 0 && g(0),
		((I >= M && l.currentTime !== A) || !A) && g(A),
		I > S && I < M
			? (l.changeBegan ||
                      ((l.changeBegan = !0),
                      (l.changeCompleted = !1),
                      m('changeBegin')),
			m('change'),
			g(I))
			: l.changeBegan &&
                  ((l.changeCompleted = !0),
                  (l.changeBegan = !1),
                  m('changeComplete')),
		(l.currentTime = Pr(I, 0, A)),
		l.began && m('update'),
		x >= A &&
                ((t = 0),
                f(),
                l.remaining
                	? ((e = i),
                	m('loopComplete'),
                	(l.loopBegan = !1),
                	l.direction === 'alternate' && c())
                	: ((l.paused = !0),
                	l.completed ||
                          ((l.completed = !0),
                          m('loopComplete'),
                          m('complete'),
                          !l.passThrough &&
                              'Promise' in window &&
                              (s(), o(l)))));
	}
	return (
		(l.reset = function () {
			var x = l.direction;
			(l.passThrough = !1),
			(l.currentTime = 0),
			(l.progress = 0),
			(l.paused = !0),
			(l.began = !1),
			(l.loopBegan = !1),
			(l.changeBegan = !1),
			(l.completed = !1),
			(l.changeCompleted = !1),
			(l.reversePlayback = !1),
			(l.reversed = x === 'reverse'),
			(l.remaining = l.loop),
			(n = l.children),
			(a = n.length);
			for (var A = a; A--; ) l.children[A].reset();
			((l.reversed && l.loop !== !0) ||
                (x === 'alternate' && l.loop === 1)) &&
                l.remaining++,
			g(l.reversed ? l.duration : 0);
		}),
		(l._onDocumentVisibility = h),
		(l.set = function (x, A) {
			return Wg(x, A), l;
		}),
		(l.tick = function (x) {
			(i = x), e || (e = i), v((i + (t - e)) * pt.speed);
		}),
		(l.seek = function (x) {
			v(u(x));
		}),
		(l.pause = function () {
			(l.paused = !0), h();
		}),
		(l.play = function () {
			!l.paused ||
                (l.completed && l.reset(),
                (l.paused = !1),
                fr.push(l),
                h(),
                Xg());
		}),
		(l.reverse = function () {
			c(), (l.completed = !l.reversed), h();
		}),
		(l.restart = function () {
			l.reset(), l.play();
		}),
		(l.remove = function (x) {
			var A = uh(x);
			qg(A, l);
		}),
		l.reset(),
		l.autoplay && l.play(),
		l
	);
}
function Kp(r, e) {
	for (var t = e.length; t--; )
		ih(r, e[t].animatable.target) && e.splice(t, 1);
}
function qg(r, e) {
	var t = e.animations,
		i = e.children;
	Kp(r, t);
	for (var n = i.length; n--; ) {
		var a = i[n],
			s = a.animations;
		Kp(r, s), !s.length && !a.children.length && i.splice(n, 1);
	}
	!t.length && !i.length && e.pause();
}
function M3(r) {
	for (var e = uh(r), t = fr.length; t--; ) {
		var i = fr[t];
		qg(e, i);
	}
}
function S3(r, e) {
	e === void 0 && (e = {});
	var t = e.direction || 'normal',
		i = e.easing ? rh(e.easing) : null,
		n = e.grid,
		a = e.axis,
		s = e.from || 0,
		o = s === 'first',
		l = s === 'center',
		c = s === 'last',
		u = Ie.arr(r),
		h = parseFloat(u ? r[0] : r),
		d = u ? parseFloat(r[1]) : 0,
		p = Kr(u ? r[1] : r) || 0,
		g = e.start || 0 + (u ? h : 0),
		m = [],
		f = 0;
	return function (v, x, A) {
		if (
			(o && (s = 0), l && (s = (A - 1) / 2), c && (s = A - 1), !m.length)
		) {
			for (var S = 0; S < A; S++) {
				if (!n) m.push(Math.abs(s - S));
				else {
					var M = l ? (n[0] - 1) / 2 : s % n[0],
						I = l ? (n[1] - 1) / 2 : Math.floor(s / n[0]),
						D = S % n[0],
						G = Math.floor(S / n[0]),
						re = M - D,
						B = I - G,
						b = Math.sqrt(re * re + B * B);
					a === 'x' && (b = -re), a === 'y' && (b = -B), m.push(b);
				}
				f = Math.max.apply(Math, m);
			}
			i &&
                (m = m.map(function (j) {
                	return i(j / f) * f;
                })),
			t === 'reverse' &&
                    (m = m.map(function (j) {
                    	return a ? (j < 0 ? j * -1 : -j) : Math.abs(f - j);
                    }));
		}
		var E = u ? (d - h) / f : h;
		return g + E * (Math.round(m[x] * 100) / 100) + p;
	};
}
function T3(r) {
	r === void 0 && (r = {});
	var e = pt(r);
	return (
		(e.duration = 0),
		(e.add = function (t, i) {
			var n = fr.indexOf(e),
				a = e.children;
			n > -1 && fr.splice(n, 1);
			function s(d) {
				d.passThrough = !0;
			}
			for (var o = 0; o < a.length; o++) s(a[o]);
			var l = gl(t, ru(th, r));
			l.targets = l.targets || r.targets;
			var c = e.duration;
			(l.autoplay = !1),
			(l.direction = e.direction),
			(l.timelineOffset = Ie.und(i) ? c : lh(i, c)),
			s(e),
			e.seek(l.timelineOffset);
			var u = pt(l);
			s(u), a.push(u);
			var h = jg(a, r);
			return (
				(e.delay = h.delay),
				(e.endDelay = h.endDelay),
				(e.duration = h.duration),
				e.seek(0),
				e.reset(),
				e.autoplay && e.play(),
				e
			);
		}),
		e
	);
}
pt.version = '3.2.1';
pt.speed = 1;
pt.suspendWhenDocumentHidden = !0;
pt.running = fr;
pt.remove = M3;
pt.get = oh;
pt.set = Wg;
pt.convertPx = ah;
pt.path = p3;
pt.setDashoffset = h3;
pt.stagger = S3;
pt.timeline = T3;
pt.easing = rh;
pt.penner = Dg;
pt.random = function (r, e) {
	return Math.floor(Math.random() * (e - r + 1)) + r;
};
var Yg = [
	{
		Name: 'Light',
		DomID: 'Light',
		ColorScheme: {
			bg: '#d8fdf7',
			bgSelector: '#b1fbef99',
			svgColor:
                'invert(6%) sepia(27%) saturate(6747%) hue-rotate(203deg)',
			text: '#011936',
			tiCursorColor: '#011936',
			textHighlight: '#073642',
			textHighlightAlt: '#e278c4'
		},
		themeType: 'light'
	},
	{
		Name: 'Dark',
		DomID: 'Dark',
		ColorScheme: {
			bg: '#232323',
			bgSelector: '#2d2d2dee',
			svgColor:
                'invert(100%) sepia(0%) saturate(7482%) hue-rotate(149deg) brightness(101%) contrast(100%)',
			text: '#FFFFFF',
			tiCursorColor: '#FFFFFF',
			textHighlight: '#b1fbef',
			textHighlightAlt: '#e278c4'
		},
		themeType: 'dark'
	},
	{
		Name: 'Starfall',
		DomID: 'Starfall',
		ColorScheme: {
			bg: '#1b2636',
			bgSelector: '#214d63ee',
			svgColor:
                'invert(100%) sepia(0%) saturate(7482%) hue-rotate(149deg) brightness(101%) contrast(100%)',
			text: '#cacde2',
			tiCursorColor: '#cacde2',
			textHighlight: '#e278c4',
			textHighlightAlt: '#8de8b0'
		},
		themeType: 'dark'
	},
	{
		Name: 'Mocha',
		DomID: 'CatMocha',
		ColorScheme: {
			bg: '#1e1e2e',
			bgSelector: '#43465a99',
			svgColor:
                'invert(100%) sepia(0%) saturate(7482%) hue-rotate(149deg) brightness(101%) contrast(100%)',
			text: '#c6d0f5',
			tiCursorColor: '#c6d0f5',
			textHighlight: '#a6e3a1',
			textHighlightAlt: '#cba6f7'
		},
		themeType: 'dark'
	},
	{
		Name: 'Latte',
		DomID: 'CatLatte',
		ColorScheme: {
			bg: '#eff1f5',
			bgSelector: '#ccd0da99',
			svgColor:
                'invert(6%) sepia(27%) saturate(6747%) hue-rotate(203deg)',
			text: '#4c4f69',
			tiCursorColor: '#4c4f69',
			textHighlight: '#fe640b',
			textHighlightAlt: '#7287fd'
		},
		themeType: 'light'
	},
	{
		Name: 'Frappe',
		DomID: 'CatFrappe',
		ColorScheme: {
			bg: '#303446',
			bgSelector: '#41455999',
			svgColor:
                'invert(100%) sepia(0%) saturate(7482%) hue-rotate(149deg) brightness(101%) contrast(100%)',
			text: '#c6ceef',
			tiCursorColor: '#c6ceef',
			textHighlight: '#e78284',
			textHighlightAlt: '#a6d189'
		},
		themeType: 'dark'
	},
	{
		Name: 'Macchiato',
		DomID: 'CatMacchiato',
		ColorScheme: {
			bg: '#24273a',
			bgSelector: '#363a4f99',
			svgColor:
                'invert(100%) sepia(0%) saturate(7482%) hue-rotate(149deg) brightness(101%) contrast(100%)',
			text: '#c5cff5',
			tiCursorColor: '#c5cff5',
			textHighlight: '#8aadf4',
			textHighlightAlt: '#ed8796'
		},
		themeType: 'dark'
	}
];
const E3 = {
		class: 'lg:inline-grid lg:grid-cols-3 lg:gap-x-8 inline-grid grid-cols-1 w-full justify-center'
	},
	A3 = ['onClick', 'onMouseenter'],
	L3 = { class: '' },
	R3 = {
		name: 'MainThemeCardComponent',
		setup(r) {
			bf((l) => ({
				'5f31ef3a': i.value.bg,
				'3e364d62': i.value.bgSelector,
				'0122ccfd': i.value.svgColor,
				'52ceb1cb': i.value.text,
				'18fd251a': i.value.tiCursorColor,
				'7d8661ae': i.value.textHighlight,
				'437075c0': i.value.textHighlightAlt
			}));
			const e = Yg,
				t = document.body,
				i = lt({}),
				n = lt(''),
				a = lt(document.body.classList[0]),
				s = (l) => {
					const { ColorScheme: c } = l;
					i.value = {
						bg: c.bg,
						bgSelector: c.bgSelector,
						svgColor: c.svgColor,
						text: c.text,
						tiCursorColor: c.tiCursorColor,
						textHighlight: c.textHighlight,
						textHighlightAlt: c.textHighlightAlt
					};
				},
				o = (l) => {
					(t.className = ''),
					t.setAttribute('style', n.value.attributes.style.value),
					t.classList.add('palette'),
					(a.value = l.Name),
					localStorage.setItem('themePreference', l.themeType);
				};
			return (l, c) => (
				Ce(),
				Oe(
					'div',
					{
						class: 'flex items-center justify-between',
						ref_key: 'preview',
						ref: n
					},
					[
						ee('div', E3, [
							(Ce(!0),
							Oe(
								gt,
								null,
								Zr(
									Qn(e),
									(u) => (
										Ce(),
										Oe(
											'div',
											{
												class: 'div-center theme-selector-card-component rounded-lg px-2 py-2 text-center my-3 mx-3',
												onClick: (h) => o(u),
												onMouseenter: (h) => s(u),
												onMouseleave:
                                                    c[0] ||
                                                    (c[0] = (...h) =>
                                                    	l.revertTheme &&
                                                        l.revertTheme(...h)),
												key: u.DomId,
												style: cn(
													a.value !== u.Name
														? {
															backgroundColor:
                                                                  u.ColorScheme
                                                                  	.bg,
															color: u
																.ColorScheme
																.textHighlight
														}
														: {
															backgroundColor:
                                                                  u.ColorScheme
                                                                  	.bgSelector,
															color: u
																.ColorScheme
																.textHighlight,
															fontWeight: 700
														}
												)
											},
											[ee('p', L3, vr(u.Name), 1)],
											44,
											A3
										)
									)
								),
								128
							))
						])
					],
					512
				)
			);
		}
	},
	k3 = {
		class: 'flex items-start justify-center min-h-screen pt-24 text-center',
		ref: 'container'
	},
	C3 = {
		class: 'overlay-bg acrlyic rounded-lg text-left overflow-hidden shadow-xl w-10/12 sm:w-1/2 overflow-y-auto'
	},
	P3 = {
		name: 'MainThemeSelector',
		props: { isShowingThemeOverlay: { type: Boolean, default: !1 } },
		emits: ['closeOverlay'],
		setup(r, { emit: e }) {
			const t = (i) => {
				i.target.classList.contains('min-h-screen') &&
                    e('closeOverlay');
			};
			return (i, n) => (
				Ce(),
				en(pf, { to: 'body' }, [
					Ge(
						xa,
						{
							'enter-active-class':
                                'transition ease-out duration-200 transform',
							'enter-from-class': 'opacity-0',
							'enter-to-class': 'opacity-100',
							'leave-active-class':
                                'transition ease-in duration-200 transform',
							'leave-from-class': 'opacity-100',
							'leave-to-class': 'opacity-0'
						},
						{
							default: tr(() => [
								Yr(
									ee(
										'div',
										{
											class: nr([
												'top-0 fixed z-50 w-full bg-black bg-opacity-50 h-full overflow-auto',
												r.isShowingThemeOverlay
													? ''
													: 'overflow-auto '
											]),
											onClick:
                                                n[0] ||
                                                (n[0] = Lu(
                                                	(a) => t(a),
                                                	['stop', 'prevent']
                                                ))
										},
										[
											ee(
												'div',
												k3,
												[ee('div', C3, [Ge(R3)])],
												512
											)
										],
										2
									),
									[[ps, r.isShowingThemeOverlay]]
								)
							]),
							_: 1
						}
					)
				])
			);
		}
	},
	I3 = {
		props: { selectedIcon: { type: String, required: !1, default: null } },
		components: { MainThemeSelector: P3 },
		setup(r) {
			const e = './assets/theme.svg',
				t = lt(!1);
			return {
				svgSource: e,
				toggleThemeOverlay: () => {
					t.value = !t.value;
				},
				isShowingThemeOverlay: t,
				closeThemeOverlay: () => {
					t.value = !1;
				}
			};
		}
	},
	D3 = { key: 0 },
	O3 = ['src'],
	N3 = { key: 1 },
	z3 = Qo(
		'<button class=""><div class="border-2 rounded-md p-[0.48rem] svg_border -mt-[1px]"><div class="h-[0.15rem] w-[1.5rem] navbar_burger"></div><div class="h-[0.15rem] w-[1.5rem] navbar_burger mt-2"></div><div class="h-[0.15rem] w-[1.5rem] navbar_burger mt-2"></div></div></button>',
		1
	),
	U3 = [z3],
	B3 = { key: 2 },
	F3 = ee(
		'button',
		{
			class: 'border-2 rounded-md p-[0.35rem] svg_border',
			onclick:
                'window.open(\'https://github.com/Kuon-dev/kuon-portfolio/tree/main\');'
		},
		[
			ee('img', {
				src: 'https://cdn.jsdelivr.net/gh/devicons/devicon/icons/github/github-original.svg',
				class: 'svgColor inline min-w-[25px] min-h-[25px]',
				width: '20px',
				height: '20px'
			})
		],
		-1
	),
	H3 = [F3],
	G3 = { key: 3 },
	V3 = { key: 4 };
function W3(r, e, t, i, n, a) {
	const s = yr('MainThemeSelector');
	return (
		Ce(),
		Oe('div', null, [
			t.selectedIcon === 'themeSelector'
				? (Ce(),
				Oe('div', D3, [
					ee(
						'button',
						{
							class: 'border-2 rounded-md p-[0.35rem] svg_border',
							onClick:
                                  e[0] ||
                                  (e[0] = (...o) =>
                                  	i.toggleThemeOverlay &&
                                      i.toggleThemeOverlay(...o))
						},
						[
							ee(
								'img',
								{
									src: i.svgSource,
									class: 'svgColor inline min-w-[25px] min-h-[25px]',
									width: '20px',
									height: '20px'
								},
								null,
								8,
								O3
							)
						]
					)
				]))
				: t.selectedIcon === 'burgerMenu'
					? (Ce(), Oe('div', N3, U3))
					: t.selectedIcon === 'gitSource'
						? (Ce(), Oe('div', B3, H3))
						: (Ce(), Oe('div', G3)),
			t.selectedIcon === 'themeSelector'
				? (Ce(),
				Oe('div', V3, [
					Ge(
						s,
						{
							'is-showing-theme-overlay':
                                  i.isShowingThemeOverlay,
							onCloseOverlay: i.closeThemeOverlay
						},
						null,
						8,
						['is-showing-theme-overlay', 'onCloseOverlay']
					)
				]))
				: Ot('', !0)
		])
	);
}
var j3 = Yt(I3, [['render', W3]]);
const X3 = {
		class: 'flex items-start justify-end h-full text-center closeable-wrapper'
	},
	q3 = {
		class: 'overlay-bg acrlyic text-left overflow-hidden shadow-xl md:w-1/3 w-2/3 h-full overflow-y-auto',
		style: { 'border-radius': '0px' }
	},
	Y3 = { class: 'pb-8' },
	Z3 = {
		name: 'NavbarMobileComponent',
		props: {
			isShowingNavbarOverlay: { type: Boolean, default: !1 },
			navbarItems: { type: Array, default: null }
		},
		emits: ['closeOverlay'],
		setup(r, { emit: e }) {
			const t = (i) => {
				i.target.classList.contains('closeable-wrapper') &&
                    e('closeOverlay'),
				i.target.classList.contains('closeable-wrapper-sidebar') &&
                        setTimeout(() => e('closeOverlay'), 300);
			};
			return (i, n) => {
				const a = yr('router-link');
				return (
					Ce(),
					en(pf, { to: 'body' }, [
						Ge(
							xa,
							{
								'enter-active-class':
                                    'animate__animated animate__slideInRight animate__fast',
								'leave-active-class':
                                    'animate__animated animate__slideOutRight animate__fast'
							},
							{
								default: tr(() => [
									Yr(
										ee(
											'div',
											{
												class: nr([
													'top-0 fixed z-50 w-full h-full overflow-auto',
													r.isShowingNavbarOverlay
														? ''
														: 'overflow-auto '
												]),
												onClick:
                                                    n[2] ||
                                                    (n[2] = Lu(
                                                    	(s) => t(s),
                                                    	['stop', 'prevent']
                                                    ))
											},
											[
												ee('div', X3, [
													ee('ul', q3, [
														ee('li', Y3, [
															ee(
																'button',
																{
																	class: 'right-0 ml-auto float-right closeable-wrapper select-none',
																	onClick:
                                                                        n[0] ||
                                                                        (n[0] =
                                                                            (
                                                                            	s
                                                                            ) =>
                                                                            	t(
                                                                            		s
                                                                            	))
																},
																' X '
															)
														]),
														(Ce(!0),
														Oe(
															gt,
															null,
															Zr(
																r.navbarItems,
																(s) => (
																	Ce(),
																	Oe(
																		'li',
																		{
																			key: s.route,
																			class: 'text-3xl font-bold sm:-ml-[0px] text-center py-3',
																			onClick:
                                                                                n[1] ||
                                                                                (n[1] =
                                                                                    (
                                                                                    	o
                                                                                    ) =>
                                                                                    	t(
                                                                                    		o
                                                                                    	))
																		},
																		[
																			Ge(
																				a,
																				{
																					to: s.route,
																					class: 'scroll-smooth closeable-wrapper-sidebar'
																				},
																				{
																					default:
                                                                                        tr(
                                                                                        	() => [
                                                                                        		ar(
                                                                                        			vr(
                                                                                        				s.title
                                                                                        			),
                                                                                        			1
                                                                                        		)
                                                                                        	]
                                                                                        ),
																					_: 2
																				},
																				1032,
																				[
																					'to'
																				]
																			)
																		]
																	)
																)
															),
															128
														))
													])
												])
											],
											2
										),
										[[ps, r.isShowingNavbarOverlay]]
									)
								]),
								_: 1
							}
						)
					])
				);
			};
		}
	},
	$3 = {
		components: { NavbarIcons: j3, MobileNavbarComponent: Z3 },
		data() {
			return { windowWidth: window.innerWidth };
		},
		setup(r) {
			const e = {
					contact: { title: 'Contact', route: '/contact' },
					skills: { title: 'Skills', route: '/skills' },
					works: { title: 'Works', route: '/work' }
				},
				t = lt(!1);
			return {
				webRoutes: e,
				mobileDropdownNavigation: t,
				showDropdownNavigation: () => {
					t.value = !0;
				},
				hideDropdownNavigation: () => {
					t.value = !1;
				},
				scrollTop: () => {
					(document.body.scrollTop = 0),
					(document.documentElement.scrollTop = 0);
				}
			};
		},
		emits: ['updateWindowSize'],
		mounted() {
			this.onResize(),
			this.$nextTick(() => {
				window.addEventListener('resize', this.onResize);
			});
		},
		beforeDestroy() {
			window.removeEventListener('resize', this.onResize);
		},
		methods: {
			onResize() {
				(this.windowWidth = window.innerWidth),
				this.$emit('updateWindowSize', this.windowWidth);
			}
		}
	},
	K3 = (r) => (qm('data-v-0a9888da'), (r = r()), Ym(), r),
	J3 = { class: 'pt-2 navbar fixed w-full divCenter' },
	Q3 = { class: '2xl:flex flex-row py-3 px-3 hidden ml-20' },
	eT = { class: 'text-4xl font-bold headers' },
	tT = ar('Aaron'),
	rT = { class: 'text-2xl inline-block px-10 pt-[0.4rem]' },
	iT = { class: 'flex flex-row' },
	nT = K3(() => ee('div', null, [ee('div', { class: 'w-[30rem]' })], -1)),
	aT = { class: 'rightSide flex flex-row gap-4' },
	sT = { class: '2xl:hidden flex flex-row py-3 items-center' },
	oT = { class: 'text-3xl font-bold sm:-ml-[0px]' },
	lT = ar(' Aaron '),
	cT = { class: 'rightSide flex flex-row gap-4' },
	uT = { key: 0, class: 'has-dpdn' },
	hT = { key: 1, class: 'has-dpdn' },
	dT = { class: 'has-dpdn' };
function pT(r, e, t, i, n, a) {
	const s = yr('router-link'),
		o = yr('NavbarIcons'),
		l = yr('MobileNavbarComponent');
	return (
		Ce(),
		Oe('section', J3, [
			ee('div', Q3, [
				ee('div', null, [
					ee('h1', eT, [
						Ge(
							s,
							{ to: '/', onClick: i.scrollTop },
							{ default: tr(() => [tT]), _: 1 },
							8,
							['onClick']
						)
					])
				]),
				ee('div', rT, [
					ee('ul', iT, [
						(Ce(!0),
						Oe(
							gt,
							null,
							Zr(
								i.webRoutes,
								(c, u) => (
									Ce(),
									Oe(
										'li',
										{ class: 'px-3 flex flex-row', key: u },
										[
											ee('button', null, [
												Ge(
													s,
													{
														to: c.route,
														onClick: i.scrollTop
													},
													{
														default: tr(() => [
															ar(vr(c.title), 1)
														]),
														_: 2
													},
													1032,
													['to', 'onClick']
												)
											])
										]
									)
								)
							),
							128
						))
					])
				]),
				nT,
				ee('div', aT, [
					Ge(o, { 'selected-icon': 'themeSelector' }),
					Ge(o, { 'selected-icon': 'gitSource' })
				])
			]),
			ee('div', sT, [
				ee('div', null, [
					ee('h1', oT, [
						Ge(
							s,
							{
								to: '/',
								onClick: i.scrollTop,
								class: 'scroll-smooth'
							},
							{ default: tr(() => [lT]), _: 1 },
							8,
							['onClick']
						)
					])
				]),
				ee('div', null, [
					ee(
						'div',
						{
							style: cn(
								n.windowWidth > 400
									? { width: n.windowWidth / 3 + 'px' }
									: { width: n.windowWidth / 8 + 'px' }
							)
						},
						null,
						4
					)
				]),
				ee('div', cT, [
					n.windowWidth <= 1536
						? (Ce(),
						Oe('div', uT, [
							Ge(o, { 'selected-icon': 'themeSelector' })
						]))
						: Ot('', !0),
					n.windowWidth <= 1536
						? (Ce(),
						Oe('div', hT, [
							Ge(o, { 'selected-icon': 'gitSource' })
						]))
						: Ot('', !0),
					ee('div', dT, [
						Ge(
							o,
							{
								'selected-icon': 'burgerMenu',
								onClick: i.showDropdownNavigation
							},
							null,
							8,
							['onClick']
						),
						Ge(
							l,
							{
								'is-showing-navbar-overlay':
                                    i.mobileDropdownNavigation,
								'navbar-items': i.webRoutes,
								onCloseOverlay: i.hideDropdownNavigation
							},
							null,
							8,
							[
								'is-showing-navbar-overlay',
								'navbar-items',
								'onCloseOverlay'
							]
						)
					])
				])
			])
		])
	);
}
var mT = Yt($3, [
	['render', pT],
	['__scopeId', 'data-v-0a9888da']
]);
const fT = {
		emits: ['apply-theme'],
		methods: {
			setApplyTheme() {
				this.$emit('apply-theme', !0);
			}
		},
		mounted() {
			setTimeout(() => {
				pt({
					targets: '.loading-view',
					easing: 'easeInOutQuad',
					duration: 1500,
					width: '100%'
				}),
				setTimeout(() => {
					this.setApplyTheme();
				}, 2e3);
			}, 500);
		}
	},
	gT = { class: 'pt-32 div-center w-full overflow-hidden animate-pulse' },
	vT = ee(
		'div',
		{ class: 'w-96' },
		[
			ee('p', { class: 'text-2xl mt-2 ml-5' }, 'loading...'),
			ee(
				'div',
				{ class: 'w-full mt-2 border-2 rounded-lg loading-container' },
				[ee('div', { class: 'loading-view h-5 w-1 rounded-md' })]
			)
		],
		-1
	),
	yT = [vT];
function xT(r, e, t, i, n, a) {
	return Ce(), Oe('div', gT, yT);
}
var bT = Yt(fT, [['render', xT]]);
const wT = {
		setup() {
			const r = lt(!1);
			return (
				(r.value = !1),
				setTimeout(() => {
					r.value = !0;
				}, 1200),
				{ isLoadingRendered: r }
			);
		}
	},
	_T = { class: 'animate-pulse mt-48 px-10 sm:px-20' },
	MT = { key: 0 },
	ST = ee(
		'section',
		{ class: 'flex flex-col gap-4 w-full' },
		[
			ee('div', { class: 'sm:w-48 w-32 h-6 mb-6 skeleton-title-bar-i' }),
			ee('div', { class: 'sm:w-96 w-24 h-3 skeleton-text-bar-i' }),
			ee('div', { class: 'sm:w-32 w-32 h-3 skeleton-text-bar-i' }),
			ee('div', { class: 'sm:w-64 w-8 h-3 skeleton-text-bar-ii' }),
			ee('div', { class: 'sm:w-64 w-20 h-3 skeleton-text-bar-i' })
		],
		-1
	),
	TT = ee(
		'section',
		{ class: 'flex flex-col gap-4 pt-20 w-full' },
		[
			ee('div', {
				class: 'sm:w-64 w-24 h-6 mb-6 ml-6 skeleton-header-bar-i'
			}),
			ee('div', { class: 'sm:w-64 w-24 h-3 skeleton-text-bar-ii' }),
			ee('div', { class: 'sm:w-96 w-32 h-3 skeleton-text-bar-i' }),
			ee('div', { class: 'sm:w-24 w-8 h-3 skeleton-text-bar-ii' }),
			ee('div', { class: 'sm:w-64 w-20 h-3 skeleton-text-bar-i' }),
			ee('div', { class: 'sm:w-32 w-20 skeleton-text-bar-i' })
		],
		-1
	),
	ET = [ST, TT];
function AT(r, e, t, i, n, a) {
	return (
		Ce(),
		Oe('div', _T, [
			Ge(
				xa,
				{
					'enter-active-class':
                        'animate__animated animate__fadeInUp animate__fast',
					'leave-active-class':
                        'animate__animated animate__fadeOutDown animate__fast',
					'enter-from-class': 'opacity-0',
					'enter-to-class': 'opacity-100',
					'leave-from-class': 'opacity-100',
					'leave-to-class': 'opacity-0'
				},
				{
					default: tr(() => [
						i.isLoadingRendered
							? (Ce(), Oe('div', MT, ET))
							: Ot('', !0)
					]),
					_: 1
				}
			)
		])
	);
}
var LT = Yt(wT, [['render', AT]]);
const RT = { key: 1, class: 'h-48 w-48' },
	kT = { class: 'h-64' },
	CT = { key: 1 },
	PT = {
		data() {
			return {
				currentRoute: null,
				windowWidth: window.innerWidth,
				paddingValue: 0,
				setRoutingResizeDelay: !1,
				setAnimate: !0
			};
		},
		mounted() {
			this.$nextTick(() => {
				window.addEventListener('resize', this.onResize);
			}),
			setTimeout(() => {
				this.setDefaultPadding(), this.setDefaultWidth();
			}, 1e3),
			setTimeout(() => {
				this.setAnimate = !1;
			}, 4e3);
		},
		beforeDestroy() {
			window.removeEventListener('resize', this.onResize);
		},
		computed: {
			currentRouteName() {
				return this.$route.name;
			}
		},
		watch: {
			windowWidth() {
				this.windowWidth > 1280
					? ((this.paddingValue =
                          Math.trunc(this.windowWidth - 1280) / 2),
					this.paddingValue > 400 && (this.paddingvalue = 400))
					: this.windowWidth < 1280 && (this.paddingValue = 0);
			}
		},
		methods: {
			setWindowWidth(r) {
				this.windowWidth = r;
			},
			setDefaultWidth() {
				this.windowWidth > 1280
					? ((this.paddingValue =
                          Math.trunc(this.windowWidth - 1280) / 2),
					this.paddingValue > 400 && (this.paddingvalue = 400))
					: this.windowWidth < 1280 && (this.paddingValue = 0);
			},
			setDefaultPadding() {
				(this.paddingValue = Math.trunc(this.windowWidth - 1280) / 2),
				this.paddingValue > 400 && (this.paddingValue = 400);
			}
		}
	},
	IT = Object.assign(PT, {
		name: 'App',
		setup(r) {
			bf((u) => ({
				'7af73ae2': t.value.bg,
				'446790e1': t.value.bgSelector,
				95063788: t.value.svgColor,
				cbc77eec: t.value.text,
				'904a858a': t.value.tiCursorColor,
				'601a674a': t.value.textHighlight,
				beca4402: t.value.textHighlightAlt
			}));
			const e = document.body,
				t = lt({}),
				i = lt(''),
				n = Yg,
				a = lt(!1),
				s = lt(!1),
				o = lt(''),
				l = () => {
					if (e.className !== 'placeholder-theme') return;
					const u = n[Math.floor(Math.random() * n.length)],
						h = localStorage.getItem('themePreference');
					u.themeType === h || h === null
						? ((s.value = !0), (t.value = u.ColorScheme))
						: l();
				},
				c = () => {
					e.setAttribute('style', i.value.attributes.style.value),
					(a.value = !0),
					(e.className = ''),
					e.classList.add('set-palette'),
					console.log('Theme applied');
				};
			return (
				l(),
				As(() => {
					setTimeout(() => {
						o.value;
					}, 2500);
				}),
				(u, h) => {
					const d = yr('router-view');
					return (
						Ce(),
						Oe(
							'div',
							{ ref_key: 'baseModel', ref: i },
							[
								ee(
									'div',
									{
										class: nr([
											'xl:px-[20rem] lg:px-[14rem] md:px-[10rem] sm:px-[7rem] px-[4rem]',
											u.setAnimate && a.value
												? 'animate__animated animate__fadeInUp animate__fast'
												: null
										]),
										ref_key: 'baseContainer',
										ref: o
									},
									[
										Yr(
											Ge(
												mT,
												{
													onUpdateWindowSize:
                                                        h[0] ||
                                                        (h[0] = (p) =>
                                                        	u.setWindowWidth(p))
												},
												null,
												512
											),
											[[ps, a.value]]
										),
										a.value && u.currentRouteName !== 'ngl'
											? (Ce(),
											en(
												K2,
												{
													key: 0,
													'padding-value':
                                                          u.paddingValue
												},
												null,
												8,
												['padding-value']
											))
											: a.value &&
                                              u.currentRouteName === 'ngl'
												? (Ce(), Oe('div', RT))
												: Ot('', !0),
										Yr(
											ee(
												'div',
												kT,
												[Ge(bT, { onApplyTheme: c })],
												512
											),
											[[ps, !a.value]]
										),
										ee(
											'div',
											{
												class: nr([
													'pb-20 z-10 -mt-[5rem] -m-[3rem] px-5 sm:px-0 content-container',
													a.value ? 'divCenter' : null
												]),
												style: cn(
													u.windowWidth < 1280
														? null
														: {
															'padding-left':
                                                                  u.paddingValue -
                                                                  50 +
                                                                  'px',
															'padding-right':
                                                                  u.paddingValue -
                                                                  50 +
                                                                  'px'
														}
												)
											},
											[
												a.value
													? (Ce(),
													en(
														d,
														{ key: 0 },
														{
															default: tr(
																({
																	Component:
                                                                          p
																}) => [
																	Ge(
																		xa,
																		{
																			mode: 'out-in',
																			'enter-active-class':
                                                                                  'animate__animated animate__fadeInUp animate__fast',
																			'leave-active-class':
                                                                                  'animate__animated animate__fadeOutDown animate__fast'
																		},
																		{
																			default:
                                                                                  tr(
                                                                                  	() => [
                                                                                  		(Ce(),
                                                                                  		en(
                                                                                  			Wv(
                                                                                  				p
                                                                                  			),
                                                                                  			{
                                                                                  				'responsive-value':
                                                                                                      u.paddingValue
                                                                                  			},
                                                                                  			null,
                                                                                  			8,
                                                                                  			[
                                                                                  				'responsive-value'
                                                                                  			]
                                                                                  		))
                                                                                  	]
                                                                                  ),
																			_: 2
																		},
																		1024
																	)
																]
															),
															_: 1
														}
													))
													: Ot('', !0),
												a.value
													? Ot('', !0)
													: (Ce(),
													Oe('div', CT, [Ge(LT)]))
											],
											6
										)
									],
									2
								)
							],
							512
						)
					);
				}
			);
		}
	});
/*!
 * vue-router v4.0.15
 * (c) 2022 Eduardo San Martin Morote
 * @license MIT
 */ const Zg =
        typeof Symbol == 'function' && typeof Symbol.toStringTag == 'symbol',
	La = (r) => (Zg ? Symbol(r) : '_vr_' + r),
	DT = La('rvlm'),
	Jp = La('rvd'),
	hh = La('r'),
	$g = La('rl'),
	nu = La('rvl'),
	jn = typeof window != 'undefined';
function OT(r) {
	return r.__esModule || (Zg && r[Symbol.toStringTag] === 'Module');
}
const at = Object.assign;
function mc(r, e) {
	const t = {};
	for (const i in e) {
		const n = e[i];
		t[i] = Array.isArray(n) ? n.map(r) : r(n);
	}
	return t;
}
const as = () => {},
	NT = /\/$/,
	zT = (r) => r.replace(NT, '');
function fc(r, e, t = '/') {
	let i,
		n = {},
		a = '',
		s = '';
	const o = e.indexOf('?'),
		l = e.indexOf('#', o > -1 ? o : 0);
	return (
		o > -1 &&
            ((i = e.slice(0, o)),
            (a = e.slice(o + 1, l > -1 ? l : e.length)),
            (n = r(a))),
		l > -1 && ((i = i || e.slice(0, l)), (s = e.slice(l, e.length))),
		(i = HT(i != null ? i : e, t)),
		{ fullPath: i + (a && '?') + a + s, path: i, query: n, hash: s }
	);
}
function UT(r, e) {
	const t = e.query ? r(e.query) : '';
	return e.path + (t && '?') + t + (e.hash || '');
}
function Qp(r, e) {
	return !e || !r.toLowerCase().startsWith(e.toLowerCase())
		? r
		: r.slice(e.length) || '/';
}
function BT(r, e, t) {
	const i = e.matched.length - 1,
		n = t.matched.length - 1;
	return (
		i > -1 &&
        i === n &&
        ma(e.matched[i], t.matched[n]) &&
        Kg(e.params, t.params) &&
        r(e.query) === r(t.query) &&
        e.hash === t.hash
	);
}
function ma(r, e) {
	return (r.aliasOf || r) === (e.aliasOf || e);
}
function Kg(r, e) {
	if (Object.keys(r).length !== Object.keys(e).length) return !1;
	for (const t in r) if (!FT(r[t], e[t])) return !1;
	return !0;
}
function FT(r, e) {
	return Array.isArray(r) ? em(r, e) : Array.isArray(e) ? em(e, r) : r === e;
}
function em(r, e) {
	return Array.isArray(e)
		? r.length === e.length && r.every((t, i) => t === e[i])
		: r.length === 1 && r[0] === e;
}
function HT(r, e) {
	if (r.startsWith('/')) return r;
	if (!r) return e;
	const t = e.split('/'),
		i = r.split('/');
	let n = t.length - 1,
		a,
		s;
	for (a = 0; a < i.length; a++)
		if (((s = i[a]), !(n === 1 || s === '.')))
			if (s === '..') n--;
			else break;
	return (
		t.slice(0, n).join('/') +
        '/' +
        i.slice(a - (a === i.length ? 1 : 0)).join('/')
	);
}
var Ts;
(function (r) {
	(r.pop = 'pop'), (r.push = 'push');
})(Ts || (Ts = {}));
var ss;
(function (r) {
	(r.back = 'back'), (r.forward = 'forward'), (r.unknown = '');
})(ss || (ss = {}));
function GT(r) {
	if (!r)
		if (jn) {
			const e = document.querySelector('base');
			(r = (e && e.getAttribute('href')) || '/'),
			(r = r.replace(/^\w+:\/\/[^\/]+/, ''));
		} else r = '/';
	return r[0] !== '/' && r[0] !== '#' && (r = '/' + r), zT(r);
}
const VT = /^[^#]+#/;
function WT(r, e) {
	return r.replace(VT, '#') + e;
}
function jT(r, e) {
	const t = document.documentElement.getBoundingClientRect(),
		i = r.getBoundingClientRect();
	return {
		behavior: e.behavior,
		left: i.left - t.left - (e.left || 0),
		top: i.top - t.top - (e.top || 0)
	};
}
const vl = () => ({ left: window.pageXOffset, top: window.pageYOffset });
function XT(r) {
	let e;
	if ('el' in r) {
		const t = r.el,
			i = typeof t == 'string' && t.startsWith('#'),
			n =
                typeof t == 'string'
                	? i
                		? document.getElementById(t.slice(1))
                		: document.querySelector(t)
                	: t;
		if (!n) return;
		e = jT(n, r);
	} else e = r;
	'scrollBehavior' in document.documentElement.style
		? window.scrollTo(e)
		: window.scrollTo(
			e.left != null ? e.left : window.pageXOffset,
			e.top != null ? e.top : window.pageYOffset
		);
}
function tm(r, e) {
	return (history.state ? history.state.position - e : -1) + r;
}
const au = new Map();
function qT(r, e) {
	au.set(r, e);
}
function YT(r) {
	const e = au.get(r);
	return au.delete(r), e;
}
let ZT = () => location.protocol + '//' + location.host;
function Jg(r, e) {
	const { pathname: t, search: i, hash: n } = e,
		a = r.indexOf('#');
	if (a > -1) {
		let s = n.includes(r.slice(a)) ? r.slice(a).length : 1,
			o = n.slice(s);
		return o[0] !== '/' && (o = '/' + o), Qp(o, '');
	}
	return Qp(t, r) + i + n;
}
function $T(r, e, t, i) {
	let n = [],
		a = [],
		s = null;
	const o = ({ state: d }) => {
		const p = Jg(r, location),
			g = t.value,
			m = e.value;
		let f = 0;
		if (d) {
			if (((t.value = p), (e.value = d), s && s === g)) {
				s = null;
				return;
			}
			f = m ? d.position - m.position : 0;
		} else i(p);
		n.forEach((v) => {
			v(t.value, g, {
				delta: f,
				type: Ts.pop,
				direction: f ? (f > 0 ? ss.forward : ss.back) : ss.unknown
			});
		});
	};
	function l() {
		s = t.value;
	}
	function c(d) {
		n.push(d);
		const p = () => {
			const g = n.indexOf(d);
			g > -1 && n.splice(g, 1);
		};
		return a.push(p), p;
	}
	function u() {
		const { history: d } = window;
		!d.state || d.replaceState(at({}, d.state, { scroll: vl() }), '');
	}
	function h() {
		for (const d of a) d();
		(a = []),
		window.removeEventListener('popstate', o),
		window.removeEventListener('beforeunload', u);
	}
	return (
		window.addEventListener('popstate', o),
		window.addEventListener('beforeunload', u),
		{ pauseListeners: l, listen: c, destroy: h }
	);
}
function rm(r, e, t, i = !1, n = !1) {
	return {
		back: r,
		current: e,
		forward: t,
		replaced: i,
		position: window.history.length,
		scroll: n ? vl() : null
	};
}
function KT(r) {
	const { history: e, location: t } = window,
		i = { value: Jg(r, t) },
		n = { value: e.state };
	n.value ||
        a(
        	i.value,
        	{
        		back: null,
        		current: i.value,
        		forward: null,
        		position: e.length - 1,
        		replaced: !0,
        		scroll: null
        	},
        	!0
        );
	function a(l, c, u) {
		const h = r.indexOf('#'),
			d =
                h > -1
                	? (t.host && document.querySelector('base')
                		? r
                		: r.slice(h)) + l
                	: ZT() + r + l;
		try {
			e[u ? 'replaceState' : 'pushState'](c, '', d), (n.value = c);
		} catch (p) {
			console.error(p), t[u ? 'replace' : 'assign'](d);
		}
	}
	function s(l, c) {
		const u = at({}, e.state, rm(n.value.back, l, n.value.forward, !0), c, {
			position: n.value.position
		});
		a(l, u, !0), (i.value = l);
	}
	function o(l, c) {
		const u = at({}, n.value, e.state, { forward: l, scroll: vl() });
		a(u.current, u, !0);
		const h = at({}, rm(i.value, l, null), { position: u.position + 1 }, c);
		a(l, h, !1), (i.value = l);
	}
	return { location: i, state: n, push: o, replace: s };
}
function JT(r) {
	r = GT(r);
	const e = KT(r),
		t = $T(r, e.state, e.location, e.replace);
	function i(a, s = !0) {
		s || t.pauseListeners(), history.go(a);
	}
	const n = at(
		{ location: '', base: r, go: i, createHref: WT.bind(null, r) },
		e,
		t
	);
	return (
		Object.defineProperty(n, 'location', {
			enumerable: !0,
			get: () => e.location.value
		}),
		Object.defineProperty(n, 'state', {
			enumerable: !0,
			get: () => e.state.value
		}),
		n
	);
}
function QT(r) {
	return typeof r == 'string' || (r && typeof r == 'object');
}
function Qg(r) {
	return typeof r == 'string' || typeof r == 'symbol';
}
const gi = {
		path: '/',
		name: void 0,
		params: {},
		query: {},
		hash: '',
		fullPath: '/',
		matched: [],
		meta: {},
		redirectedFrom: void 0
	},
	e0 = La('nf');
var im;
(function (r) {
	(r[(r.aborted = 4)] = 'aborted'),
	(r[(r.cancelled = 8)] = 'cancelled'),
	(r[(r.duplicated = 16)] = 'duplicated');
})(im || (im = {}));
function fa(r, e) {
	return at(new Error(), { type: r, [e0]: !0 }, e);
}
function vi(r, e) {
	return r instanceof Error && e0 in r && (e == null || !!(r.type & e));
}
const nm = '[^/]+?',
	eE = { sensitive: !1, strict: !1, start: !0, end: !0 },
	tE = /[.+*?^${}()[\]/\\]/g;
function rE(r, e) {
	const t = at({}, eE, e),
		i = [];
	let n = t.start ? '^' : '';
	const a = [];
	for (const c of r) {
		const u = c.length ? [] : [90];
		t.strict && !c.length && (n += '/');
		for (let h = 0; h < c.length; h++) {
			const d = c[h];
			let p = 40 + (t.sensitive ? 0.25 : 0);
			if (d.type === 0)
				h || (n += '/'), (n += d.value.replace(tE, '\\$&')), (p += 40);
			else if (d.type === 1) {
				const { value: g, repeatable: m, optional: f, regexp: v } = d;
				a.push({ name: g, repeatable: m, optional: f });
				const x = v || nm;
				if (x !== nm) {
					p += 10;
					try {
						new RegExp(`(${x})`);
					} catch (S) {
						throw new Error(
							`Invalid custom RegExp for param "${g}" (${x}): ` +
                                S.message
						);
					}
				}
				let A = m ? `((?:${x})(?:/(?:${x}))*)` : `(${x})`;
				h || (A = f && c.length < 2 ? `(?:/${A})` : '/' + A),
				f && (A += '?'),
				(n += A),
				(p += 20),
				f && (p += -8),
				m && (p += -20),
				x === '.*' && (p += -50);
			}
			u.push(p);
		}
		i.push(u);
	}
	if (t.strict && t.end) {
		const c = i.length - 1;
		i[c][i[c].length - 1] += 0.7000000000000001;
	}
	t.strict || (n += '/?'), t.end ? (n += '$') : t.strict && (n += '(?:/|$)');
	const s = new RegExp(n, t.sensitive ? '' : 'i');
	function o(c) {
		const u = c.match(s),
			h = {};
		if (!u) return null;
		for (let d = 1; d < u.length; d++) {
			const p = u[d] || '',
				g = a[d - 1];
			h[g.name] = p && g.repeatable ? p.split('/') : p;
		}
		return h;
	}
	function l(c) {
		let u = '',
			h = !1;
		for (const d of r) {
			(!h || !u.endsWith('/')) && (u += '/'), (h = !1);
			for (const p of d)
				if (p.type === 0) u += p.value;
				else if (p.type === 1) {
					const { value: g, repeatable: m, optional: f } = p,
						v = g in c ? c[g] : '';
					if (Array.isArray(v) && !m)
						throw new Error(
							`Provided param "${g}" is an array but it is not repeatable (* or + modifiers)`
						);
					const x = Array.isArray(v) ? v.join('/') : v;
					if (!x)
						if (f)
							d.length < 2 &&
                                r.length > 1 &&
                                (u.endsWith('/')
                                	? (u = u.slice(0, -1))
                                	: (h = !0));
						else throw new Error(`Missing required param "${g}"`);
					u += x;
				}
		}
		return u;
	}
	return { re: s, score: i, keys: a, parse: o, stringify: l };
}
function iE(r, e) {
	let t = 0;
	for (; t < r.length && t < e.length; ) {
		const i = e[t] - r[t];
		if (i) return i;
		t++;
	}
	return r.length < e.length
		? r.length === 1 && r[0] === 40 + 40
			? -1
			: 1
		: r.length > e.length
			? e.length === 1 && e[0] === 40 + 40
				? 1
				: -1
			: 0;
}
function nE(r, e) {
	let t = 0;
	const i = r.score,
		n = e.score;
	for (; t < i.length && t < n.length; ) {
		const a = iE(i[t], n[t]);
		if (a) return a;
		t++;
	}
	return n.length - i.length;
}
const aE = { type: 0, value: '' },
	sE = /[a-zA-Z0-9_]/;
function oE(r) {
	if (!r) return [[]];
	if (r === '/') return [[aE]];
	if (!r.startsWith('/')) throw new Error(`Invalid path "${r}"`);
	function e(p) {
		throw new Error(`ERR (${t})/"${c}": ${p}`);
	}
	let t = 0,
		i = t;
	const n = [];
	let a;
	function s() {
		a && n.push(a), (a = []);
	}
	let o = 0,
		l,
		c = '',
		u = '';
	function h() {
		!c ||
            (t === 0
            	? a.push({ type: 0, value: c })
            	: t === 1 || t === 2 || t === 3
            		? (a.length > 1 &&
                      (l === '*' || l === '+') &&
                      e(
                      	`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`
                      ),
            		a.push({
            			type: 1,
            			value: c,
            			regexp: u,
            			repeatable: l === '*' || l === '+',
            			optional: l === '*' || l === '?'
            		}))
            		: e('Invalid state to consume buffer'),
            (c = ''));
	}
	function d() {
		c += l;
	}
	for (; o < r.length; ) {
		if (((l = r[o++]), l === '\\' && t !== 2)) {
			(i = t), (t = 4);
			continue;
		}
		switch (t) {
		case 0:
			l === '/' ? (c && h(), s()) : l === ':' ? (h(), (t = 1)) : d();
			break;
		case 4:
			d(), (t = i);
			break;
		case 1:
			l === '('
				? (t = 2)
				: sE.test(l)
					? d()
					: (h(),
					(t = 0),
					l !== '*' && l !== '?' && l !== '+' && o--);
			break;
		case 2:
			l === ')'
				? u[u.length - 1] == '\\'
					? (u = u.slice(0, -1) + l)
					: (t = 3)
				: (u += l);
			break;
		case 3:
			h(),
			(t = 0),
			l !== '*' && l !== '?' && l !== '+' && o--,
			(u = '');
			break;
		default:
			e('Unknown state');
			break;
		}
	}
	return (
		t === 2 && e(`Unfinished custom RegExp for param "${c}"`), h(), s(), n
	);
}
function lE(r, e, t) {
	const i = rE(oE(r.path), t),
		n = at(i, { record: r, parent: e, children: [], alias: [] });
	return e && !n.record.aliasOf == !e.record.aliasOf && e.children.push(n), n;
}
function cE(r, e) {
	const t = [],
		i = new Map();
	e = sm({ strict: !1, end: !0, sensitive: !1 }, e);
	function n(u) {
		return i.get(u);
	}
	function a(u, h, d) {
		const p = !d,
			g = hE(u);
		g.aliasOf = d && d.record;
		const m = sm(e, u),
			f = [g];
		if ('alias' in u) {
			const A = typeof u.alias == 'string' ? [u.alias] : u.alias;
			for (const S of A)
				f.push(
					at({}, g, {
						components: d ? d.record.components : g.components,
						path: S,
						aliasOf: d ? d.record : g
					})
				);
		}
		let v, x;
		for (const A of f) {
			const { path: S } = A;
			if (h && S[0] !== '/') {
				const M = h.record.path,
					I = M[M.length - 1] === '/' ? '' : '/';
				A.path = h.record.path + (S && I + S);
			}
			if (
				((v = lE(A, h, m)),
				d
					? d.alias.push(v)
					: ((x = x || v),
					x !== v && x.alias.push(v),
					p && u.name && !am(v) && s(u.name)),
				'children' in g)
			) {
				const M = g.children;
				for (let I = 0; I < M.length; I++)
					a(M[I], v, d && d.children[I]);
			}
			(d = d || v), l(v);
		}
		return x
			? () => {
				s(x);
			}
			: as;
	}
	function s(u) {
		if (Qg(u)) {
			const h = i.get(u);
			h &&
                (i.delete(u),
                t.splice(t.indexOf(h), 1),
                h.children.forEach(s),
                h.alias.forEach(s));
		} else {
			const h = t.indexOf(u);
			h > -1 &&
                (t.splice(h, 1),
                u.record.name && i.delete(u.record.name),
                u.children.forEach(s),
                u.alias.forEach(s));
		}
	}
	function o() {
		return t;
	}
	function l(u) {
		let h = 0;
		for (
			;
			h < t.length &&
            nE(u, t[h]) >= 0 &&
            (u.record.path !== t[h].record.path || !t0(u, t[h]));

		)
			h++;
		t.splice(h, 0, u), u.record.name && !am(u) && i.set(u.record.name, u);
	}
	function c(u, h) {
		let d,
			p = {},
			g,
			m;
		if ('name' in u && u.name) {
			if (((d = i.get(u.name)), !d)) throw fa(1, { location: u });
			(m = d.record.name),
			(p = at(
				uE(
					h.params,
					d.keys.filter((x) => !x.optional).map((x) => x.name)
				),
				u.params
			)),
			(g = d.stringify(p));
		} else if ('path' in u)
			(g = u.path),
			(d = t.find((x) => x.re.test(g))),
			d && ((p = d.parse(g)), (m = d.record.name));
		else {
			if (
				((d = h.name
					? i.get(h.name)
					: t.find((x) => x.re.test(h.path))),
				!d)
			)
				throw fa(1, { location: u, currentLocation: h });
			(m = d.record.name),
			(p = at({}, h.params, u.params)),
			(g = d.stringify(p));
		}
		const f = [];
		let v = d;
		for (; v; ) f.unshift(v.record), (v = v.parent);
		return { name: m, path: g, params: p, matched: f, meta: pE(f) };
	}
	return (
		r.forEach((u) => a(u)),
		{
			addRoute: a,
			resolve: c,
			removeRoute: s,
			getRoutes: o,
			getRecordMatcher: n
		}
	);
}
function uE(r, e) {
	const t = {};
	for (const i of e) i in r && (t[i] = r[i]);
	return t;
}
function hE(r) {
	return {
		path: r.path,
		redirect: r.redirect,
		name: r.name,
		meta: r.meta || {},
		aliasOf: void 0,
		beforeEnter: r.beforeEnter,
		props: dE(r),
		children: r.children || [],
		instances: {},
		leaveGuards: new Set(),
		updateGuards: new Set(),
		enterCallbacks: {},
		components:
            'components' in r ? r.components || {} : { default: r.component }
	};
}
function dE(r) {
	const e = {},
		t = r.props || !1;
	if ('component' in r) e.default = t;
	else for (const i in r.components) e[i] = typeof t == 'boolean' ? t : t[i];
	return e;
}
function am(r) {
	for (; r; ) {
		if (r.record.aliasOf) return !0;
		r = r.parent;
	}
	return !1;
}
function pE(r) {
	return r.reduce((e, t) => at(e, t.meta), {});
}
function sm(r, e) {
	const t = {};
	for (const i in r) t[i] = i in e ? e[i] : r[i];
	return t;
}
function t0(r, e) {
	return e.children.some((t) => t === r || t0(r, t));
}
const r0 = /#/g,
	mE = /&/g,
	fE = /\//g,
	gE = /=/g,
	vE = /\?/g,
	i0 = /\+/g,
	yE = /%5B/g,
	xE = /%5D/g,
	n0 = /%5E/g,
	bE = /%60/g,
	a0 = /%7B/g,
	wE = /%7C/g,
	s0 = /%7D/g,
	_E = /%20/g;
function dh(r) {
	return encodeURI('' + r)
		.replace(wE, '|')
		.replace(yE, '[')
		.replace(xE, ']');
}
function ME(r) {
	return dh(r).replace(a0, '{').replace(s0, '}').replace(n0, '^');
}
function su(r) {
	return dh(r)
		.replace(i0, '%2B')
		.replace(_E, '+')
		.replace(r0, '%23')
		.replace(mE, '%26')
		.replace(bE, '`')
		.replace(a0, '{')
		.replace(s0, '}')
		.replace(n0, '^');
}
function SE(r) {
	return su(r).replace(gE, '%3D');
}
function TE(r) {
	return dh(r).replace(r0, '%23').replace(vE, '%3F');
}
function EE(r) {
	return r == null ? '' : TE(r).replace(fE, '%2F');
}
function Fo(r) {
	try {
		return decodeURIComponent('' + r);
	} catch {}
	return '' + r;
}
function AE(r) {
	const e = {};
	if (r === '' || r === '?') return e;
	const t = (r[0] === '?' ? r.slice(1) : r).split('&');
	for (let i = 0; i < t.length; ++i) {
		const n = t[i].replace(i0, ' '),
			a = n.indexOf('='),
			s = Fo(a < 0 ? n : n.slice(0, a)),
			o = a < 0 ? null : Fo(n.slice(a + 1));
		if (s in e) {
			let l = e[s];
			Array.isArray(l) || (l = e[s] = [l]), l.push(o);
		} else e[s] = o;
	}
	return e;
}
function om(r) {
	let e = '';
	for (let t in r) {
		const i = r[t];
		if (((t = SE(t)), i == null)) {
			i !== void 0 && (e += (e.length ? '&' : '') + t);
			continue;
		}
		(Array.isArray(i) ? i.map((n) => n && su(n)) : [i && su(i)]).forEach(
			(n) => {
				n !== void 0 &&
                    ((e += (e.length ? '&' : '') + t),
                    n != null && (e += '=' + n));
			}
		);
	}
	return e;
}
function LE(r) {
	const e = {};
	for (const t in r) {
		const i = r[t];
		i !== void 0 &&
            (e[t] = Array.isArray(i)
            	? i.map((n) => (n == null ? null : '' + n))
            	: i == null
            		? i
            		: '' + i);
	}
	return e;
}
function Wa() {
	let r = [];
	function e(i) {
		return (
			r.push(i),
			() => {
				const n = r.indexOf(i);
				n > -1 && r.splice(n, 1);
			}
		);
	}
	function t() {
		r = [];
	}
	return { add: e, list: () => r, reset: t };
}
function bi(r, e, t, i, n) {
	const a = i && (i.enterCallbacks[n] = i.enterCallbacks[n] || []);
	return () =>
		new Promise((s, o) => {
			const l = (h) => {
					h === !1
						? o(fa(4, { from: t, to: e }))
						: h instanceof Error
							? o(h)
							: QT(h)
								? o(fa(2, { from: e, to: h }))
								: (a &&
                              i.enterCallbacks[n] === a &&
                              typeof h == 'function' &&
                              a.push(h),
								s());
				},
				c = r.call(i && i.instances[n], e, t, l);
			let u = Promise.resolve(c);
			r.length < 3 && (u = u.then(l)), u.catch((h) => o(h));
		});
}
function gc(r, e, t, i) {
	const n = [];
	for (const a of r)
		for (const s in a.components) {
			let o = a.components[s];
			if (!(e !== 'beforeRouteEnter' && !a.instances[s]))
				if (RE(o)) {
					const l = (o.__vccOpts || o)[e];
					l && n.push(bi(l, t, i, a, s));
				} else {
					let l = o();
					n.push(() =>
						l.then((c) => {
							if (!c)
								return Promise.reject(
									new Error(
										`Couldn't resolve component "${s}" at "${a.path}"`
									)
								);
							const u = OT(c) ? c.default : c;
							a.components[s] = u;
							const h = (u.__vccOpts || u)[e];
							return h && bi(h, t, i, a, s)();
						})
					);
				}
		}
	return n;
}
function RE(r) {
	return (
		typeof r == 'object' ||
        'displayName' in r ||
        'props' in r ||
        '__vccOpts' in r
	);
}
function lm(r) {
	const e = Ti(hh),
		t = Ti($g),
		i = mr(() => e.resolve(Qn(r.to))),
		n = mr(() => {
			const { matched: l } = i.value,
				{ length: c } = l,
				u = l[c - 1],
				h = t.matched;
			if (!u || !h.length) return -1;
			const d = h.findIndex(ma.bind(null, u));
			if (d > -1) return d;
			const p = cm(l[c - 2]);
			return c > 1 && cm(u) === p && h[h.length - 1].path !== p
				? h.findIndex(ma.bind(null, l[c - 2]))
				: d;
		}),
		a = mr(() => n.value > -1 && IE(t.params, i.value.params)),
		s = mr(
			() =>
				n.value > -1 &&
                n.value === t.matched.length - 1 &&
                Kg(t.params, i.value.params)
		);
	function o(l = {}) {
		return PE(l)
			? e[Qn(r.replace) ? 'replace' : 'push'](Qn(r.to)).catch(as)
			: Promise.resolve();
	}
	return {
		route: i,
		href: mr(() => i.value.href),
		isActive: a,
		isExactActive: s,
		navigate: o
	};
}
const kE = Qm({
		name: 'RouterLink',
		props: {
			to: { type: [String, Object], required: !0 },
			replace: Boolean,
			activeClass: String,
			exactActiveClass: String,
			custom: Boolean,
			ariaCurrentValue: { type: String, default: 'page' }
		},
		useLink: lm,
		setup(r, { slots: e }) {
			const t = Es(lm(r)),
				{ options: i } = Ti(hh),
				n = mr(() => ({
					[um(
						r.activeClass,
						i.linkActiveClass,
						'router-link-active'
					)]: t.isActive,
					[um(
						r.exactActiveClass,
						i.linkExactActiveClass,
						'router-link-exact-active'
					)]: t.isExactActive
				}));
			return () => {
				const a = e.default && e.default(t);
				return r.custom
					? a
					: Au(
						'a',
						{
							'aria-current': t.isExactActive
								? r.ariaCurrentValue
								: null,
							href: t.href,
							onClick: t.navigate,
							class: n.value
						},
						a
					);
			};
		}
	}),
	CE = kE;
function PE(r) {
	if (
		!(r.metaKey || r.altKey || r.ctrlKey || r.shiftKey) &&
        !r.defaultPrevented &&
        !(r.button !== void 0 && r.button !== 0)
	) {
		if (r.currentTarget && r.currentTarget.getAttribute) {
			const e = r.currentTarget.getAttribute('target');
			if (/\b_blank\b/i.test(e)) return;
		}
		return r.preventDefault && r.preventDefault(), !0;
	}
}
function IE(r, e) {
	for (const t in e) {
		const i = e[t],
			n = r[t];
		if (typeof i == 'string') {
			if (i !== n) return !1;
		} else if (
			!Array.isArray(n) ||
            n.length !== i.length ||
            i.some((a, s) => a !== n[s])
		)
			return !1;
	}
	return !0;
}
function cm(r) {
	return r ? (r.aliasOf ? r.aliasOf.path : r.path) : '';
}
const um = (r, e, t) => (r != null ? r : e != null ? e : t),
	DE = Qm({
		name: 'RouterView',
		inheritAttrs: !1,
		props: { name: { type: String, default: 'default' }, route: Object },
		compatConfig: { MODE: 3 },
		setup(r, { attrs: e, slots: t }) {
			const i = Ti(nu),
				n = mr(() => r.route || i.value),
				a = Ti(Jp, 0),
				s = mr(() => n.value.matched[a]);
			_o(Jp, a + 1), _o(DT, s), _o(nu, n);
			const o = lt();
			return (
				Mo(
					() => [o.value, s.value, r.name],
					([l, c, u], [h, d, p]) => {
						c &&
                            ((c.instances[u] = l),
                            d &&
                                d !== c &&
                                l &&
                                l === h &&
                                (c.leaveGuards.size ||
                                    (c.leaveGuards = d.leaveGuards),
                                c.updateGuards.size ||
                                    (c.updateGuards = d.updateGuards))),
						l &&
                                c &&
                                (!d || !ma(c, d) || !h) &&
                                (c.enterCallbacks[u] || []).forEach((g) =>
                                	g(l)
                                );
					},
					{ flush: 'post' }
				),
				() => {
					const l = n.value,
						c = s.value,
						u = c && c.components[r.name],
						h = r.name;
					if (!u) return hm(t.default, { Component: u, route: l });
					const d = c.props[r.name],
						p = d
							? d === !0
								? l.params
								: typeof d == 'function'
									? d(l)
									: d
							: null,
						g = Au(
							u,
							at({}, p, e, {
								onVnodeUnmounted: (m) => {
									m.component.isUnmounted &&
                                        (c.instances[h] = null);
								},
								ref: o
							})
						);
					return hm(t.default, { Component: g, route: l }) || g;
				}
			);
		}
	});
function hm(r, e) {
	if (!r) return null;
	const t = r(e);
	return t.length === 1 ? t[0] : t;
}
const OE = DE;
function NE(r) {
	const e = cE(r.routes, r),
		t = r.parseQuery || AE,
		i = r.stringifyQuery || om,
		n = r.history,
		a = Wa(),
		s = Wa(),
		o = Wa(),
		l = pv(gi);
	let c = gi;
	jn &&
        r.scrollBehavior &&
        'scrollRestoration' in history &&
        (history.scrollRestoration = 'manual');
	const u = mc.bind(null, (W) => '' + W),
		h = mc.bind(null, EE),
		d = mc.bind(null, Fo);
	function p(W, ue) {
		let U, ve;
		return (
			Qg(W) ? ((U = e.getRecordMatcher(W)), (ve = ue)) : (ve = W),
			e.addRoute(ve, U)
		);
	}
	function g(W) {
		const ue = e.getRecordMatcher(W);
		ue && e.removeRoute(ue);
	}
	function m() {
		return e.getRoutes().map((W) => W.record);
	}
	function f(W) {
		return !!e.getRecordMatcher(W);
	}
	function v(W, ue) {
		if (((ue = at({}, ue || l.value)), typeof W == 'string')) {
			const K = fc(t, W, ue.path),
				te = e.resolve({ path: K.path }, ue),
				w = n.createHref(K.fullPath);
			return at(K, te, {
				params: d(te.params),
				hash: Fo(K.hash),
				redirectedFrom: void 0,
				href: w
			});
		}
		let U;
		if ('path' in W) U = at({}, W, { path: fc(t, W.path, ue.path).path });
		else {
			const K = at({}, W.params);
			for (const te in K) K[te] == null && delete K[te];
			(U = at({}, W, { params: h(W.params) })),
			(ue.params = h(ue.params));
		}
		const ve = e.resolve(U, ue),
			Ae = W.hash || '';
		ve.params = u(d(ve.params));
		const Te = UT(i, at({}, W, { hash: ME(Ae), path: ve.path })),
			ae = n.createHref(Te);
		return at(
			{
				fullPath: Te,
				hash: Ae,
				query: i === om ? LE(W.query) : W.query || {}
			},
			ve,
			{ redirectedFrom: void 0, href: ae }
		);
	}
	function x(W) {
		return typeof W == 'string' ? fc(t, W, l.value.path) : at({}, W);
	}
	function A(W, ue) {
		if (c !== W) return fa(8, { from: ue, to: W });
	}
	function S(W) {
		return D(W);
	}
	function M(W) {
		return S(at(x(W), { replace: !0 }));
	}
	function I(W) {
		const ue = W.matched[W.matched.length - 1];
		if (ue && ue.redirect) {
			const { redirect: U } = ue;
			let ve = typeof U == 'function' ? U(W) : U;
			return (
				typeof ve == 'string' &&
                    ((ve =
                        ve.includes('?') || ve.includes('#')
                        	? (ve = x(ve))
                        	: { path: ve }),
                    (ve.params = {})),
				at({ query: W.query, hash: W.hash, params: W.params }, ve)
			);
		}
	}
	function D(W, ue) {
		const U = (c = v(W)),
			ve = l.value,
			Ae = W.state,
			Te = W.force,
			ae = W.replace === !0,
			K = I(U);
		if (K)
			return D(at(x(K), { state: Ae, force: Te, replace: ae }), ue || U);
		const te = U;
		te.redirectedFrom = ue;
		let w;
		return (
			!Te &&
                BT(i, ve, U) &&
                ((w = fa(16, { to: te, from: ve })), J(ve, ve, !0, !1)),
			(w ? Promise.resolve(w) : re(te, ve))
				.catch((R) => (vi(R) ? (vi(R, 2) ? R : Z(R)) : k(R, te, ve)))
				.then((R) => {
					if (R) {
						if (vi(R, 2))
							return D(
								at(x(R.to), {
									state: Ae,
									force: Te,
									replace: ae
								}),
								ue || te
							);
					} else R = b(te, ve, !0, ae, Ae);
					return B(te, ve, R), R;
				})
		);
	}
	function G(W, ue) {
		const U = A(W, ue);
		return U ? Promise.reject(U) : Promise.resolve();
	}
	function re(W, ue) {
		let U;
		const [ve, Ae, Te] = zE(W, ue);
		U = gc(ve.reverse(), 'beforeRouteLeave', W, ue);
		for (const K of ve)
			K.leaveGuards.forEach((te) => {
				U.push(bi(te, W, ue));
			});
		const ae = G.bind(null, W, ue);
		return (
			U.push(ae),
			Bn(U)
				.then(() => {
					U = [];
					for (const K of a.list()) U.push(bi(K, W, ue));
					return U.push(ae), Bn(U);
				})
				.then(() => {
					U = gc(Ae, 'beforeRouteUpdate', W, ue);
					for (const K of Ae)
						K.updateGuards.forEach((te) => {
							U.push(bi(te, W, ue));
						});
					return U.push(ae), Bn(U);
				})
				.then(() => {
					U = [];
					for (const K of W.matched)
						if (K.beforeEnter && !ue.matched.includes(K))
							if (Array.isArray(K.beforeEnter))
								for (const te of K.beforeEnter)
									U.push(bi(te, W, ue));
							else U.push(bi(K.beforeEnter, W, ue));
					return U.push(ae), Bn(U);
				})
				.then(
					() => (
						W.matched.forEach((K) => (K.enterCallbacks = {})),
						(U = gc(Te, 'beforeRouteEnter', W, ue)),
						U.push(ae),
						Bn(U)
					)
				)
				.then(() => {
					U = [];
					for (const K of s.list()) U.push(bi(K, W, ue));
					return U.push(ae), Bn(U);
				})
				.catch((K) => (vi(K, 8) ? K : Promise.reject(K)))
		);
	}
	function B(W, ue, U) {
		for (const ve of o.list()) ve(W, ue, U);
	}
	function b(W, ue, U, ve, Ae) {
		const Te = A(W, ue);
		if (Te) return Te;
		const ae = ue === gi,
			K = jn ? history.state : {};
		U &&
            (ve || ae
            	? n.replace(W.fullPath, at({ scroll: ae && K && K.scroll }, Ae))
            	: n.push(W.fullPath, Ae)),
		(l.value = W),
		J(W, ue, U, ae),
		Z();
	}
	let E;
	function j() {
		E ||
            (E = n.listen((W, ue, U) => {
            	const ve = v(W),
            		Ae = I(ve);
            	if (Ae) {
            		D(at(Ae, { replace: !0 }), ve).catch(as);
            		return;
            	}
            	c = ve;
            	const Te = l.value;
            	jn && qT(tm(Te.fullPath, U.delta), vl()),
            	re(ve, Te)
            		.catch((ae) =>
            			vi(ae, 12)
            				? ae
            				: vi(ae, 2)
            					? (D(ae.to, ve)
            						.then((K) => {
            							vi(K, 20) &&
                                              !U.delta &&
                                              U.type === Ts.pop &&
                                              n.go(-1, !1);
            						})
            						.catch(as),
            					Promise.reject())
            					: (U.delta && n.go(-U.delta, !1), k(ae, ve, Te))
            		)
            		.then((ae) => {
            			(ae = ae || b(ve, Te, !1)),
            			ae &&
                                    (U.delta
                                    	? n.go(-U.delta, !1)
                                    	: U.type === Ts.pop &&
                                          vi(ae, 20) &&
                                          n.go(-1, !1)),
            			B(ve, Te, ae);
            		})
            		.catch(as);
            }));
	}
	let z = Wa(),
		V = Wa(),
		H;
	function k(W, ue, U) {
		Z(W);
		const ve = V.list();
		return (
			ve.length ? ve.forEach((Ae) => Ae(W, ue, U)) : console.error(W),
			Promise.reject(W)
		);
	}
	function P() {
		return H && l.value !== gi
			? Promise.resolve()
			: new Promise((W, ue) => {
				z.add([W, ue]);
			});
	}
	function Z(W) {
		return (
			H ||
                ((H = !W),
                j(),
                z.list().forEach(([ue, U]) => (W ? U(W) : ue())),
                z.reset()),
			W
		);
	}
	function J(W, ue, U, ve) {
		const { scrollBehavior: Ae } = r;
		if (!jn || !Ae) return Promise.resolve();
		const Te =
            (!U && YT(tm(W.fullPath, 0))) ||
            ((ve || !U) && history.state && history.state.scroll) ||
            null;
		return Fm()
			.then(() => Ae(W, ue, Te))
			.then((ae) => ae && XT(ae))
			.catch((ae) => k(ae, W, ue));
	}
	const fe = (W) => n.go(W);
	let ce;
	const xe = new Set();
	return {
		currentRoute: l,
		addRoute: p,
		removeRoute: g,
		hasRoute: f,
		getRoutes: m,
		resolve: v,
		options: r,
		push: S,
		replace: M,
		go: fe,
		back: () => fe(-1),
		forward: () => fe(1),
		beforeEach: a.add,
		beforeResolve: s.add,
		afterEach: o.add,
		onError: V.add,
		isReady: P,
		install(W) {
			const ue = this;
			W.component('RouterLink', CE),
			W.component('RouterView', OE),
			(W.config.globalProperties.$router = ue),
			Object.defineProperty(W.config.globalProperties, '$route', {
				enumerable: !0,
				get: () => Qn(l)
			}),
			jn &&
                    !ce &&
                    l.value === gi &&
                    ((ce = !0), S(n.location).catch((Ae) => {}));
			const U = {};
			for (const Ae in gi) U[Ae] = mr(() => l.value[Ae]);
			W.provide(hh, ue), W.provide($g, Es(U)), W.provide(nu, l);
			const ve = W.unmount;
			xe.add(W),
			(W.unmount = function () {
				xe.delete(W),
				xe.size < 1 &&
                            ((c = gi),
                            E && E(),
                            (E = null),
                            (l.value = gi),
                            (ce = !1),
                            (H = !1)),
				ve();
			});
		}
	};
}
function Bn(r) {
	return r.reduce((e, t) => e.then(() => t()), Promise.resolve());
}
function zE(r, e) {
	const t = [],
		i = [],
		n = [],
		a = Math.max(e.matched.length, r.matched.length);
	for (let s = 0; s < a; s++) {
		const o = e.matched[s];
		o && (r.matched.find((c) => ma(c, o)) ? i.push(o) : t.push(o));
		const l = r.matched[s];
		l && (e.matched.find((c) => ma(c, l)) || n.push(l));
	}
	return [t, i, n];
}
var o0 = (r) => Array.isArray(r),
	l0 = (r) => (o0(r) ? r : [r]);
let UE = function (r) {
	let e = function (d) {
			return (
				l0(d).forEach((p) => {
					var g;
					return h.set(
						Symbol((g = p.char) == null ? void 0 : g.innerText),
						T0({}, p)
					);
				}),
				this
			);
		},
		t = () => o().filter((d) => d.typeable),
		i = function (d, p) {
			let g = [...h.keys()];
			h.set(g[d], p);
		},
		n = function () {
			h.forEach((d) => delete d.done);
		},
		a = function () {
			(h = new Map()), e(r);
		},
		s = () => h,
		o = () => Array.from(h.values()),
		l = (d) => h.delete(d),
		c = (d = !1) => (d ? o() : o().filter((p) => !p.done)),
		u = (d, p = !1) => (p ? h.delete(d) : (h.get(d).done = !0)),
		h = new Map();
	return (
		e(r),
		{
			add: e,
			set: i,
			wipe: a,
			reset: n,
			destroy: l,
			done: u,
			getItems: c,
			getQueue: s,
			getTypeable: t
		}
	);
};
var c0 = (r) => Array.from(r),
	ph = (r) => document.createTextNode(r);
let mh = (r) => (
	[...r.childNodes].forEach((e) => {
		if (e.nodeValue) {
			[...e.nodeValue].forEach((t) => {
				e.parentNode.insertBefore(ph(t), e);
			}),
			e.remove();
			return;
		}
		mh(e);
	}),
	r
);
var u0 = (r) => {
	let e = document.implementation.createHTMLDocument();
	return (e.body.innerHTML = r), mh(e.body);
};
const h0 = 'data-typeit-id',
	ks = 'ti-cursor',
	BE = 'END',
	FE = { started: !1, completed: !1, frozen: !1, destroyed: !1 },
	HE = {
		breakLines: !0,
		cursor: !0,
		cursorChar: '|',
		cursorSpeed: 1e3,
		deleteSpeed: null,
		html: !0,
		lifeLike: !0,
		loop: !1,
		loopDelay: 750,
		nextStringDelay: 750,
		speed: 100,
		startDelay: 250,
		startDelete: !1,
		strings: [],
		waitUntilVisible: !1,
		beforeString: () => {},
		afterString: () => {},
		beforeStep: () => {},
		afterStep: () => {},
		afterComplete: () => {}
	},
	GE = `[${h0}]:before {content: '.'; display: inline-block; width: 0; visibility: hidden;}`;
function d0(r, e = !1) {
	let t = document.createTreeWalker(r, NodeFilter.SHOW_ALL, {
			acceptNode: (a) => {
				var s;
				return (s = a.classList) != null && s.contains(ks)
					? NodeFilter.FILTER_REJECT
					: NodeFilter.FILTER_ACCEPT;
			}
		}),
		i,
		n = [];
	for (; (i = t.nextNode()); ) (i.originalParent = i.parentNode), n.push(i);
	return e ? n.reverse() : n;
}
function VE(r) {
	return d0(u0(r));
}
function WE(r, e = !0) {
	return e ? VE(r) : c0(r).map(ph);
}
var Lo = (r) => document.createElement(r),
	p0 = (r, e = '') => {
		let t = Lo('style');
		(t.id = e), t.appendChild(ph(r)), document.head.appendChild(t);
	},
	dm = (r) => (o0(r) || (r = [r / 2, r / 2]), r),
	pm = (r, e) => Math.abs(Math.random() * (r + e - (r - e)) + (r - e));
let mm = (r) => r / 2;
function jE(r) {
	let { speed: e, deleteSpeed: t, lifeLike: i } = r;
	return (
		(t = t !== null ? t : e / 3), i ? [pm(e, mm(e)), pm(t, mm(t))] : [e, t]
	);
}
var XE = (r) => (r.forEach(clearTimeout), []),
	qE = () => Math.random().toString().substring(2, 9),
	fh = (r) => 'value' in r;
let YE = (r) =>
	fh(r) ? c0(r.value) : d0(r, !0).filter((e) => !(e.childNodes.length > 0));
var ZE = (r, e) => {
	new IntersectionObserver(
		(t, i) => {
			t.forEach((n) => {
				n.isIntersecting && (e(), i.unobserve(r));
			});
		},
		{ threshold: 1 }
	).observe(r);
};
let Fn = (r) => (typeof r == 'function' ? r() : r);
var m0 = (r) => Number.isInteger(r);
let gh = (r, e = document, t = !1) => e[`querySelector${t ? 'All' : ''}`](r),
	$E = (r) => (r == null ? void 0 : r.tagName) === 'BODY',
	KE = (r, e) => {
		if (fh(r)) {
			r.value = `${r.value}${e.textContent}`;
			return;
		}
		e.innerHTML = '';
		let t = $E(e.originalParent) ? r : e.originalParent || r;
		t.insertBefore(e, gh('.' + ks, t) || null);
	},
	JE = (r, e, t) => Math.min(Math.max(e + r, 0), t.length);
var xo = (r, e) => Object.assign({}, r, e),
	vc = (r) => {
		if (!r) return;
		let e = r.parentNode;
		(e.childNodes.length > 1 ? r : e).remove();
	},
	QE = (r, e, t) => {
		let i = e[t - 1],
			n = gh(`.${ks}`, r);
		(r = (i == null ? void 0 : i.parentNode) || r),
		r.insertBefore(n, i || null);
	};
function eA(r) {
	return typeof r == 'string' ? gh(r) : r;
}
var tA = (r) => /<(.+)>(.*?)<\/(.+)>/.test(r.outerHTML);
let rA = async (r, e, t) =>
		new Promise((i) => {
			let n = async () => {
				await r(), i();
			};
			t.push(setTimeout(n, e || 0));
		}),
	iA = {
		'font-family': '',
		'font-weight': '',
		'font-size': '',
		'font-style': '',
		'line-height': '',
		color: '',
		'margin-left': '-.125em',
		'margin-right': '.125em'
	},
	nA = (r, e, t) => {
		let i = `${`[${h0}='${r}']`} .${ks}`,
			n = getComputedStyle(t),
			a = Object.entries(iA).reduce(
				(s, [o, l]) =>
					`${s} ${o}: var(--ti-cursor-${o}, ${l || n[o]});`,
				''
			);
		p0(
			`@keyframes blink-${r} { 0% {opacity: 0} 49% {opacity: 0} 50% {opacity: 1} } ${i} { display: inline; letter-spacing: -1em; ${a} animation: blink-${r} ${
				e.cursorSpeed / 1e3
			}s infinite; } ${i}.with-delay { animation-delay: 500ms; } ${i}.disabled { animation: none; }`,
			r
		);
	};
var yc = (r, e) => new Array(e).fill(r);
const fm = ({ queueItems: r, selector: e, cursorPosition: t, to: i }) => {
	if (m0(e)) return e * -1;
	let n = new RegExp(BE, 'i').test(i),
		a = e
			? [...r].reverse().findIndex(({ char: o }) => {
				let l = o.parentElement,
					c = l.matches(e);
				return n && c ? !0 : c && l.firstChild.isSameNode(o);
			})
			: -1;
	a < 0 && (a = n ? 0 : r.length - 1);
	let s = n ? 0 : 1;
	return a - t + s;
};
let aA = async (r, e) => {
	let t = async () => {
		var i;
		return (i = r.func) == null ? void 0 : i.call(globalThis);
	};
	r.delay
		? await e(async () => {
			await t();
		}, r.delay)
		: await t();
};
const vh = function (r, e = {}) {
		let t = async (k, P, Z = !1) => {
				b.frozen &&
                    (await new Promise((J) => {
                    	this.unfreeze = () => {
                    		(b.frozen = !1), J();
                    	};
                    })),
				Z || (await E.beforeStep(this)),
				await rA(k, P, G),
				Z || (await E.afterStep(this));
			},
			i = () => fh(D),
			n = (k = 0) => jE(E)[k],
			a = () => YE(D),
			s = (k = {}) => {
				let P = k.delay;
				P && z.add({ delay: P });
			},
			o = (k, P) => (z.add(k), s(P), this),
			l = () => (B != null ? B : re),
			c = (k = {}) => [{ func: () => S(k) }, { func: () => S(E) }],
			u = (k) => {
				let P = E.nextStringDelay;
				z.add([{ delay: P[0] }, ...k, { delay: P[1] }]);
			},
			h = () => {
				if (i()) return;
				let k = Lo('span');
				return (
					(k.className = ks),
					V
						? ((k.innerHTML = u0(E.cursorChar).innerHTML), k)
						: ((k.style.visibility = 'hidden'), k)
				);
			},
			d = async () => {
				!i() && H && D.appendChild(H), V && nA(j, E, D);
			},
			p = (k) => {
				V &&
                    H &&
                    (H.classList.toggle('disabled', k),
                    H.classList.toggle('with-delay', !k));
			},
			g = () => {
				let k = E.strings.filter((P) => !!P);
				k.forEach((P, Z) => {
					if ((this.type(P), Z + 1 === k.length)) return;
					let J = E.breakLines
						? [{ func: () => A(Lo('BR')), typeable: !0 }]
						: yc({ func: I, delay: n(1) }, z.getTypeable().length);
					u(J);
				});
			},
			m = async (k) => {
				let P = l();
				P && (await x({ value: P }));
				for (let Z of a()) await t(I, n(1));
				z.reset(), z.set(0, { delay: k });
			},
			f = (k) => {
				let P = D.innerHTML;
				return P
					? ((D.innerHTML = ''),
					E.startDelete
						? ((D.innerHTML = P), mh(D), u([{ func: I }]), k)
						: P.replace(/<!--(.+?)-->/g, '')
							.trim()
							.split(/<br(?:\s*?)(?:\/)?>/)
							.concat(k))
					: k;
			},
			v = async (k = !0) => {
				b.started = !0;
				try {
					for (let [Z, J] of z.getQueue())
						J.done ||
                            (J.typeable && !b.frozen && p(!0),
                            (!J.deletable || (J.deletable && a().length)) &&
                                (await aA(J, t)),
                            p(!1),
                            z.done(Z, !k));
					if (!k) return this;
					if (
						((b.completed = !0),
						await E.afterComplete(this),
						!E.loop)
					)
						throw '';
					let P = E.loopDelay;
					t(async () => {
						await m(P[0]), v();
					}, P[1]);
				} catch {}
				return this;
			},
			x = async (k) => {
				(re = JE(k, re, a())), QE(D, a(), re);
			},
			A = (k) => KE(D, k),
			S = async (k) => (E = xo(E, k)),
			M = async () => {
				if (i()) {
					D.value = '';
					return;
				}
				a().forEach(vc);
			},
			I = () => {
				let k = a();
				!k.length ||
                    (i() ? (D.value = D.value.slice(0, -1)) : vc(k[re]));
			};
		(this.break = function (k) {
			return o({ func: () => A(Lo('BR')), typeable: !0 }, k);
		}),
		(this.delete = function (k = null, P = {}) {
			k = Fn(k);
			let Z = c(P),
				J = k,
				{ instant: fe, to: ce } = P,
				xe = z.getTypeable(),
				W = (() =>
					J === null
						? xe.length
						: m0(J)
							? J
							: fm({
								queueItems: xe,
								selector: J,
								cursorPosition: l(),
								to: ce
							}))();
			return o(
				[
					Z[0],
					...yc(
						{ func: I, delay: fe ? 0 : n(1), deletable: !0 },
						W
					),
					Z[1]
				],
				P
			);
		}),
		(this.empty = function (k = {}) {
			return o({ func: M }, k);
		}),
		(this.exec = function (k, P = {}) {
			let Z = c(P);
			return o([Z[0], { func: () => k(this) }, Z[1]], P);
		}),
		(this.move = function (k, P = {}) {
			k = Fn(k);
			let Z = c(P),
				{ instant: J, to: fe } = P,
				ce = fm({
					queueItems: z.getTypeable(),
					selector: k === null ? '' : k,
					to: fe,
					cursorPosition: l()
				}),
				xe = ce < 0 ? -1 : 1;
			return (
				(B = l() + ce),
				o(
					[
						Z[0],
						...yc(
							{ func: () => x(xe), delay: J ? 0 : n() },
							Math.abs(ce)
						),
						Z[1]
					],
					P
				)
			);
		}),
		(this.options = function (k, P = {}) {
			return (k = Fn(k)), S(k), o({}, P);
		}),
		(this.pause = function (k, P = {}) {
			return o({ delay: Fn(k) }, P);
		}),
		(this.type = function (k, P = {}) {
			k = Fn(k);
			let { instant: Z } = P,
				J = c(P),
				fe = WE(k, E.html).map((xe) => ({
					func: () => A(xe),
					char: xe,
					delay: Z || tA(xe) ? 0 : n(),
					typeable: xe.nodeType === Node.TEXT_NODE
				})),
				ce = [
					J[0],
					{ func: async () => await E.beforeString(k, this) },
					...fe,
					{ func: async () => await E.afterString(k, this) },
					J[1]
				];
			return o(ce, P);
		}),
		(this.is = function (k) {
			return b[k];
		}),
		(this.destroy = function (k = !0) {
			(G = XE(G)), Fn(k) && H && vc(H), (b.destroyed = !0);
		}),
		(this.freeze = function () {
			b.frozen = !0;
		}),
		(this.unfreeze = () => {}),
		(this.reset = function (k) {
			!this.is('destroyed') && this.destroy(),
			k ? (z.wipe(), k(this)) : z.reset(),
			(re = 0);
			for (let P in b) b[P] = !1;
			return (D[i() ? 'value' : 'innerHTML'] = ''), this;
		}),
		(this.go = function () {
			return b.started
				? this
				: (d(),
				E.waitUntilVisible
					? (ZE(D, v.bind(this)), this)
					: (v(), this));
		}),
		(this.flush = function (k = () => {}) {
			return d(), v(!1).then(k), this;
		}),
		(this.getQueue = () => z),
		(this.getOptions = () => E),
		(this.updateOptions = (k) => S(k)),
		(this.getElement = () => D);
		let D = eA(r),
			G = [],
			re = 0,
			B = null,
			b = xo({}, FE),
			E = xo(HE, e);
		E = xo(E, {
			html: !i() && E.html,
			nextStringDelay: dm(E.nextStringDelay),
			loopDelay: dm(E.loopDelay)
		});
		let j = qE(),
			z = UE([{ func: () => {}, delay: E.startDelay }]);
		(D.dataset.typeitId = j), p0(GE);
		let V = E.cursor && !i(),
			H = h();
		(E.strings = f(l0(E.strings))), E.strings.length && g();
	},
	sA = {
		data() {
			return { display: !1 };
		},
		setup() {
			const r = lt('');
			r.value !== '' && r.value;
		},
		mounted() {
			new vh('#landing_intro', {
				speed: 50,
				waitUntilVisible: !0,
				startDelay: 2e3,
				startDelete: !0,
				afterComplete: function (r) {
					r.destroy();
				}
			})
				.type(
					'Hello! I am a full stack web developer based in Malaysia.'
				)
				.go();
		}
	},
	oA = { class: 'flex flex-col gap-[2.5rem]' },
	lA = { class: 'divCenter' },
	cA = {
		id: 'landing_intro',
		ref: 'landingIntro',
		class: 'lg:text-xl text-md acrlyic w-auto text-center selector'
	},
	uA = Qo(
		'<section class=""><h1 class="text-4xl font-bold">Aaron Lyn</h1><h3 class="text-lg">Professional web developer</h3></section><section class="pt-2"><h2 class="lg:text-2xl text-lg font-bold underline underline-offset-8 decoration-2"> Professional background </h2><br><p class="lg:text-lg text-sm text-justify leading-6"> \xA0\xA0\xA0\xA0 Professional junior web developer capable professional looking and user-friendly websites from stratch and writes <strong>performance optimized, reusable and refactorable codes</strong>. Professionally developed 5 web applications with multiple Javascript frameworks. </p><br><p class="lg:text-lg text-sm text-justify leading-6"> Hungry for knowledge, collaborative individual and possess analytical skills. Enjoys problem solving and willing to adapt to changes in the industry to stay on top. </p></section><section class=""><h2 class="lg:text-2xl text-lg font-bold underline underline-offset-8 decoration-2"> Bio </h2><br><p class="lg:text-lg text-sm text-justify leading-6"> \xA0\xA0\xA0\xA0 Aaron has a strong passion on technology and computers. Outside of programmimg, Aaron has a hobby of collecting and engage with technology. He likes to tinker with his Arch Linux Operating System and enjoys collecting custom keyboards. </p></section><section class=""><h2 class="lg:text-2xl text-lg font-bold underline underline-offset-8 decoration-2"> Journey </h2><br><div class="flex flex-col gap-2"><p class="lg:text-lg text-sm text-justify"><strong>2017:</strong> \xA0 Started journey on programming as a hobby </p><p class="lg:text-lg text-sm text-justify"><strong>2020:</strong> \xA0 Enrolled for diploma of ICT with specalism in software engineering </p><p class="lg:text-lg text-sm text-justify"><strong>2022:</strong> \xA0 Started journey on web development </p></div></section>',
		4
	);
function hA(r, e, t, i, n, a) {
	return Ce(), Oe('div', oA, [ee('div', lA, [ee('p', cA, null, 512)]), uA]);
}
var dA = Yt(sA, [['render', hA]]),
	pA = [
		{
			Image: './assets/images/work1.png',
			Title: 'Shopify Clone',
			Description:
                'Shopify is a popular E-commerce website that allows the user to setup an online store and sell their products. This project clones the basic functionalities of shopify such as user interface, user authentication functionalities, along with adding products to database ',
			Sidenote:
                'This is Aaron\'s first project developed in Vue3 and Laravel',
			Github: 'https://github.com/Kuon-dev/Shopify-Clone',
			Tags: ['Vue3', 'Laravel', 'PHP', 'MySQL', 'TailwindCSS']
		},
		{
			Image: './assets/images/work2.png',
			Title: 'Mersing Website with Chatbot',
			Description:
                'Mersing is a tourism spot located in West Malaysia, the purpose of this website is to boost the tourism industry of this location by making a AI Chatbot powered by Microsoft Virtual Agent ',
			Sidenote: '',
			Github: 'https://github.com/Kuon-dev/IaI-project',
			Tags: ['Vue3', 'TailwindCSS', 'Microsoft Virtual Agent', 'API']
		},
		{
			Image: './assets/images/work3.png',
			Title: 'Paws Heaven E-commerce Website',
			Description:
                'Paws Heaven is an online E-commerce website developed by a team of 3 developers. Paws Heaven offers a variety of pet products such as food, vitamins and cages ',
			Sidenote: '',
			Github: 'https://github.com/Kuon-dev/WDT-assignment',
			Tags: ['PHP', 'HTML5', 'CSS3', 'MYSQL']
		}
	];
const mA = {
		name: 'TagsComponent',
		props: { tagSettings: { type: Array, required: !1 } }
	},
	fA = { class: 'mt-5' },
	gA = { class: 'flex flex-row gap-5 flex-wrap' };
function vA(r, e, t, i, n, a) {
	return (
		Ce(),
		Oe('div', fA, [
			ee('ul', gA, [
				(Ce(!0),
				Oe(
					gt,
					null,
					Zr(
						t.tagSettings,
						(s, o) => (
							Ce(),
							Oe(
								'li',
								{
									key: o,
									class: 'tags lg:text-md text-sm text-center selector rounded-md xl:p-3 xl:px-4 p-2 px-3 cursor-default transition ease-in-out hover:rotate-6'
								},
								vr(s),
								1
							)
						)
					),
					128
				))
			])
		])
	);
}
var yA = Yt(mA, [
	['render', vA],
	['__scopeId', 'data-v-56e9355d']
]);
const xA = {
		components: { TagsComponent: yA },
		data() {
			return { worksData: pA, indexMaxLength: 0, isInMobile: !1 };
		},
		setup() {
			const r = lt('');
			r.value !== '' && r.value;
		},
		mounted() {
			(this.indexMaxLength = this.worksData.length - 1),
			new vh('#works_intro', {
				speed: 50,
				waitUntilVisible: !0,
				startDelay: 2e3,
				startDelete: !0,
				afterComplete: function (r) {
					r.destroy();
				}
			})
				.type('Here are a list of my personal projects!')
				.go(),
			window.innerWidth < 1536 && (this.isInMobile = !0);
		}
	},
	bA = { class: 'divCenter' },
	wA = {
		id: 'works_intro',
		class: 'lg:text-xl text-md acrlyic w-auto text-center selector',
		ref: 'worksIntro'
	},
	_A = ee('br', null, null, -1),
	MA = ee(
		'div',
		null,
		[
			ee(
				'h2',
				{ class: 'text-2xl font-bold underline underline-offset-1' },
				'Works'
			)
		],
		-1
	),
	SA = ee('br', null, null, -1),
	TA = { class: 'flex flex-col divCenter pt-5' },
	EA = { class: 'xl:max-w-[40rem] w-auto 2xl:block hidden' },
	AA = ['src'],
	LA = { class: '2xl:pt-2 xl:max-w-[40rem]' },
	RA = {
		class: 'lg:text-xl pb-4 sm:pb-0 text-lg font-bold underline sm:underline-offset-8 decoration-3 sm:decoration-4 whitespace-nowrap'
	},
	kA = { class: 'xl:max-w-[40rem] w-auto 2xl:hidden flex flex-col' },
	CA = ['src'],
	PA = { class: 'lg:text-lg text-md text-justify py-2 2xl:py-5' },
	IA = {
		key: 0,
		class: 'lg:text-lg text-sm text-justify leading-6 2xl:py-2 py-3'
	},
	DA = ee('br', null, null, -1),
	OA = { class: 'decoration-2 underline' },
	NA = ['href'],
	zA = { key: 1, class: 'mt-3' },
	UA = ee('br', null, null, -1),
	BA = { style: { 'border-color': 'var(--text-highlight)' } };
function FA(r, e, t, i, n, a) {
	const s = yr('TagsComponent');
	return (
		Ce(),
		Oe('section', null, [
			ee('div', bA, [ee('p', wA, null, 512)]),
			_A,
			MA,
			SA,
			ee('div', TA, [
				(Ce(!0),
				Oe(
					gt,
					null,
					Zr(
						n.worksData,
						(o, l) => (
							Ce(),
							Oe(
								'div',
								{
									class: nr([
										'flex 2xl:flex-row flex-col xl:gap-[3rem] gap-[3rem] 2xl:mb-[5rem] mb-[3rem]',
										l % 2 !== 0 && !n.isInMobile
											? '2xl:flex-row-reverse flex-col-reverse'
											: null
									]),
									key: l
								},
								[
									ee('div', EA, [
										ee(
											'img',
											{
												src: o.Image,
												class: 'bg-auto bg-center rounded-md border-2 min-w-32'
											},
											null,
											8,
											AA
										),
										Ge(
											s,
											{
												tagSettings: o.Tags,
												class: 'pt-3'
											},
											null,
											8,
											['tagSettings']
										)
									]),
									ee('div', LA, [
										ee('h2', RA, vr(o.Title), 1),
										ee('div', kA, [
											ee(
												'img',
												{
													src: o.Image,
													class: 'bg-auto bg-center rounded-md border-2'
												},
												null,
												8,
												CA
											),
											Ge(
												s,
												{
													tagSettings: o.Tags,
													class: 'pt-3 pb-3'
												},
												null,
												8,
												['tagSettings']
											)
										]),
										ee('p', PA, vr(o.Description), 1),
										o.Sidenote !== ''
											? (Ce(),
											Oe('p', IA, vr(o.Sidenote), 1))
											: Ot('', !0),
										DA,
										ee('strong', OA, [
											ee(
												'a',
												{ href: o.Github },
												'View this project on Github',
												8,
												NA
											)
										]),
										n.isInMobile
											? (Ce(),
											Oe('div', zA, [
												UA,
												Yr(ee('hr', BA, null, 512), [
													[
														ps,
														l !== n.indexMaxLength
													]
												])
											]))
											: Ot('', !0)
									])
								],
								2
							)
						)
					),
					128
				))
			])
		])
	);
}
var HA = Yt(xA, [['render', FA]]),
	f0 = [
		{
			type: 'frontend',
			technologies: [
				{ title: 'React', image: 'devicon-react-original' },
				{ title: 'Vue', image: 'devicon-vuejs-plain' },
				{ title: 'ThreeJS', image: 'devicon-threejs-original' },
				{
					title: 'Javascript (ES6)',
					image: 'devicon-javascript-plain'
				},
				{ title: 'HTML5', image: 'devicon-html5-plain' },
				{ title: 'CSS3', image: 'devicon-css3-plain' },
				{ title: 'Tailwind', image: 'devicon-tailwindcss-plain' }
			]
		},
		{
			type: 'backend',
			technologies: [
				{ title: 'Python', image: 'devicon-python-plain' },
				{ title: 'Node', image: 'devicon-nodejs-plain' },
				{ title: 'Java', image: 'devicon-java-plain' },
				{ title: 'MongoDB', image: 'devicon-mongodb-plain' },
				{ title: 'Laravel', image: 'devicon-laravel-plain' }
			]
		},
		{
			type: 'tools',
			technologies: [
				{ title: 'Markdown', image: 'devicon-markdown-original' },
				{ title: 'Vim', image: 'devicon-vim-plain' },
				{ title: 'Figma', image: 'devicon-figma-plain' },
				{ title: 'Linux (Arch)', image: 'devicon-linux-plain' }
			]
		}
	];
const GA = {
		name: 'CardComponent',
		props: {
			title: { type: String, required: !1, default: null },
			image: { type: String, required: !1, default: null },
			argOne: { type: String, required: !1, default: null },
			argTwo: { type: String, required: !1, default: null },
			isParagraph: { type: Boolean, default: !1 }
		},
		data() {
			return { isHovering: !1, isClicked: !1 };
		},
		mounted() {}
	},
	VA = {
		key: 0,
		class: 'flex flex-col items-center gap-2 animate__animated animate__fadeIn animate__fast'
	},
	WA = { class: 'font-bold whitespace-nowrap' },
	jA = { key: 1 },
	XA = { class: 'transition ease-in-out px-2 text-lg' };
function qA(r, e, t, i, n, a) {
	return (
		Ce(),
		Oe('div', null, [
			ee(
				'div',
				{
					class: nr([
						'selector py-1 pt-2 rounded-lg transition ease-in-out border-wrapper-hover',
						[
							t.isParagraph
								? 'px-2 overflow-y-scroll h-[12rem] w-[12rem] icon-highlight-focus'
								: 'div-center hover:rotate-6 w-[10rem] h-[8rem] icon-highlight hover:border-2',
							n.isClicked && t.isParagraph
								? 'icon-highlight border-2'
								: 'paragraph-option'
						]
					]),
					onMouseenter: e[0] || (e[0] = (s) => (n.isHovering = !0)),
					onMouseleave:
                        e[1] ||
                        (e[1] = (s) => {
                        	(n.isHovering = !1), (n.isClicked = !1);
                        }),
					onClick:
                        e[2] || (e[2] = (s) => (n.isClicked = !n.isClicked))
				},
				[
					t.isParagraph
						? (Ce(),
						Oe('div', jA, [
							ee(
								'div',
								XA,
								vr(n.isClicked ? t.argOne : t.title),
								1
							)
						]))
						: (Ce(),
						Oe('div', VA, [
							ee(
								'i',
								{
									class: nr([t.image, 'text-7xl']),
									style: { 'font-weight': 'normal' }
								},
								null,
								2
							),
							ee('p', WA, vr(t.title), 1)
						]))
				],
				34
			)
		])
	);
}
var YA = Yt(GA, [
	['render', qA],
	['__scopeId', 'data-v-e8f66912']
]);
const ZA = {
		name: 'SkillBarContent',
		components: { CardComponent: YA },
		props: {
			title: { type: String, required: !1 },
			description: { type: String, required: !1 },
			duration: { type: String, required: !1 },
			image: { type: String, required: !1 }
		},
		data() {
			return {
				skillData: f0,
				typeOfSkill: ['frontend', 'backend', 'tools'],
				isSkillActive: { frontend: !1, backend: !1, tools: !1 },
				isHoveringNavbar: !1,
				selectedTech: this.currentSelectedTechnology(0),
				selectedLang: this.currentSelectedLang()
			};
		},
		setup() {},
		watch: {},
		mounted() {
			this.currentSelectedTechnology(0), this.setDefaultSelectLang(0);
		},
		methods: {
			currentSelectedTechnology(r) {
				switch (r) {
				case 0:
					this.selectedTech = 'frontend';
					break;
				case 1:
					this.selectedTech = 'backend';
					break;
				case 2:
					this.selectedTech = 'tools';
					break;
				}
			},
			currentSelectedLang(r) {
				this.selectedLang = r;
			},
			setDefaultSelectLang(r) {
				const e = this.skillData[r].technologies[0].title;
				this.selectedLang = e;
			}
		}
	},
	$A = { class: 'flex sm:flex-row flex-col lg:pt-10' },
	KA = { class: 'flex flex-row sm:flex-col mt-4 ml-[auto] sm:ml-0' },
	JA = ['onClick'],
	QA = { class: 'mt-5 lg:-mt-5 lg:pt-0' },
	eL = {
		key: 0,
		class: 'flex sm:flex-row flex-col gap-2 lg:gap-8 ml-0 sm:ml-4 animate__animated animate__fadeIn'
	},
	tL = { class: 'grid lg:grid-cols-4 sm:grid-cols-3 grid-cols-2' };
function rL(r, e, t, i, n, a) {
	const s = yr('CardComponent');
	return (
		Ce(),
		Oe('section', $A, [
			ee('div', KA, [
				(Ce(!0),
				Oe(
					gt,
					null,
					Zr(
						n.typeOfSkill,
						(o, l) => (
							Ce(),
							Oe(
								'button',
								{
									key: l,
									class: nr([
										'px-4 py-3 selector-bg-hover left-border-one text-left text-lg sm:border-l-2 sm:border-b-0 border-l-0 border-b-2 transition ease-in-out delay-100 translate font-bold',
										n.selectedTech === o
											? 'left-border-two sm:border-l-3 sm:border-b-0 border-l-0 border-b-3'
											: null
									]),
									onClick: (c) => {
										a.currentSelectedTechnology(l),
										a.setDefaultSelectLang(l);
									}
								},
								vr(o),
								11,
								JA
							)
						)
					),
					128
				))
			]),
			ee('div', QA, [
				(Ce(!0),
				Oe(
					gt,
					null,
					Zr(
						n.skillData,
						(o, l) => (
							Ce(),
							Oe(
								'div',
								{ key: l, class: 'flex flex-row sm:flex-col' },
								[
									o.type === n.selectedTech
										? (Ce(),
										Oe('div', eL, [
											ee('div', tL, [
												(Ce(!0),
												Oe(
													gt,
													null,
													Zr(
														o.technologies,
														(c, u) => (
															Ce(),
															en(
																s,
																{
																	key: u,
																	onClick: (
																		h
																	) =>
																		a.currentSelectedLang(
																			c.title
																		),
																	class: nr(
																		[
																			'px-2 sm:px-5 py-2 left-border-one transition ease-in-out delay-100 flex',
																			n.selectedLang ===
                                                                              c.title
																				? 'left-border-two'
																				: null
																		]
																	),
																	title: c.title,
																	image: c.image
																},
																null,
																8,
																[
																	'onClick',
																	'class',
																	'title',
																	'image'
																]
															)
														)
													),
													128
												))
											])
										]))
										: Ot('', !0)
								]
							)
						)
					),
					128
				))
			])
		])
	);
}
var iL = Yt(ZA, [['render', rL]]);
const nL = {
		data() {
			return { skillsData: f0, paddingValue: 0, loaded: !1 };
		},
		props: { responsiveValue: { type: Number, default: 0 } },
		components: { SkillBarContent: iL },
		methods: {
			fetch: function () {
				console.log(document.getElementById('render'));
			}
		},
		setup() {
			let r = lt(''),
				e = lt('');
			const t = () => {
					r.value.innerHTML = null;
				},
				i = () => {
					e.value.innerText = null;
				},
				n = mr(() => {
					if (
						e.value.innerText === null ||
                        e.value.innerText === void 0
					)
						return null;
					let a = e.value.innerText;
					return (a = a.replaceAll('|', '')), a;
				});
			return (
				As(() => {
					(window.Prism = window.Prism || {}),
					(window.Prism.manual = !0),
					setTimeout(() => {}, 5e3);
				}),
				{
					contentRenderer: r,
					textField: e,
					clearCodeBlock: t,
					clearTerminalBlock: i,
					renderOutTextField: n
				}
			);
		},
		watch: {
			windowWidth() {
				this.windowWidth > 1280
					? (this.paddingValue =
                          Math.trunc(this.windowWidth - 1280) / 2)
					: this.windowWidth < 1280 && (this.paddingValue = 0);
			}
		},
		mounted() {
			const r = () => {
					const i = document.getElementById('demo').innerHTML;
					document.getElementById('render').innerHTML = '';
					let n = i.replaceAll(
						'<span class="ti-cursor with-delay">|</span>',
						''
					);
					(n = n.replaceAll('&lt;', '<')),
					(n = n.replaceAll('&gt;', '>')),
					(n = n.replaceAll('&nbsp;', '')),
					(n = n.replaceAll(
						'<span class="html-tag">div</span>',
						'div'
					)),
					(n = n.replaceAll(
						'<span class="html-attribute">class</span>',
						'class'
					)),
					(n = n.replaceAll(
						'<span class="html-tag">lable</span>',
						'lable'
					)),
					(n = n.replaceAll(
						'<span class="html-tag">input</span>',
						'input'
					)),
					(n = n.replaceAll(
						'<span class="html-attribute">placeholder</span>',
						'placeholder'
					));
					const a = document.createElement('div');
					(a.innerHTML = n),
					a.classList.add('rendered-contents'),
					document.getElementById('render').appendChild(a);
				},
				e = () => {
					document
						.querySelector('.rendered-contents')
						.classList.replace(
							'rendered-contents',
							'rem-rendered-contents'
						);
				},
				t = () => {
					let i = document.getElementById('demo').innerHTML;
					(i = i.replaceAll(
						'<span class="ti-cursor with-delay">|</span>',
						''
					)),
					(i = i.replaceAll(
						'<span class="html-tag">div</span>',
						'div'
					)),
					(i = i.replaceAll(
						'<span class="html-tag">lable</span>',
						'lable'
					)),
					(i = i.replaceAll(
						'<span class="html-tag">input</span>',
						'input'
					)),
					(i = i.replaceAll(
						'<span class="html-attribute">class</span>',
						'class'
					)),
					(i = i.replaceAll(
						'<span class="html-attribute">placeholder</span>',
						'placeholder'
					));
					let n = i.replaceAll(
						'class',
						'<span class="html-attribute">class</span>'
					);
					(n = n.replaceAll(
						'placeholder',
						'<span class="html-attribute">placeholder</span>'
					)),
					(n = n.replaceAll(
						'div',
						'<span class="html-tag">div</span>'
					)),
					(n = n.replaceAll(
						'lable',
						'<span class="html-tag">lable</span>'
					)),
					(n = n.replaceAll(
						'input',
						'<span class="html-tag">input</span>'
					)),
					(n = n + '<span class="ti-cursor with-delay">|</span>'),
					(document.getElementById('demo').innerHTML = n);
				};
			new vh('#demo', {
				speed: 30,
				waitUntilVisible: !0,
				startDelay: 2e3,
				startDelete: !0,
				loop: !0
			})
				.type('<', { speed: 30 })
				.type('div class=\'flex lg:flex-row flex-col\'>')
				.break()
				.pause(1)
				.exec(async () => {
					await new Promise((i, n) => {
						t(), setTimeout(() => i(), 1);
					});
				})
				.type('&nbsp&nbsp<')
				.type('div class=\'flex flex-row gap-4\'>')
				.break()
				.pause(1)
				.exec(async () => {
					await new Promise((i, n) => {
						t(), setTimeout(() => i(), 1);
					});
				})
				.type('&nbsp&nbsp&nbsp&nbsp<')
				.type('div class=\'bg-sky-600 px-2\'>1<')
				.type('/div>')
				.break()
				.pause(1)
				.exec(async () => {
					await new Promise((i, n) => {
						t(), setTimeout(() => i(), 1);
					});
				})
				.type('&nbsp&nbsp&nbsp&nbsp<')
				.type('div class=\'bg-rose-600 px-2\'>2<')
				.type('/div>')
				.break()
				.pause(1)
				.exec(async () => {
					await new Promise((i, n) => {
						t(), setTimeout(() => i(), 1);
					});
				})
				.type('&nbsp&nbsp<')
				.type('/div>')
				.break()
				.pause(1)
				.exec(async () => {
					await new Promise((i, n) => {
						t(), setTimeout(() => i(), 1);
					});
				})
				.type('&nbsp&nbsp<')
				.type('div class=\'flex flex-row gap-4\'>')
				.break()
				.pause(1)
				.exec(async () => {
					await new Promise((i, n) => {
						t(), setTimeout(() => i(), 1);
					});
				})
				.type('&nbsp&nbsp&nbsp&nbsp<')
				.type('div class=\'bg-lime-600 px-2\'>1<')
				.type('/div>')
				.break()
				.pause(1)
				.exec(async () => {
					await new Promise((i, n) => {
						t(), setTimeout(() => i(), 1);
					});
				})
				.type('&nbsp&nbsp&nbsp&nbsp<')
				.type('div class=\'bg-teal-600 px-2\'>2<')
				.type('/div>')
				.break()
				.pause(1)
				.exec(async () => {
					await new Promise((i, n) => {
						t(), setTimeout(() => i(), 1);
					});
				})
				.type('&nbsp&nbsp<')
				.type('/div>')
				.break()
				.pause(1)
				.exec(async () => {
					await new Promise((i, n) => {
						t(), setTimeout(() => i(), 1);
					});
				})
				.type('<')
				.type('/div>')
				.pause(1)
				.exec(async () => {
					await new Promise((i, n) => {
						t(), setTimeout(() => i(), 1);
					});
				})
				.pause(1e3)
				.exec(async () => {
					await new Promise((i, n) => {
						this.clearCodeBlock(), r(), setTimeout(() => i(), 2e3);
					});
				})
				.delete()
				.pause(1e3)
				.type('<')
				.type('lable> Email: <')
				.type('/lable>')
				.break()
				.pause(1)
				.exec(async () => {
					await new Promise((i, n) => {
						t(), setTimeout(() => i(), 1);
					});
				})
				.type('<')
				.type('input placeholder=\'email\' class=\'p-1 w-20\'>', {
					speed: 50
				})
				.pause(1)
				.exec(async () => {
					await new Promise((i, n) => {
						t(), setTimeout(() => i(), 1);
					});
				})
				.pause(2e3)
				.exec(async () => {
					await new Promise((i, n) => {
						e(), setTimeout(() => i(), 500);
					});
				})
				.pause(500)
				.exec(async () => {
					await new Promise((i, n) => {
						this.clearCodeBlock(), r(), setTimeout(() => i(), 500);
					});
				})
				.pause(2e3)
				.go();
		}
	},
	aL = ee(
		'div',
		null,
		[
			ee(
				'h2',
				{
					class: 'lg:text-2xl text-lg font-bold underline underline-offset-8 decoration-2'
				},
				' Overview '
			),
			ee('br'),
			ee('p', { class: 'lg:text-lg text-sm text-justify leading-6' }, [
				ar(
					' \xA0\xA0\xA0\xA0 Aaron is a full-stacked developer focused on '
				),
				ee('strong', null, ' VueJS and PHP Laravel '),
				ar(
					'. He also possess soft skills to further enhance himself as a web developer with skills such as communication skills, creativity, problem solving, and adaptability. '
				)
			])
		],
		-1
	),
	sL = ee('br', null, null, -1),
	oL = ee('br', null, null, -1),
	lL = ee('br', null, null, -1),
	cL = ee(
		'h2',
		{
			class: 'lg:text-2xl text-lg font-bold underline underline-offset-8 decoration-2'
		},
		' My technology ',
		-1
	),
	uL = { class: 'pt-[3.5rem] sm:px-10 transition ease-in-out' },
	hL = {
		class: 'lg:text-md md:text-sm text-[0.6rem] acrlyic selector min-h-[10rem] py-2 px-1 rounded-xl'
	},
	dL = Qo(
		'<div class="flex flex-row ml-2"><div class="code-block-terminal sm:h-4 h-2 sm:w-4 w-2 bg-rose-500"></div><div class="code-block-terminal sm:h-4 h-2 sm:w-4 w-2 bg-yellow-500"></div><div class="code-block-terminal sm:h-4 h-2 sm:w-4 w-2 bg-green-500"></div></div><div class="code-block-lines flex h-[0.05rem] w-full"></div>',
		2
	),
	pL = {
		class: 'flex flex-row mt-3 leading-4 md:leading-6 overflow-x-scroll relative'
	},
	mL = ee(
		'div',
		{
			class: 'code-block-lines min-h-[10rem] w-[0.05rem] mx-2 sm:mx-3 flex selector leading-4 md:leading-6'
		},
		null,
		-1
	),
	fL = { id: 'demo', class: '', ref: 'textField' },
	gL = {
		id: 'render',
		class: 'mt-5 acrlyic selector py-10 px-5 rounded-xl',
		ref: 'contentRenderer'
	};
function vL(r, e, t, i, n, a) {
	const s = yr('SkillBarContent');
	return (
		Ce(),
		Oe('div', null, [
			ee('div', null, [
				aL,
				sL,
				oL,
				lL,
				cL,
				Ge(s),
				ee('div', uL, [
					ee('div', hL, [
						dL,
						ee('div', pL, [
							ee('div', null, [
								(Ce(),
								Oe(
									gt,
									null,
									Zr(12, (o) =>
										ee(
											'div',
											{
												key: o,
												class: 'flex flex-col sm:ml-3 text-center'
											},
											vr(o),
											1
										)
									),
									64
								))
							]),
							mL,
							ee('div', null, [ee('code', fL, null, 512)])
						])
					]),
					ee('div', gL, null, 512)
				])
			])
		])
	);
}
var yL = Yt(nL, [['render', vL]]);
const xL = {
		setup() {
			const r = {}.VITE_API_ENDPOINT + '/message',
				e = lt(!1),
				t = lt(''),
				i = lt(''),
				n = lt(''),
				a = lt(''),
				s = lt(!1),
				o = lt(!1),
				l = lt(!1),
				c = lt(!1),
				u = lt(!1);
			return {
				submitHandler: (h) => {
					var d;
					if (
						((s.value = !1),
						(o.value = !1),
						(l.value = !1),
						(c.value = !1),
						(u.value = !1),
						(e.value = !1),
						t.value || (s.value = !0),
						n.value || (o.value = !0),
						a.value || (l.value = !0),
						l.value || o.value || s.value)
					)
						return;
					const p = /^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/g;
					if (!n.value.match(p)) {
						c.value = !0;
						return;
					}
					const g = {
						firstName: t.value,
						lastName: (d = i.value) != null ? d : '',
						userEmail: n.value,
						userMessage: a.value
					};
					(async () => (
						await fetch(r, {
							method: 'POST',
							headers: {
								Accept: 'application/json',
								'Content-Type': 'application/json'
							},
							body: JSON.stringify(g)
						})
							.then((m) => m.json())
							.catch((m) => {
								console.log(m), (e.value = !0);
							}),
						e.value || (u.value = !0)
					))();
				},
				firstName: t,
				lastName: i,
				userEmail: n,
				userText: a,
				showNoFirstName: s,
				showNoEmail: o,
				showNoMessage: l,
				showInvalidEmail: c,
				showPostSuccess: u,
				failedPost: e
			};
		}
	},
	mn = (r) => (qm('data-v-c0285922'), (r = r()), Ym(), r),
	bL = Qo(
		'<section class="" data-v-c0285922><h2 class="lg:text-2xl text-lg font-bold underline underline-offset-8 decoration-2" data-v-c0285922> Get in touch </h2><br data-v-c0285922><p class="lg:text-lg text-sm text-justify leading-6" data-v-c0285922> \xA0\xA0\xA0\xA0 Have an idea you want it to become a reality? I can make it happen for you! Don&#39;t feel hesitated to contact me, I will be responding to your messages as soon as possible. </p></section><section class="divCenter pt-5 8xl:ml-[-70rem] 7xl:ml-[-55rem] 6xl:ml-[-20rem] 5xl:ml-[-10rem] 4xl:ml-[-5rem] 3xl:ml-[-2rem] xl:mr-[40rem] lg:mr-[27rem] md:mr-[15rem] sm:ml-[0rem] ml-[3rem] flex flex-col w-full" data-v-c0285922><div id="Contact_ThreeContainer" class="-mt-10 pl-20 hidden" data-v-c0285922></div></section><section class="pt-5" data-v-c0285922><p class="lg:text-lg text-sm text-justify leading-6" data-v-c0285922> You can reach me by emailing me at <strong data-v-c0285922>aaronlyn88@gmail.com</strong>. I will be able to reply to your mail within 2 days of working days. </p></section><br data-v-c0285922>',
		4
	),
	wL = { class: '' },
	_L = { class: 'lg:text-lg text-sm text-justify leading-6' },
	ML = ar(' You can visit my '),
	SL = { class: 'underline' },
	TL = ar('portfolio'),
	EL = ar(' to view my works. Alternatively, you can visit my '),
	AL = mn(() =>
		ee(
			'strong',
			{ class: 'underline' },
			[
				ee(
					'a',
					{ href: 'https://github.com/Kuon-dev' },
					'Github Profile'
				)
			],
			-1
		)
	),
	LL = ar(' to view my projects posted on Github '),
	RL = { class: 'pt-10 hidden' },
	kL = mn(() =>
		ee(
			'div',
			{ class: '' },
			[
				ee(
					'h2',
					{
						class: 'lg:text-2xl text-lg font-bold underline underline-offset-8 decoration-2'
					},
					' Send me a message! '
				)
			],
			-1
		)
	),
	CL = { class: 'divCenter pt-10' },
	PL = { class: 'w-full max-w-lg' },
	IL = { class: 'flex flex-wrap -mx-3 mb-6' },
	DL = { class: 'w-full md:w-1/2 px-3 mb-6 md:mb-0' },
	OL = mn(() =>
		ee(
			'label',
			{
				class: 'block uppercase tracking-wide text-xs font-bold mb-2',
				for: 'grid-first-name'
			},
			' First Name ',
			-1
		)
	),
	NL = { key: 0, class: 'text-red-500 text-xs italic' },
	zL = { class: 'w-full md:w-1/2 px-3' },
	UL = mn(() =>
		ee(
			'label',
			{
				class: 'block uppercase tracking-wide text-xs font-bold mb-2',
				for: 'grid-last-name'
			},
			' Last Name (optional) ',
			-1
		)
	),
	BL = { class: 'flex flex-wrap -mx-3 mb-6' },
	FL = { class: 'w-full px-3' },
	HL = mn(() =>
		ee(
			'label',
			{
				class: 'block uppercase tracking-wide text-xs font-bold mb-2',
				for: 'grid-password'
			},
			' E-mail ',
			-1
		)
	),
	GL = { key: 0, class: 'text-red-500 text-xs italic' },
	VL = { key: 1, class: 'text-red-500 text-xs italic' },
	WL = { class: 'flex flex-wrap -mx-3 mb-6' },
	jL = { class: 'w-full px-3' },
	XL = mn(() =>
		ee(
			'label',
			{
				class: 'block uppercase tracking-wide text-xs font-bold mb-2',
				for: 'grid-password'
			},
			' Message ',
			-1
		)
	),
	qL = { key: 0, class: 'text-red-500 text-xs italic' },
	YL = { class: 'md:flex md:items-center' },
	ZL = { class: 'md:w-2/3' },
	$L = { key: 0, class: 'text-red-500 text-xs italic pt-5' },
	KL = { key: 1, class: 'success text-md pt-5' },
	JL = mn(() => ee('div', { class: 'md:w-1/3' }, null, -1));
function QL(r, e, t, i, n, a) {
	const s = yr('router-link');
	return (
		Ce(),
		Oe('div', null, [
			bL,
			ee('section', wL, [
				ee('p', _L, [
					ML,
					ee('strong', SL, [
						Ge(
							s,
							{ to: '/work' },
							{ default: tr(() => [TL]), _: 1 }
						)
					]),
					EL,
					AL,
					LL
				])
			]),
			ee('section', RL, [
				kL,
				ee('div', CL, [
					ee('form', PL, [
						ee('div', IL, [
							ee('div', DL, [
								OL,
								Yr(
									ee(
										'input',
										{
											class: 'appearance-none block w-full border rounded py-3 px-4 mb-3 leading-tight focus:outline-none',
											'onUpdate:modelValue':
                                                e[0] ||
                                                (e[0] = (o) =>
                                                	(i.firstName = o)),
											type: 'text',
											placeholder: 'Jane'
										},
										null,
										512
									),
									[[Us, i.firstName]]
								),
								i.showNoFirstName
									? (Ce(),
									Oe(
										'p',
										NL,
										' Please fill out this field. '
									))
									: Ot('', !0)
							]),
							ee('div', zL, [
								UL,
								Yr(
									ee(
										'input',
										{
											class: 'appearance-none block w-full border rounded py-3 px-4 leading-tight focus:outline-none',
											'onUpdate:modelValue':
                                                e[1] ||
                                                (e[1] = (o) =>
                                                	(i.lastName = o)),
											type: 'text',
											placeholder: 'Doe'
										},
										null,
										512
									),
									[[Us, i.lastName]]
								)
							])
						]),
						ee('div', BL, [
							ee('div', FL, [
								HL,
								Yr(
									ee(
										'input',
										{
											class: 'appearance-none block w-full border rounded py-3 px-4 mb-3 leading-tight focus:outline-none',
											'onUpdate:modelValue':
                                                e[2] ||
                                                (e[2] = (o) =>
                                                	(i.userEmail = o)),
											type: 'email'
										},
										null,
										512
									),
									[[Us, i.userEmail]]
								),
								i.showNoEmail
									? (Ce(),
									Oe(
										'p',
										GL,
										' Please fill out this field. '
									))
									: Ot('', !0),
								i.showInvalidEmail
									? (Ce(),
									Oe('p', VL, ' Email entered is invalid '))
									: Ot('', !0)
							])
						]),
						ee('div', WL, [
							ee('div', jL, [
								XL,
								Yr(
									ee(
										'textarea',
										{
											class: 'no-resize block w-full appearance-none border rounded py-3 px-4 mb-3 leading-tight focus:outline-none h-48 resize-none',
											placeholder:
                                                'Enter your message here',
											'onUpdate:modelValue':
                                                e[3] ||
                                                (e[3] = (o) => (i.userText = o))
										},
										null,
										512
									),
									[[Us, i.userText]]
								),
								i.showNoMessage
									? (Ce(),
									Oe(
										'p',
										qL,
										' Please fill out this field. '
									))
									: Ot('', !0)
							])
						]),
						ee('div', YL, [
							ee('div', ZL, [
								ee(
									'button',
									{
										class: 'shadow focus:shadow-outline focus:outline-none font-bold py-4 px-10 rounded',
										onClick:
                                            e[4] ||
                                            (e[4] = Lu(
                                            	(o) => i.submitHandler(o),
                                            	['prevent']
                                            ))
									},
									' Submit '
								),
								i.failedPost
									? (Ce(),
									Oe(
										'p',
										$L,
										' An error has occurred, please try again later. '
									))
									: Ot('', !0),
								i.showPostSuccess
									? (Ce(),
									Oe(
										'p',
										KL,
										' Your message has been received! '
									))
									: Ot('', !0)
							]),
							JL
						])
					])
				])
			])
		])
	);
}
var eR = Yt(xL, [
	['render', QL],
	['__scopeId', 'data-v-c0285922']
]);
const tR = {},
	rR = { class: 'divCenter flex flex-col gap-10' },
	iR = ee(
		'div',
		{
			class: 'pt-5 flex lg:flex-row flex-col lg:gap-[3rem] gap-5 items-center'
		},
		[
			ee('h2', { class: 'text-5xl' }, '404'),
			ee('p', { class: 'text-5xl lg:flex hidden' }, '|'),
			ee(
				'p',
				{ class: 'text-3xl' },
				'Oops! The page you requested could not be found...'
			)
		],
		-1
	),
	nR = {
		class: 'return_to_home_btn border-2 p-2 px-5 text-xl lg:mt-[3rem] mt-5 transition ease-in-out'
	},
	aR = ar('Back to home page');
function sR(r, e, t, i, n, a) {
	const s = yr('router-link');
	return (
		Ce(),
		Oe('div', rR, [
			iR,
			ee('div', null, [
				ee('button', nR, [
					Ge(s, { to: '/' }, { default: tr(() => [aR]), _: 1 })
				])
			])
		])
	);
}
var oR = Yt(tR, [['render', sR]]),
	lR = NE({
		history: JT(),
		routes: [
			{ path: '/', name: 'homepg', component: dA, props: !0 },
			{ path: '/work', name: 'work', component: HA, props: !0 },
			{ path: '/skills', name: 'skills', component: yL, props: !0 },
			{ path: '/contact', name: 'contact', component: eR, props: !0 },
			{
				path: '/:pathMatch(.*)*',
				name: 'notfound',
				component: oR,
				props: !0
			}
		]
	});
Jy(IT).use(lR).mount('#app');
